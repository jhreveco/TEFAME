<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ModalEspectral</title>
  <meta name="keywords" content="ModalEspectral">
  <meta name="description" content="______________________________________________________________________">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # tefame --><!-- menu.html analisis -->
<h1>ModalEspectral
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>______________________________________________________________________</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> ______________________________________________________________________
|                                                                      |
|           TEFAME - Toolbox para Elemento Finitos y Analisis          |
|                  Matricial de Estructuras en MATLAB                  |
|                                                                      |
|                   Area  de Estructuras y Geotecnia                   |
|                   Departamento de Ingenieria Civil                   |
|              Facultad de Ciencias Fisicas y Matematicas              |
|                         Universidad de Chile                         |
|                                                                      |
| TEFAME es una  plataforma en base a objetos para modelar, analizar y |
| visualizar  la respuesta de sistemas  estructurales usando el metodo |
| de elementos finitos y analisis matricial de estructuras en MATLAB.  |
| La plataforma es desarrollada en  propagacion orientada a objetos en |
| MATLAB.                                                              |
|______________________________________________________________________|
 ______________________________________________________________________
|                                                                      |
| Clase ModalEspectral                                                 |
|                                                                      |
| Este archivo contiene la definicion de la Clase ModalEspectral       |
| ModalEspectral es una clase que se usa para resolver la estructura   |
| aplicando el metodo modal espectral. Para ello se calcula la matriz  |
| de masa y de rigidez.                                                |
|                                                                      |
| Programado: Pablo Pizarro @ppizarror                                 |
| Fecha: 18/03/2019                                                    |
|______________________________________________________________________|

  Properties (Access=private):
       modeloObj
       numeroGDL
       Kt
       Mt
       gdlCond
       F
       u
       wn
       Tn
       phin
       phiExt
       condMatT
       condMatRot
       Mm
       Km
       rm
       Lm
       Mmeff
       Mmeffacum
       Mtotal
       analisisFinalizado
       numModos
       numDG
       numDGReal
       cRayleigh
       cPenzien
       mostrarDeformada
       cargarAnimacion
  Methods:
       analisisObj = ModalEspectral(modeloObjeto)
       definirNumeracionGDL(analisisObj)
       analizar(analisisObj,varargin)
       numeroEcuaciones = obtenerNumeroEcuaciones(analisisObj)
       M_Modelo = obtenerMatrizMasa(analisisObj)
       C_Modelo = obtenerMatrizAmortiguamiento(analisisObj,rayleigh)
       K_Modelo = obtenerMatrizRigidez(analisisObj)
       Cdv_Modelo = obtenerMatrizAmortiguamientoDisipadores(analisisObj)
       Kdv_Modelo = obtenerMatrizRigidezDisipadores(analisisObj)
       r_Modelo = obtenerVectorInfluencia(analisisObj)
       F_Modelo = obtenerVectorFuerzas(analisisObj)
       u_Modelo = obtenerDesplazamientos(analisisObj)
       wn_Modelo = obtenerValoresPropios(analisisObj)
       phi_Modelo = obtenerMatrizPhi(analisisObj)
       c = obtenerCargaEstatica(analisisObj,varargin)
       activarPlotDeformadaInicial(analisisObj)
       desactivarPlotDeformadaInicial(analisisObj)
       activarCargaAnimacion(analisisObj)
       desactivarCargaAnimacion(analisisObj)
       calcularMomentoCorteBasal(analisisObj,carga)
       plotTrayectoriaNodo(analisisObj,carga,nodo,direccion)
       plotEsfuerzosElemento(analisisObj,carga)
       calcularDesplazamientoDrift(analisisObj,xanalisis)
       calcularCurvasEnergia(analisisObj,carga)
       plot(analisisObj,varargin)
       disp(analisisObj)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="ModalEspectral.html" class="code" title="">ModalEspectral</a>	______________________________________________________________________</li><li><a href="../../tefame/analisis/eig/calculoEigDirectaBarrido.html" class="code" title="function [v, w, error] = calculoEigDirectaBarrido(M, K, nModos, tol)">calculoEigDirectaBarrido</a>	calculoEigIterDirecta: Calcula los valores y vectores propios del sistema</li><li><a href="../../tefame/analisis/eig/calculoEigEigs.html" class="code" title="function [w, v] = calculoEigEigs(M, K, nModos)">calculoEigEigs</a>	calculoEigEigs: Calcula los valores y vectores propios del sistema usando</li><li><a href="../../tefame/analisis/eig/calculoEigItSubespacio.html" class="code" title="function [v, w] = calculoEigItSubespacio(M, K, nModos, tol)">calculoEigItSubespacio</a>	calculoEigItSubespacio: Calcula los valores y vectores propios del sistema</li><li><a href="../../tefame/analisis/eig/calculoEigIterDirecta.html" class="code" title="function [v, w, error] = calculoEigIterDirecta(M, K, tol)">calculoEigIterDirecta</a>	calculoEigIterDirecta: Calcula los valores y vectores propios del sistema</li><li><a href="../../tefame/analisis/eig/calculoEigIterInvDesplazamiento.html" class="code" title="function [v, w, error] = calculoEigIterInvDesplazamiento(M, K, mu, tol)">calculoEigIterInvDesplazamiento</a>	calculoEigIterDirecta: Calcula los valores y vectores propios del sistema</li><li><a href="../../tefame/lib/allDivMod.html" class="code" title="function t = allDivMod(y, r)">allDivMod</a>	ALLDIVMOD Retorna verdadero si todos los elementos de y son divisibles por r.</li><li><a href="../../tefame/lib/arrayIntNum2str.html" class="code" title="function textCell = arrayIntNum2str(a, num)">arrayIntNum2str</a>	textCell = array2str(a,num) function that transform the array of number to a</li><li><a href="../../tefame/lib/arrayNum2str.html" class="code" title="function textCell = arrayNum2str(a, num)">arrayNum2str</a>	textCell = array2str(a,num) function that transform the array of number to a</li><li><a href="../../tefame/lib/arrayStr2str.html" class="code" title="function textCell = arrayStr2str(a, num)">arrayStr2str</a>	textCell = array2str(a,num) function that transform the array of string to a</li><li><a href="../../tefame/lib/drawVyLine.html" class="code" title="function obj = drawVyLine(y, style, lw)">drawVyLine</a>	DRAW VX LINE</li><li><a href="../../tefame/lib/gifPlayerGUI.html" class="code" title="function gifPlayerGUI(fname, delayTime)">gifPlayerGUI</a>	</li><li><a href="../../tefame/lib/padFillNum.html" class="code" title="function y = padFillNum(x, a)">padFillNum</a>	PADFILLNUM Full a number respect to <a></li><li><a href="../../tefame/modelo/cargas/CargaDinamica.html" class="code" title="">CargaDinamica</a>	______________________________________________________________________</li><li><a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>	dispMetodoTEFAME: Normaliza la salida estandar disp en consola de los</li><li><a href="../../tefame/utils/verificarVectorDireccion.html" class="code" title="function y = verificarVectorDireccion(vec, ndg)">verificarVectorDireccion</a>	verificarVectorDireccion: Verifica que un vector direccion tenga sentido y</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="ModalEspectral.html" class="code" title="">ModalEspectral</a>	______________________________________________________________________</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function analisisObj = ModalEspectral(modeloObjeto)</a></li><li><a href="#_sub2" class="code">function analizar(analisisObj, varargin)</a></li><li><a href="#_sub3" class="code">function resolverCargasDinamicas(analisisObj, varargin)</a></li><li><a href="#_sub4" class="code">function numeroEcuaciones = obtenerNumeroEcuaciones(analisisObj)</a></li><li><a href="#_sub5" class="code">function M_Modelo = obtenerMatrizMasa(analisisObj)</a></li><li><a href="#_sub6" class="code">function C_Modelo = obtenerMatrizAmortiguamiento(analisisObj, rayleigh)</a></li><li><a href="#_sub7" class="code">function K_Modelo = obtenerMatrizRigidez(analisisObj)</a></li><li><a href="#_sub8" class="code">function Cdv_Modelo = obtenerMatrizAmortiguamientoDisipadores(analisisObj)</a></li><li><a href="#_sub9" class="code">function Kdv_Modelo = obtenerMatrizRigidezDisipadores(analisisObj)</a></li><li><a href="#_sub10" class="code">function r_Modelo = obtenerVectorInfluencia(analisisObj)</a></li><li><a href="#_sub11" class="code">function F_Modelo = obtenerVectorFuerzas(analisisObj)</a></li><li><a href="#_sub12" class="code">function u_Modelo = obtenerDesplazamientos(analisisObj)</a></li><li><a href="#_sub13" class="code">function wn_Modelo = obtenerValoresPropios(analisisObj)</a></li><li><a href="#_sub14" class="code">function phi_Modelo = obtenerMatrizPhi(analisisObj)</a></li><li><a href="#_sub15" class="code">function plt = plot(analisisObj, varargin)</a></li><li><a href="#_sub16" class="code">function calcularDesplazamientoDrift(analisisObj, carga, xanalisis, varargin)</a></li><li><a href="#_sub17" class="code">function calcularMomentoCorteBasal(analisisObj, carga, varargin)</a></li><li><a href="#_sub18" class="code">function calcularCurvasEnergia(analisisObj, carga, varargin)</a></li><li><a href="#_sub19" class="code">function e_v = calcularModosEnergia(analisisObj, carga, dispinfo)</a></li><li><a href="#_sub20" class="code">function esfmax = plotEsfuerzosElemento(analisisObj, carga, elemento, direccion, varargin)</a></li><li><a href="#_sub21" class="code">function plotTrayectoriaNodo(analisisObj, carga, nodo, direccion, varargin)</a></li><li><a href="#_sub22" class="code">function activarCargaAnimacion(analisisObj)</a></li><li><a href="#_sub23" class="code">function desactivarCargaAnimacion(analisisObj)</a></li><li><a href="#_sub24" class="code">function activarPlotDeformadaInicial(analisisObj)</a></li><li><a href="#_sub25" class="code">function desactivarPlotDeformadaInicial(analisisObj)</a></li><li><a href="#_sub26" class="code">function disp(analisisObj)</a></li><li><a href="#_sub27" class="code">function c = obtenerCargaEstatica(analisisObj, varargin)</a></li><li><a href="#_sub28" class="code">function definirNumeracionGDL(analisisObj)</a></li><li><a href="#_sub29" class="code">function calcularModalEspectral(analisisObj, nModos, betacR, modocR,</a></li><li><a href="#_sub30" class="code">function ensamblarMatrizRigidez(analisisObj)</a></li><li><a href="#_sub31" class="code">function ensamblarMatrizMasa(analisisObj)</a></li><li><a href="#_sub32" class="code">function Cdv = ensamblarMatrizAmortiguamientoDisipadores(analisisObj)</a></li><li><a href="#_sub33" class="code">function Kdv = ensamblarMatrizRigidezDisipadores(analisisObj)</a></li><li><a href="#_sub34" class="code">function ensamblarVectorFuerzas(analisisObj)</a></li><li><a href="#_sub35" class="code">function plotAnimado(analisisObj, deformada, modo, factor, phif, limx, limy, limz,</a></li><li><a href="#_sub36" class="code">function [limx, limy, limz] = obtenerLimitesDeformada(analisisObj, modo, factor, defcarga, carga)</a></li><li><a href="#_sub37" class="code">function def = obtenerDeformadaNodo(analisisObj, nodo, modo, gdl, defcarga, carga, tcarga)</a></li><li><a href="#_sub38" class="code">function [Cortante, Momento, CBplot, MBplot, hplot] = calcularMomentoCorteBasalAcel(analisisObj, acel)</a></li><li><a href="#_sub39" class="code">function ctitle = imprimirPropiedadesAnalisisCarga(analisisObj, carga)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% ______________________________________________________________________</span>
0002 <span class="comment">%|                                                                      |</span>
0003 <span class="comment">%|           TEFAME - Toolbox para Elemento Finitos y Analisis          |</span>
0004 <span class="comment">%|                  Matricial de Estructuras en MATLAB                  |</span>
0005 <span class="comment">%|                                                                      |</span>
0006 <span class="comment">%|                   Area  de Estructuras y Geotecnia                   |</span>
0007 <span class="comment">%|                   Departamento de Ingenieria Civil                   |</span>
0008 <span class="comment">%|              Facultad de Ciencias Fisicas y Matematicas              |</span>
0009 <span class="comment">%|                         Universidad de Chile                         |</span>
0010 <span class="comment">%|                                                                      |</span>
0011 <span class="comment">%| TEFAME es una  plataforma en base a objetos para modelar, analizar y |</span>
0012 <span class="comment">%| visualizar  la respuesta de sistemas  estructurales usando el metodo |</span>
0013 <span class="comment">%| de elementos finitos y analisis matricial de estructuras en MATLAB.  |</span>
0014 <span class="comment">%| La plataforma es desarrollada en  propagacion orientada a objetos en |</span>
0015 <span class="comment">%| MATLAB.                                                              |</span>
0016 <span class="comment">%|______________________________________________________________________|</span>
0017 <span class="comment">% ______________________________________________________________________</span>
0018 <span class="comment">%|                                                                      |</span>
0019 <span class="comment">%| Clase ModalEspectral                                                 |</span>
0020 <span class="comment">%|                                                                      |</span>
0021 <span class="comment">%| Este archivo contiene la definicion de la Clase ModalEspectral       |</span>
0022 <span class="comment">%| ModalEspectral es una clase que se usa para resolver la estructura   |</span>
0023 <span class="comment">%| aplicando el metodo modal espectral. Para ello se calcula la matriz  |</span>
0024 <span class="comment">%| de masa y de rigidez.                                                |</span>
0025 <span class="comment">%|                                                                      |</span>
0026 <span class="comment">%| Programado: Pablo Pizarro @ppizarror                                 |</span>
0027 <span class="comment">%| Fecha: 18/03/2019                                                    |</span>
0028 <span class="comment">%|______________________________________________________________________|</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%  Properties (Access=private):</span>
0031 <span class="comment">%       modeloObj</span>
0032 <span class="comment">%       numeroGDL</span>
0033 <span class="comment">%       Kt</span>
0034 <span class="comment">%       Mt</span>
0035 <span class="comment">%       gdlCond</span>
0036 <span class="comment">%       F</span>
0037 <span class="comment">%       u</span>
0038 <span class="comment">%       wn</span>
0039 <span class="comment">%       Tn</span>
0040 <span class="comment">%       phin</span>
0041 <span class="comment">%       phiExt</span>
0042 <span class="comment">%       condMatT</span>
0043 <span class="comment">%       condMatRot</span>
0044 <span class="comment">%       Mm</span>
0045 <span class="comment">%       Km</span>
0046 <span class="comment">%       rm</span>
0047 <span class="comment">%       Lm</span>
0048 <span class="comment">%       Mmeff</span>
0049 <span class="comment">%       Mmeffacum</span>
0050 <span class="comment">%       Mtotal</span>
0051 <span class="comment">%       analisisFinalizado</span>
0052 <span class="comment">%       numModos</span>
0053 <span class="comment">%       numDG</span>
0054 <span class="comment">%       numDGReal</span>
0055 <span class="comment">%       cRayleigh</span>
0056 <span class="comment">%       cPenzien</span>
0057 <span class="comment">%       mostrarDeformada</span>
0058 <span class="comment">%       cargarAnimacion</span>
0059 <span class="comment">%  Methods:</span>
0060 <span class="comment">%       analisisObj = ModalEspectral(modeloObjeto)</span>
0061 <span class="comment">%       definirNumeracionGDL(analisisObj)</span>
0062 <span class="comment">%       analizar(analisisObj,varargin)</span>
0063 <span class="comment">%       numeroEcuaciones = obtenerNumeroEcuaciones(analisisObj)</span>
0064 <span class="comment">%       M_Modelo = obtenerMatrizMasa(analisisObj)</span>
0065 <span class="comment">%       C_Modelo = obtenerMatrizAmortiguamiento(analisisObj,rayleigh)</span>
0066 <span class="comment">%       K_Modelo = obtenerMatrizRigidez(analisisObj)</span>
0067 <span class="comment">%       Cdv_Modelo = obtenerMatrizAmortiguamientoDisipadores(analisisObj)</span>
0068 <span class="comment">%       Kdv_Modelo = obtenerMatrizRigidezDisipadores(analisisObj)</span>
0069 <span class="comment">%       r_Modelo = obtenerVectorInfluencia(analisisObj)</span>
0070 <span class="comment">%       F_Modelo = obtenerVectorFuerzas(analisisObj)</span>
0071 <span class="comment">%       u_Modelo = obtenerDesplazamientos(analisisObj)</span>
0072 <span class="comment">%       wn_Modelo = obtenerValoresPropios(analisisObj)</span>
0073 <span class="comment">%       phi_Modelo = obtenerMatrizPhi(analisisObj)</span>
0074 <span class="comment">%       c = obtenerCargaEstatica(analisisObj,varargin)</span>
0075 <span class="comment">%       activarPlotDeformadaInicial(analisisObj)</span>
0076 <span class="comment">%       desactivarPlotDeformadaInicial(analisisObj)</span>
0077 <span class="comment">%       activarCargaAnimacion(analisisObj)</span>
0078 <span class="comment">%       desactivarCargaAnimacion(analisisObj)</span>
0079 <span class="comment">%       calcularMomentoCorteBasal(analisisObj,carga)</span>
0080 <span class="comment">%       plotTrayectoriaNodo(analisisObj,carga,nodo,direccion)</span>
0081 <span class="comment">%       plotEsfuerzosElemento(analisisObj,carga)</span>
0082 <span class="comment">%       calcularDesplazamientoDrift(analisisObj,xanalisis)</span>
0083 <span class="comment">%       calcularCurvasEnergia(analisisObj,carga)</span>
0084 <span class="comment">%       plot(analisisObj,varargin)</span>
0085 <span class="comment">%       disp(analisisObj)</span>
0086 
0087 classdef <a href="ModalEspectral.html" class="code" title="">ModalEspectral</a> &lt; handle
0088     
0089     properties(Access = private)
0090         modeloObj <span class="comment">% Guarda el objeto que contiene el modelo</span>
0091         numeroGDL <span class="comment">% Guarda el numero de grados de libertad totales del modelo</span>
0092         Kt <span class="comment">% Matriz de Rigidez del modelo</span>
0093         Mt <span class="comment">% Matriz de Masa del modelo</span>
0094         gdlCond <span class="comment">% Grados de libertad condensados</span>
0095         F <span class="comment">% Vector de Fuerzas aplicadas sobre el modelo</span>
0096         u <span class="comment">% Vector con los desplazamientos de los grados de libertad del modelo</span>
0097         wn <span class="comment">% Frecuencias del sistema</span>
0098         Tn <span class="comment">% Periodos del sistema</span>
0099         phin <span class="comment">% Vectores propios del sistema</span>
0100         phinExt <span class="comment">% Vector propio del sistema extendido considerando grados condensados</span>
0101         condMatT <span class="comment">% Matriz de condensacion T</span>
0102         condMatRot <span class="comment">% Matriz de condensacion rotacion</span>
0103         Mteq <span class="comment">% Matriz masa equivalente</span>
0104         Kteq <span class="comment">% Matriz rigidez equivalente</span>
0105         Mm <span class="comment">% Matriz masa modal</span>
0106         Km <span class="comment">% Matriz rigidez modal</span>
0107         rm <span class="comment">% Vector influencia</span>
0108         Lm <span class="comment">% Factor de participacion modal</span>
0109         Mmeff <span class="comment">% Masa modal efectiva</span>
0110         Mmeffacum <span class="comment">% Masa modal efectiva acumulada</span>
0111         Mtotal <span class="comment">% Masa total del modelo</span>
0112         analisisFinalizado <span class="comment">% Indica que el analisis ha sido realizado</span>
0113         numModos <span class="comment">% Numero de modos del analisis</span>
0114         numDG <span class="comment">% Numero de ejes de analisis despues de condensar</span>
0115         numDGReal <span class="comment">% Numero de ejes de analisis antes de condensar</span>
0116         cRayleigh <span class="comment">% Matriz de amortiguamiento de Rayleigh</span>
0117         cPenzien <span class="comment">% Matriz de amortiguamiento de Wilson-Penzien</span>
0118         mostrarDeformada <span class="comment">% Muestra la posicion no deformada en los graficos</span>
0119         cargarAnimacion <span class="comment">% Carga la animacion del grafico una vez renderizado</span>
0120     <span class="keyword">end</span> <span class="comment">% properties ModalEspectral</span>
0121     
0122     methods(Access = public)
0123         
0124         <a name="_sub0" href="#_subfunctions" class="code">function analisisObj = ModalEspectral(modeloObjeto)</a>
0125             <span class="comment">% ModalEspectral: es el constructor de la clase ModalEspectral</span>
0126             <span class="comment">%</span>
0127             <span class="comment">% analisisObj = ModalEspectral(modeloObjeto)</span>
0128             <span class="comment">%</span>
0129             <span class="comment">% Crea un objeto de la clase ModalEspectral, y guarda el modelo,</span>
0130             <span class="comment">% que necesita ser analizado</span>
0131             
0132             <span class="keyword">if</span> nargin == 0
0133                 modeloObjeto = [];
0134             <span class="keyword">end</span> <span class="comment">% if</span>
0135             
0136             analisisObj.modeloObj = modeloObjeto;
0137             analisisObj.numeroGDL = 0;
0138             analisisObj.Kt = [];
0139             analisisObj.Mt = [];
0140             analisisObj.u = [];
0141             analisisObj.F = [];
0142             analisisObj.analisisFinalizado = false;
0143             analisisObj.mostrarDeformada = false;
0144             analisisObj.cargarAnimacion = true;
0145             
0146         <span class="keyword">end</span> <span class="comment">% ModalEspectral constructor</span>
0147         
0148         <a name="_sub1" href="#_subfunctions" class="code">function analizar(analisisObj, varargin)</a>
0149             <span class="comment">% analizar: es un metodo de la clase ModalEspectral que se usa para</span>
0150             <span class="comment">% realizar el analisis estatico</span>
0151             <span class="comment">% Analiza estaticamente el modelo lineal y elastico sometido a un</span>
0152             <span class="comment">% set de cargas, requiere el numero de modos para realizar el</span>
0153             <span class="comment">% analisis y de los modos conocidos con sus beta</span>
0154             <span class="comment">%</span>
0155             <span class="comment">% analizar(analisisObj,varargin)</span>
0156             <span class="comment">%</span>
0157             <span class="comment">% Parametros:</span>
0158             <span class="comment">%   'nModos'            Numero de modos de analisis (obligatorio)</span>
0159             <span class="comment">%   'rayleighBeta'      Vector amortiguamientos de Rayleigh</span>
0160             <span class="comment">%   'rayleighModo'      Vector modos de Rayleigh</span>
0161             <span class="comment">%   'rayleighDir'       Direccion amortiguamiento Rayleigh</span>
0162             <span class="comment">%   'cpenzienBeta'      Vector amortiguamiento Cpenzien</span>
0163             <span class="comment">%   'toleranciaMasa'    Tolerancia de la masa para la condensacion</span>
0164             <span class="comment">%   'condensar'         Aplica condensacion (true por defecto)</span>
0165             <span class="comment">%   'valvecAlgoritmo'   'eigvc','itDir','matBarr','itInvDesp','itSubesp'</span>
0166             <span class="comment">%   'valvecTolerancia'  Tolerancia calculo valores y vectores propios</span>
0167             <span class="comment">%   'factorCargaE'      Factor de cargas estaticas</span>
0168             
0169             <span class="comment">% Define parametros</span>
0170             p = inputParser;
0171             p.KeepUnmatched = true;
0172             addOptional(p, <span class="string">'nModos'</span>, 0);
0173             addOptional(p, <span class="string">'rayleighBeta'</span>, []);
0174             addOptional(p, <span class="string">'rayleighModo'</span>, []);
0175             addOptional(p, <span class="string">'rayleighDir'</span>, []);
0176             addOptional(p, <span class="string">'cpenzienBeta'</span>, []);
0177             addOptional(p, <span class="string">'toleranciamasa'</span>, 0.001);
0178             addOptional(p, <span class="string">'condensar'</span>, true);
0179             addOptional(p, <span class="string">'valvecAlgoritmo'</span>, <span class="string">'eigs'</span>);
0180             addOptional(p, <span class="string">'valvecTolerancia'</span>, 0.001);
0181             addOptional(p, <span class="string">'factorCargaE'</span>, 1);
0182             addOptional(p, <span class="string">'muIterDespl'</span>, 0.5);
0183             parse(p, varargin{:});
0184             r = p.Results;
0185             
0186             maxcond = r.toleranciamasa;
0187             <span class="keyword">if</span> ~r.condensar
0188                 maxcond = -1;
0189             <span class="keyword">end</span>
0190             
0191             <span class="comment">% Verifica que parametros obligatorios sean proporcionados</span>
0192             <span class="keyword">if</span> r.nModos &lt;= 0
0193                 error(<span class="string">'Numero de modos invalido'</span>);
0194             <span class="keyword">end</span>
0195             r.nModos = floor(r.nModos);
0196             
0197             <span class="keyword">if</span> isempty(r.rayleighBeta)
0198                 error(<span class="string">'Vector amortiguamiento de Rayleigh no puede ser nulo'</span>);
0199             <span class="keyword">end</span>
0200             
0201             <span class="keyword">if</span> isempty(r.rayleighModo)
0202                 error(<span class="string">'Vector modo Rayleigh no puede ser nulo'</span>);
0203             <span class="keyword">end</span>
0204             
0205             <span class="keyword">for</span> i = 1:length(r.rayleighModo)
0206                 <span class="keyword">if</span> r.rayleighModo(i) &lt;= 0
0207                     error(<span class="string">'Vector Rayleigh modo mal definido'</span>);
0208                 <span class="keyword">end</span>
0209             <span class="keyword">end</span> <span class="comment">% for i</span>
0210             
0211             <span class="keyword">if</span> length(r.rayleighBeta) ~= length(r.rayleighModo) || <span class="keyword">...</span>
0212                     length(r.rayleighBeta) ~= length(r.rayleighDir)
0213                 error(<span class="string">'Vectores parametros Rayleigh deben tener igual dimension'</span>);
0214             <span class="keyword">end</span>
0215             
0216             <span class="keyword">for</span> i = 1:length(r.rayleighDir)
0217                 <span class="keyword">if</span> ~(r.rayleighDir(i) == <span class="string">'h'</span> || r.rayleighDir(i) == <span class="string">'v'</span>)
0218                     error(<span class="string">'Direccion amortiguamiento Rayleigh solo puede ser (h) horizonal o (v) vertical'</span>);
0219                 <span class="keyword">end</span>
0220             <span class="keyword">end</span> <span class="comment">% for i</span>
0221             
0222             <span class="keyword">if</span> isempty(r.cpenzienBeta)
0223                 error(<span class="string">'Vector amortiguamiento cpenzien no puede ser nulo'</span>);
0224             <span class="keyword">end</span>
0225             
0226             <span class="keyword">if</span> r.valvecTolerancia &lt;= 0
0227                 error(<span class="string">'Tolerancia calculo valores y vectores propios no puede ser inferior o igual a cero'</span>);
0228             <span class="keyword">end</span>
0229             
0230             fprintf(<span class="string">'Ejecutando analisis modal espectral:\n'</span>);
0231             fprintf(<span class="string">'\tParametros analisis:\n'</span>);
0232             fprintf(<span class="string">'\t\tNumero de modos: %d\n'</span>, r.nModos);
0233             
0234             fprintf(<span class="string">'\t\tAmortiguamiento Rayleigh:\n'</span>);
0235             s = <a href="../../tefame/lib/arrayIntNum2str.html" class="code" title="function textCell = arrayIntNum2str(a, num)">arrayIntNum2str</a>(r.rayleighModo);
0236             fprintf(<span class="string">'\t\t\tModos:\t\t%s\n'</span>, [s{:}]);
0237             s = <a href="../../tefame/lib/arrayNum2str.html" class="code" title="function textCell = arrayNum2str(a, num)">arrayNum2str</a>(r.rayleighBeta);
0238             fprintf(<span class="string">'\t\t\tBeta:\t\t%s\n'</span>, [s{:}]);
0239             s = <a href="../../tefame/lib/arrayStr2str.html" class="code" title="function textCell = arrayStr2str(a, num)">arrayStr2str</a>(r.rayleighDir);
0240             fprintf(<span class="string">'\t\t\tDireccion:\t%s\n'</span>, [s{:}]);
0241             
0242             fprintf(<span class="string">'\t\tAmortiguamiento cpenzien:\n'</span>);
0243             s = <a href="../../tefame/lib/arrayNum2str.html" class="code" title="function textCell = arrayNum2str(a, num)">arrayNum2str</a>(r.cpenzienBeta);
0244             fprintf(<span class="string">'\t\t\tBeta:\t\t%s\n'</span>, [s{:}]);
0245             
0246             <span class="comment">% Se definen los grados de libertad por nodo -&gt; elementos</span>
0247             analisisObj.definirNumeracionGDL();
0248             
0249             <span class="comment">% Se aplica patron de carga</span>
0250             analisisObj.modeloObj.aplicarPatronesDeCargasEstatico(r.factorCargaE);
0251             
0252             <span class="comment">% Se calcula la matriz de rigidez</span>
0253             analisisObj.ensamblarMatrizRigidez();
0254             
0255             <span class="comment">% Se calcula la matriz de masa</span>
0256             analisisObj.ensamblarMatrizMasa();
0257             
0258             <span class="comment">% Guarda el resultado para las cargas estaticas</span>
0259             fprintf(<span class="string">'\tCalculando resultado carga estatica\n'</span>);
0260             analisisObj.ensamblarVectorFuerzas();
0261             analisisObj.u = (analisisObj.Kt^-1) * analisisObj.F;
0262             analisisObj.modeloObj.actualizar(analisisObj.u);
0263             
0264             <span class="comment">% Calcula el metodo modal espectral</span>
0265             analisisObj.calcularModalEspectral(r.nModos, r.rayleighBeta, <span class="keyword">...</span>
0266                 r.rayleighModo, r.rayleighDir, r.cpenzienBeta, <span class="keyword">...</span>
0267                 maxcond, r.valvecAlgoritmo, r.valvecTolerancia, <span class="keyword">...</span>
0268                 r.muIterDespl);
0269             
0270             <span class="comment">% Termina el analisis</span>
0271             <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
0272             
0273         <span class="keyword">end</span> <span class="comment">% analizar function</span>
0274         
0275         <a name="_sub2" href="#_subfunctions" class="code">function resolverCargasDinamicas(analisisObj, varargin)</a>
0276             <span class="comment">% resolverCargasDinamicas: Resuelve las cargas dinamicas del</span>
0277             <span class="comment">% sistema</span>
0278             <span class="comment">%</span>
0279             <span class="comment">% resolverCargasDinamicas(analisisObj,varargin)</span>
0280             <span class="comment">%</span>
0281             <span class="comment">% Parametros opcionales:</span>
0282             <span class="comment">%   'cpenzien'          Usa el amortiguamiento de cpenzien (false por defecto)</span>
0283             <span class="comment">%   'disipadores'       Usa los disipadores en el calculo (false por defecto)</span>
0284             <span class="comment">%   'cargaDisipador'    Carga objetivo disipador para el calculo de v0</span>
0285             <span class="comment">%   'betaObjetivo'      Beta objetivo para el calculo de disipadores</span>
0286             <span class="comment">%   'betaGrafico'       Indica si se grafica la variacion del amortiguamiento en cada iteracion</span>
0287             <span class="comment">%   'iterDisipador'     Numero de iteraciones para el calculo de disipadores</span>
0288             <span class="comment">%   'tolIterDisipador'  Tolerancia usada para las iteraciones del calculo de disipadores</span>
0289             <span class="comment">%   'activado'          Indica que se realiza el analisi</span>
0290             <span class="comment">%   'factorCargasD'     Factor de cargas dinamico</span>
0291             
0292             <span class="keyword">if</span> ~analisisObj.analisisFinalizado
0293                 error(<span class="string">'No se puede resolver las cargas dinamicas sin haber analizado la estructura'</span>);
0294             <span class="keyword">end</span>
0295             
0296             p = inputParser;
0297             p.KeepUnmatched = true;
0298             addOptional(p, <span class="string">'cpenzien'</span>, false);
0299             addOptional(p, <span class="string">'disipadores'</span>, true);
0300             addOptional(p, <span class="string">'cargaDisipador'</span>, false);
0301             addOptional(p, <span class="string">'betaObjetivo'</span>, 0);
0302             addOptional(p, <span class="string">'betaGrafico'</span>, false);
0303             addOptional(p, <span class="string">'iterDisipador'</span>, 10);
0304             addOptional(p, <span class="string">'tolIterDisipador'</span>, 0.001);
0305             addOptional(p, <span class="string">'activado'</span>, true);
0306             addOptional(p, <span class="string">'factorCargasD'</span>, 1);
0307             parse(p, varargin{:});
0308             r = p.Results;
0309             
0310             <span class="comment">% Chequea inconsistencias</span>
0311             <span class="keyword">if</span> ~r.activado
0312                 <span class="keyword">return</span>;
0313             <span class="keyword">end</span>
0314             <span class="keyword">if</span> r.disipadores
0315                 <span class="keyword">if</span> ~isa(r.cargaDisipador, <span class="string">'CargaDinamica'</span>)
0316                     error(<span class="string">'No se ha definido cargaDisipador'</span>);
0317                 <span class="keyword">end</span>
0318                 <span class="keyword">if</span> r.iterDisipador &lt; 0
0319                     error(<span class="string">'El numero de iteraciones no puede ser menor a cero'</span>);
0320                 <span class="keyword">end</span>
0321                 <span class="keyword">if</span> r.tolIterDisipador &lt;= 0
0322                     error(<span class="string">'Tolerancia iteracion disipador invalida'</span>);
0323                 <span class="keyword">end</span>
0324             <span class="keyword">end</span>
0325             
0326             fprintf(<span class="string">'Metodo modal espectral:\n'</span>);
0327             analisisObj.modeloObj.aplicarPatronesDeCargasDinamico(r.cpenzien, r.disipadores, <span class="keyword">...</span>
0328                 r.cargaDisipador, r.betaObjetivo, analisisObj.modeloObj.obtenerDisipadores(), <span class="keyword">...</span>
0329                 r.iterDisipador, r.tolIterDisipador, r.betaGrafico, <span class="keyword">...</span>
0330                 r.factorCargasD);
0331             
0332         <span class="keyword">end</span> <span class="comment">% resolverCargasDinamicas function</span>
0333         
0334         <a name="_sub3" href="#_subfunctions" class="code">function numeroEcuaciones = obtenerNumeroEcuaciones(analisisObj)</a>
0335             <span class="comment">% obtenerNumeroEcuaciones: es un metodo de la clase ModalEspectral</span>
0336             <span class="comment">% que se usa para obtener el numero total de GDL, es decir, ecuaciones</span>
0337             <span class="comment">% del modelo</span>
0338             <span class="comment">%</span>
0339             <span class="comment">% numeroEcuaciones = obtenerNumeroEcuaciones(analisisObj)</span>
0340             <span class="comment">%</span>
0341             <span class="comment">% Obtiene el numero total de GDL (numeroEcuaciones) que esta guardado</span>
0342             <span class="comment">% en el Analisis (analisisObj)</span>
0343             
0344             numeroEcuaciones = analisisObj.numeroGDL;
0345             
0346         <span class="keyword">end</span> <span class="comment">% obtenerNumeroEcuaciones function</span>
0347         
0348         <a name="_sub4" href="#_subfunctions" class="code">function M_Modelo = obtenerMatrizMasa(analisisObj)</a>
0349             <span class="comment">% obtenerMatrizMasa: es un metodo de la clase ModalEspectral</span>
0350             <span class="comment">% que se usa para obtener la matriz de masa del modelo</span>
0351             <span class="comment">%</span>
0352             <span class="comment">% M_Modelo = obtenerMatrizRigidez(analisisObj)</span>
0353             <span class="comment">%</span>
0354             <span class="comment">% Obtiene la matriz de masa (M_Modelo) del modelo que se genero</span>
0355             <span class="comment">% en el Analisis (analisisObj)</span>
0356             
0357             M_Modelo = analisisObj.Mteq;
0358             
0359         <span class="keyword">end</span> <span class="comment">% obtenerMatrizMasa function</span>
0360         
0361         <a name="_sub5" href="#_subfunctions" class="code">function C_Modelo = obtenerMatrizAmortiguamiento(analisisObj, rayleigh)</a>
0362             <span class="comment">% obtenerMatrizAmortiguamiento: es un metodo de la clase ModalEspectral</span>
0363             <span class="comment">% que se usa para obtener la matriz de amortiguamiento del modelo</span>
0364             <span class="comment">%</span>
0365             <span class="comment">% C_Modelo = obtenerMatrizAmortiguamiento(analisisObj,rayleigh)</span>
0366             <span class="comment">%</span>
0367             <span class="comment">% Obtiene la matriz de amortiguamiento (C_Modelo) del modelo que se genero</span>
0368             <span class="comment">% en el Analisis (analisisObj)</span>
0369             
0370             <span class="keyword">if</span> rayleigh
0371                 C_Modelo = analisisObj.cRayleigh;
0372             <span class="keyword">else</span>
0373                 C_Modelo = analisisObj.cPenzien;
0374             <span class="keyword">end</span>
0375             
0376         <span class="keyword">end</span> <span class="comment">% obtenerMatrizAmortiguamiento function</span>
0377         
0378         <a name="_sub6" href="#_subfunctions" class="code">function K_Modelo = obtenerMatrizRigidez(analisisObj)</a>
0379             <span class="comment">% obtenerMatrizRigidez: es un metodo de la clase ModalEspectral</span>
0380             <span class="comment">% que se usa para obtener la matriz de rigidez del modelo</span>
0381             <span class="comment">%</span>
0382             <span class="comment">% K_Modelo = obtenerMatrizRigidez(analisisObj)</span>
0383             <span class="comment">%</span>
0384             <span class="comment">% Obtiene la matriz de rigidez (K_Modelo) del modelo que se genero</span>
0385             <span class="comment">% en el Analisis (analisisObj)</span>
0386             
0387             K_Modelo = analisisObj.Kteq;
0388             
0389         <span class="keyword">end</span> <span class="comment">% obtenerMatrizRigidez function</span>
0390         
0391         <a name="_sub7" href="#_subfunctions" class="code">function Cdv_Modelo = obtenerMatrizAmortiguamientoDisipadores(analisisObj)</a>
0392             <span class="comment">% obtenerMatrizRigidez: es un metodo de la clase ModalEspectral</span>
0393             <span class="comment">% que se usa para obtener la matriz de amortiguamiento del modelo</span>
0394             <span class="comment">% producto de los disipadores incorporados</span>
0395             <span class="comment">%</span>
0396             <span class="comment">% Cdv_Modelo = obtenerMatrizAmortiguamientoDisipadores(analisisObj)</span>
0397             <span class="comment">%</span>
0398             <span class="comment">% Obtiene la matriz de amortiguamiento del modelo</span>
0399             
0400             Cdv_Modelo = analisisObj.ensamblarMatrizAmortiguamientoDisipadores();
0401             
0402         <span class="keyword">end</span> <span class="comment">% obtenerMatrizAmortiguamientoDisipadores function</span>
0403         
0404         <a name="_sub8" href="#_subfunctions" class="code">function Kdv_Modelo = obtenerMatrizRigidezDisipadores(analisisObj)</a>
0405             <span class="comment">% obtenerMatrizRigidezDisipadores: es un metodo de la clase ModalEspectral</span>
0406             <span class="comment">% que se usa para obtener la matriz de rigidez del modelo</span>
0407             <span class="comment">% producto de los disipadores incorporados</span>
0408             <span class="comment">%</span>
0409             <span class="comment">% Cdv_Modelo = obtenerMatrizRigidezDisipadores(analisisObj)</span>
0410             <span class="comment">%</span>
0411             <span class="comment">% Obtiene la matriz de Rigidez del modelo</span>
0412             
0413             Kdv_Modelo = analisisObj.ensamblarMatrizRigidezDisipadores();
0414             
0415         <span class="keyword">end</span> <span class="comment">% obtenerMatrizAmortiguamientoDisipadores function</span>
0416         
0417         <a name="_sub9" href="#_subfunctions" class="code">function r_Modelo = obtenerVectorInfluencia(analisisObj)</a>
0418             <span class="comment">% obtenerVectorInfluencia: es un metodo de la clase ModalEspectral</span>
0419             <span class="comment">% que se usa para obtener el vector de influencia del modelo</span>
0420             <span class="comment">%</span>
0421             <span class="comment">% r_Modelo = obtenerVectorInfluencia(analisisObj)</span>
0422             <span class="comment">%</span>
0423             <span class="comment">% Obtiene el vector de influencia (r) del modelo que se genero</span>
0424             <span class="comment">% en el Analisis (analisisObj)</span>
0425             
0426             r_Modelo = analisisObj.rm;
0427             
0428         <span class="keyword">end</span> <span class="comment">% obtenerVectorInfluencia function</span>
0429         
0430         <a name="_sub10" href="#_subfunctions" class="code">function F_Modelo = obtenerVectorFuerzas(analisisObj)</a>
0431             <span class="comment">% obtenerMatrizRigidez: es un metodo de la clase ModalEspectral</span>
0432             <span class="comment">% que se usa para obtener el vector de fuerza del modelo</span>
0433             <span class="comment">%</span>
0434             <span class="comment">% F_Modelo = obtenerVectorFuerzas(analisisObj)</span>
0435             <span class="comment">%</span>
0436             <span class="comment">% Obtiene el vector de fuerza (F_Modelo) del modelo que se genero</span>
0437             <span class="comment">% en el Analisis (analisisObj)</span>
0438             
0439             F_Modelo = analisisObj.F;
0440             
0441         <span class="keyword">end</span> <span class="comment">% obtenerVectorFuerzas function</span>
0442         
0443         <a name="_sub11" href="#_subfunctions" class="code">function u_Modelo = obtenerDesplazamientos(analisisObj)</a>
0444             <span class="comment">% obtenerDesplazamientos: es un metodo de la clase ModalEspectral</span>
0445             <span class="comment">% que se usa para obtener el vector de desplazamiento del modelo</span>
0446             <span class="comment">% obtenido del analisis</span>
0447             <span class="comment">%</span>
0448             <span class="comment">% u_Modelo = obtenerDesplazamientos(analisisObj)</span>
0449             <span class="comment">%</span>
0450             <span class="comment">% Obtiene el vector de desplazamiento (u_Modelo) del modelo que se</span>
0451             <span class="comment">% genero como resultado del Analisis (analisisObj)</span>
0452             
0453             u_Modelo = analisisObj.u;
0454             
0455         <span class="keyword">end</span> <span class="comment">% obtenerDesplazamientos function</span>
0456         
0457         <a name="_sub12" href="#_subfunctions" class="code">function wn_Modelo = obtenerValoresPropios(analisisObj)</a>
0458             <span class="comment">% obtenerValoresPropios: es un metodo de la clase ModalEspectral</span>
0459             <span class="comment">% que se usa para obtener los valores propios del modelo</span>
0460             <span class="comment">% obtenido del analisis</span>
0461             <span class="comment">%</span>
0462             <span class="comment">% w_Modelo = obtenerValoresPropios(analisisObj)</span>
0463             <span class="comment">%</span>
0464             <span class="comment">% Obtiene los valores propios (wn_Modelo) del modelo que se</span>
0465             <span class="comment">% genero como resultado del Analisis (analisisObj)</span>
0466             
0467             wn_Modelo = analisisObj.wn;
0468             
0469         <span class="keyword">end</span> <span class="comment">% obtenerValoresPropios function</span>
0470         
0471         <a name="_sub13" href="#_subfunctions" class="code">function phi_Modelo = obtenerMatrizPhi(analisisObj)</a>
0472             <span class="comment">% obtenerMatrizPhi: es un metodo de la clase ModalEspectral</span>
0473             <span class="comment">% que se usa para obtener los vectores propios del modelo</span>
0474             <span class="comment">% obtenido del analisis</span>
0475             <span class="comment">%</span>
0476             <span class="comment">% phi_Modelo = obtenerMatrizPhi(analisisObj)</span>
0477             <span class="comment">%</span>
0478             <span class="comment">% Obtiene los vectores propios (phi_Modelo) del modelo que se</span>
0479             <span class="comment">% genero como resultado del Analisis (analisisObj)</span>
0480             
0481             phi_Modelo = analisisObj.phin;
0482             
0483         <span class="keyword">end</span> <span class="comment">% obtenerMatrizPhi function</span>
0484         
0485         <a name="_sub14" href="#_subfunctions" class="code">function plt = plot(analisisObj, varargin)</a>
0486             <span class="comment">% plot: Grafica el modelo</span>
0487             <span class="comment">%</span>
0488             <span class="comment">% plt = plot(analisisObj,'var1',val1,'var2',val2)</span>
0489             <span class="comment">%</span>
0490             <span class="comment">% Parametros opcionales:</span>
0491             <span class="comment">%   'modo'              Numero de modo a graficar</span>
0492             <span class="comment">%   'factor'            Escala de la deformacion</span>
0493             <span class="comment">%   'cuadros'           Numero de cuadros de la animacion</span>
0494             <span class="comment">%   'gif'               Archivo en el que se guarda la animacion</span>
0495             <span class="comment">%   'defElem'           Dibuja la deformada de cada elemento</span>
0496             <span class="comment">%   'mostrarEstatico'   Dibuja la estructura estatica al animar</span>
0497             <span class="comment">%   'tmin'              Tiempo minimo al graficar cargas</span>
0498             <span class="comment">%   'tmax'              Tiempo maximo al graficar cargas</span>
0499             <span class="comment">%   'disipador'         Dibuja los disipadores</span>
0500             <span class="comment">%   'styleNodoE'        Estilo nodo estatico</span>
0501             <span class="comment">%   'sizeNodoE'         Porte nodo estatico</span>
0502             <span class="comment">%   'styleNodoD'        Estilo nodo dinamico</span>
0503             <span class="comment">%   'sizeNodoE'         Porte nodo dinamico</span>
0504             <span class="comment">%   'styleElemE'        Estilo elemento estatico</span>
0505             <span class="comment">%   'lwElemE'           Ancho linea elemento estatico</span>
0506             <span class="comment">%   'styleElemD'        Estilo elemento dinamico</span>
0507             <span class="comment">%   'lwElemD'           Ancho linea elemento dinamico</span>
0508             <span class="comment">%   'styleDisipador'    Estilo linea disipador</span>
0509             <span class="comment">%   'lwDisipador'       Ancho linea disipador</span>
0510             <span class="comment">%   'colorDisipador'    Color del disipador</span>
0511             <span class="comment">%   'unidad'            Unidad de longitud</span>
0512             <span class="comment">%   '3dAngAzh'          Angulo azimutal grafico 3D</span>
0513             <span class="comment">%   '3dAngPol'          Angulo polar grafico 3D</span>
0514             
0515             <span class="comment">% Establece variables iniciales</span>
0516             fprintf(<span class="string">'Generando animacion analisis modal espectral:\n'</span>);
0517             p = inputParser;
0518             p.KeepUnmatched = true;
0519             addOptional(p, <span class="string">'modo'</span>, 0);
0520             addOptional(p, <span class="string">'factor'</span>, 1);
0521             addOptional(p, <span class="string">'cuadros'</span>, 0);
0522             addOptional(p, <span class="string">'gif'</span>, <span class="string">''</span>);
0523             addOptional(p, <span class="string">'defElem'</span>, false);
0524             addOptional(p, <span class="string">'carga'</span>, false);
0525             addOptional(p, <span class="string">'tmin'</span>, 0);
0526             addOptional(p, <span class="string">'tmax'</span>, -1);
0527             addOptional(p, <span class="string">'mostrarEstatico'</span>, analisisObj.mostrarDeformada);
0528             addOptional(p, <span class="string">'disipadores'</span>, true);
0529             addOptional(p, <span class="string">'styleNodoE'</span>, <span class="string">'b'</span>);
0530             addOptional(p, <span class="string">'sizeNodoE'</span>, 5);
0531             addOptional(p, <span class="string">'styleNodoD'</span>, <span class="string">'k'</span>);
0532             addOptional(p, <span class="string">'sizeNodoD'</span>, 10);
0533             addOptional(p, <span class="string">'styleElemE'</span>, <span class="string">'b-'</span>);
0534             addOptional(p, <span class="string">'lwElemE'</span>, 0.5);
0535             addOptional(p, <span class="string">'styleElemD'</span>, <span class="string">'k-'</span>);
0536             addOptional(p, <span class="string">'lwElemD'</span>, 1.2);
0537             addOptional(p, <span class="string">'styleDisipador'</span>, <span class="string">'--'</span>);
0538             addOptional(p, <span class="string">'colorDisipador'</span>, <span class="string">'r'</span>);
0539             addOptional(p, <span class="string">'lwDisipador'</span>, 1.3);
0540             addOptional(p, <span class="string">'unidad'</span>, <span class="string">'m'</span>);
0541             addOptional(p, <span class="string">'angAzh'</span>, 45);
0542             addOptional(p, <span class="string">'angPol'</span>, 45);
0543             parse(p, varargin{:});
0544             r = p.Results;
0545             modo = floor(r.modo);
0546             factor = r.factor;
0547             numCuadros = floor(r.cuadros);
0548             guardaGif = r.gif;
0549             defElem = r.defElem;
0550             carga = r.carga;
0551             defCarga = false; <span class="comment">% Indica que la deformada se obtiene a partir de la carga</span>
0552             mostrarEstatico = r.mostrarEstatico;
0553             disipadores = r.disipadores;
0554             
0555             <span class="comment">% Tiempos</span>
0556             tmin = max(0, r.tmin);
0557             tmax = r.tmax;
0558             tinicial = cputime;
0559             
0560             <span class="comment">% Verificaciones si se grafica una carga</span>
0561             <span class="keyword">if</span> carga ~= false
0562                 
0563                 <span class="keyword">if</span> ~(isa(carga, <span class="string">'CargaDinamica'</span>) || isa(carga, <span class="string">'CombinacionCargas'</span>))
0564                     error(<span class="string">'Solo se pueden graficar cargas dinamicas o combinaciones de cargas'</span>);
0565                 <span class="keyword">end</span>
0566                 <span class="keyword">if</span> isempty(carga.obtenerDesplazamiento())
0567                     error(<span class="string">'No se ha resuelto la carga, no es posible graficar'</span>);
0568                 <span class="keyword">end</span>
0569                 <span class="keyword">if</span> modo ~= 0
0570                     error(<span class="string">'No se puede graficar un modo y una carga de manera simultanea'</span>);
0571                 <span class="keyword">end</span>
0572                 <span class="keyword">if</span> numCuadros &lt;= 0
0573                     error(<span class="string">'Se debe especificar el numero de cuadros'</span>);
0574                 <span class="keyword">end</span>
0575                 <span class="keyword">if</span> tmax &gt; carga.tAnalisis
0576                     fprintf(<span class="string">'\tSe ha limitado el tiempo maximo de la carga a %.2fs\n'</span>, carga.tAnalisis);
0577                     tmax = carga.tAnalisis;
0578                 <span class="keyword">elseif</span> tmax &lt; carga.tAnalisis
0579                     fprintf(<span class="string">'\tLa carga se graficara a un tiempo menor que el computado originalmente\n'</span>);
0580                 <span class="keyword">end</span>
0581                 <span class="keyword">if</span> tmax &lt;= 0
0582                     tmax = carga.tAnalisis;
0583                 <span class="keyword">end</span>
0584                 <span class="keyword">if</span> tmin &gt;= tmax
0585                     error(<span class="string">'El tiempo de analisis minimo no puede exceder al maximo'</span>);
0586                 <span class="keyword">end</span>
0587                 
0588                 <span class="comment">% Compara los dt</span>
0589                 dt_plot = (tmax - tmin) / numCuadros;
0590                 dt_real = carga.dt;
0591                 
0592                 <span class="comment">% Si el dt del grafico es menor se reajustan los cuadros</span>
0593                 <span class="keyword">if</span> dt_plot &lt; dt_real
0594                     warning(<span class="string">'El numero de cuadros genera un dt=%.3f inferior al dt=%.3f de la carga %s'</span>, <span class="keyword">...</span>
0595                         dt_plot, dt_real, carga.obtenerEtiqueta());
0596                     
0597                     <span class="comment">% Se limitan los cuadros</span>
0598                     numCuadros = floor((tmax - tmin)/dt_real);
0599                     fprintf(<span class="string">'\tSe ha limitado el numero de cuadros a %d\n'</span>, numCuadros);
0600                 <span class="keyword">elseif</span> dt_plot == dt_real
0601                     fprintf(<span class="string">'\tEl numero de cuadros genera un dt igual al de la carga\n'</span>);
0602                 <span class="keyword">else</span>
0603                     fprintf(<span class="string">'\tEl numero de cuadros genera un dt=%.3f superior al de la carga, superior en %.1f veces\n'</span>, <span class="keyword">...</span>
0604                         dt_plot, dt_plot/dt_real);
0605                     dt_plot_max_factor = 10; <span class="comment">% Factor maximo de los cuadros</span>
0606                     <span class="keyword">if</span> dt_plot / dt_real &gt; dt_plot_max_factor
0607                         fprintf(<span class="string">'\t\tNo se recomienda que este factor exceda de %d, usar numero de cuadros igual a %d\n'</span>, <span class="keyword">...</span>
0608                             dt_plot_max_factor, floor((tmax - tmin)/(dt_plot_max_factor * dt_real)));
0609                     <span class="keyword">end</span>
0610                 <span class="keyword">end</span>
0611                 
0612                 <span class="comment">% Crea el vector de tiempos de analisis</span>
0613                 tCargaEq = linspace(tmin, tmax, numCuadros);
0614                 
0615                 <span class="comment">% Busca las posiciones asociadas a la carga</span>
0616                 cargaTArr = linspace(0, carga.tAnalisis, carga.tAnalisis/carga.dt);
0617                 tCargaPos = zeros(1, numCuadros); <span class="comment">% Guarda los tiempos de 'snapshot' de la carga</span>
0618                 
0619                 i = 1;
0620                 <span class="keyword">for</span> j = 1:length(cargaTArr)
0621                     <span class="keyword">if</span> cargaTArr(j) &gt;= tCargaEq(i)
0622                         tCargaPos(i) = j;
0623                         i = i + 1;
0624                     <span class="keyword">end</span>
0625                     <span class="keyword">if</span> i &gt; numCuadros
0626                         <span class="keyword">break</span>;
0627                     <span class="keyword">end</span>
0628                 <span class="keyword">end</span> <span class="comment">% for j</span>
0629                 
0630                 <span class="comment">% Activa la deformada por carga</span>
0631                 defCarga = true;
0632                 fprintf(<span class="string">'\tSe graficara la carga %s desde ti=%.3f a tf=%.3f con dt=%.3f\n'</span>, <span class="keyword">...</span>
0633                     carga.obtenerEtiqueta(), tmin, tmax, dt_plot);
0634                 
0635             <span class="keyword">else</span>
0636                 
0637                 <span class="comment">% No se grafican cargas</span>
0638                 tCargaPos = zeros(1, numCuadros);
0639                 tCargaEq = zeros(1, numCuadros);
0640                 
0641             <span class="keyword">end</span>
0642             
0643             <span class="comment">% Chequea deformada</span>
0644             deformada = false;
0645             modo = ceil(modo);
0646             <span class="keyword">if</span> exist(<span class="string">'modo'</span>, <span class="string">'var'</span>) &amp;&amp; modo &gt; 0
0647                 deformada = true;
0648             <span class="keyword">end</span>
0649             deformada = deformada || defCarga;
0650             
0651             <span class="comment">% Grafica la estructura si no se ha ejecutado el analisis</span>
0652             <span class="keyword">if</span> (~analisisObj.analisisFinalizado || modo &lt;= 0) &amp;&amp; ~defCarga
0653                 plt = figure(<span class="string">'Name'</span>, sprintf(<span class="string">'Plot %s'</span>, analisisObj.modeloObj.obtenerNombre()), <span class="keyword">...</span>
0654                     <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
0655                 movegui(<span class="string">'center'</span>);
0656                 hold on;
0657                 grid on;
0658                 [limx, limy, limz] = analisisObj.obtenerLimitesDeformada(0, factor, defCarga, carga);
0659                 <a href="#_sub35" class="code" title="subfunction plotAnimado(analisisObj, deformada, modo, factor, phif, limx, limy, limz, ">plotAnimado</a>(analisisObj, false, 0, factor, 0, limx, limy, limz, <span class="keyword">...</span>
0660                     0, 1, 1, defElem, defCarga, carga, 1, tCargaEq, mostrarEstatico, disipadores, <span class="keyword">...</span>
0661                     r.styleNodoE, r.sizeNodoE, r.styleNodoD, r.sizeNodoD, r.styleElemE, r.lwElemE, <span class="keyword">...</span>
0662                     r.styleElemD, r.lwElemD, r.styleDisipador, r.colorDisipador, r.lwDisipador, <span class="keyword">...</span>
0663                     r.unidad, r.angAzh, r.angPol);
0664                 figure(plt);
0665                 <span class="keyword">return</span>;
0666             <span class="keyword">end</span>
0667             
0668             <span class="comment">% Guarda gif</span>
0669             guardarGif = false;
0670             <span class="keyword">if</span> exist(<span class="string">'guardaGif'</span>, <span class="string">'var'</span>) &amp;&amp; ~strcmp(guardaGif, <span class="string">''</span>)
0671                 guardarGif = true;
0672                 guardaGif = sprintf(guardaGif, modo);
0673             <span class="keyword">else</span>
0674                 guardaGif = tempname;
0675             <span class="keyword">end</span>
0676             
0677             <span class="keyword">if</span> (modo &gt; analisisObj.numModos || modo &lt;= 0) &amp;&amp; ~defCarga
0678                 error(<span class="string">'El modo a graficar %d excede la cantidad de modos del sistema (%d)'</span>, <span class="keyword">...</span>
0679                     modo, analisisObj.numModos);
0680             <span class="keyword">end</span>
0681             
0682             <span class="comment">% Obtiene el periodo</span>
0683             <span class="keyword">if</span> ~defCarga
0684                 tn = analisisObj.Tn(modo);
0685             <span class="keyword">else</span>
0686                 tn = 0;
0687             <span class="keyword">end</span>
0688             
0689             <span class="comment">% Calcula los limites</span>
0690             [limx, limy, limz] = analisisObj.obtenerLimitesDeformada(modo, factor, defCarga, carga);
0691             
0692             <span class="comment">% Grafica la estructura</span>
0693             <span class="keyword">if</span> modo ~= 0
0694                 fig_nom = sprintf(<span class="string">'Plot %s - Modo %d'</span>, analisisObj.modeloObj.obtenerNombre(), <span class="keyword">...</span>
0695                     modo);
0696             <span class="keyword">else</span>
0697                 fig_nom = sprintf(<span class="string">'Plot %s - Carga %s'</span>, analisisObj.modeloObj.obtenerNombre(), <span class="keyword">...</span>
0698                     carga.obtenerEtiqueta());
0699             <span class="keyword">end</span>
0700             plt = figure(<span class="string">'Name'</span>, fig_nom, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
0701             fig_num = get(gcf, <span class="string">'Number'</span>);
0702             movegui(<span class="string">'center'</span>);
0703             hold on;
0704             grid on;
0705             <span class="comment">% axis tight manual;</span>
0706             <span class="comment">% set(gca, 'nextplot', 'replacechildren');</span>
0707             
0708             <span class="comment">% Imprime mensajes en consola</span>
0709             <span class="keyword">if</span> defElem
0710                 fprintf(<span class="string">'\tSe ha activado la deformada de los elementos\n'</span>);
0711             <span class="keyword">end</span>
0712             <span class="keyword">if</span> guardarGif &amp;&amp; numCuadros ~= 0
0713                 fprintf(<span class="string">'\tEl proceso generara un archivo gif\n'</span>);
0714             <span class="keyword">end</span>
0715             
0716             <span class="comment">% Grafica el sistema</span>
0717             <span class="keyword">if</span> numCuadros &lt;= 0
0718                 fprintf(<span class="string">'\tSe grafica el caso con la deformacion maxima\n'</span>);
0719                 <a href="#_sub35" class="code" title="subfunction plotAnimado(analisisObj, deformada, modo, factor, phif, limx, limy, limz, ">plotAnimado</a>(analisisObj, deformada, modo, factor, 1, <span class="keyword">...</span>
0720                     limx, limy, limz, tn, 1, 1, defElem, defCarga, carga, <span class="keyword">...</span>
0721                     1, tCargaEq, mostrarEstatico, disipadores, r.styleNodoE, <span class="keyword">...</span>
0722                     r.sizeNodoE, r.styleNodoD, r.sizeNodoD, r.styleElemE, <span class="keyword">...</span>
0723                     r.lwElemE, r.styleElemD, r.lwElemD, r.styleDisipador, <span class="keyword">...</span>
0724                     r.colorDisipador, r.lwDisipador, r.unidad, <span class="keyword">...</span>
0725                     r.angAzh, r.angPol);
0726                 fprintf(<span class="string">'\tProceso finalizado en %.2f segundos\n'</span>, cputime-tinicial);
0727             <span class="keyword">else</span>
0728                 <a href="#_sub35" class="code" title="subfunction plotAnimado(analisisObj, deformada, modo, factor, phif, limx, limy, limz, ">plotAnimado</a>(analisisObj, deformada, modo, factor, 0, <span class="keyword">...</span>
0729                     limx, limy, limz, tn, 1, 1, defElem, defCarga, <span class="keyword">...</span>
0730                     carga, tCargaPos(1), tCargaEq, mostrarEstatico, disipadores, <span class="keyword">...</span>
0731                     r.styleNodoE, r.sizeNodoE, r.styleNodoD, r.sizeNodoD, <span class="keyword">...</span>
0732                     r.styleElemE, r.lwElemE, r.styleElemD, r.lwElemD, <span class="keyword">...</span>
0733                     r.styleDisipador, r.colorDisipador, r.lwDisipador, <span class="keyword">...</span>
0734                     r.unidad, r.angAzh, r.angPol);
0735                 hold off;
0736                 
0737                 <span class="comment">% Obtiene el numero de cuadros</span>
0738                 t = 0;
0739                 dt = 2 * pi() / numCuadros;
0740                 reverse_porcent = <span class="string">''</span>;
0741                 
0742                 <span class="comment">% Crea la estructura de cuadros</span>
0743                 Fr(numCuadros) = struct(<span class="string">'cdata'</span>, [], <span class="string">'colormap'</span>, []);
0744                 
0745                 <span class="keyword">for</span> i = 1:numCuadros
0746                     
0747                     <span class="comment">% Si el usuario cierra el plot termina de graficar</span>
0748                     <span class="keyword">if</span> ~ishandle(plt) || ~ishghandle(plt)
0749                         delete(plt);
0750                         close(fig_num); <span class="comment">% Cierra el grafico</span>
0751                         fprintf(<span class="string">'\n\tSe ha cancelado el proceso del grafico\n'</span>);
0752                         <span class="keyword">return</span>;
0753                     <span class="keyword">end</span>
0754                     
0755                     t = t + dt;
0756                     <span class="keyword">try</span>
0757                         <span class="comment">% figure(fig_num); % Atrapa el foco</span>
0758                         <a href="#_sub35" class="code" title="subfunction plotAnimado(analisisObj, deformada, modo, factor, phif, limx, limy, limz, ">plotAnimado</a>(analisisObj, deformada, modo, factor, sin(t), <span class="keyword">...</span>
0759                             limx, limy, limz, tn, i, numCuadros, defElem, defCarga, <span class="keyword">...</span>
0760                             carga, tCargaPos(i), tCargaEq, mostrarEstatico, disipadores, <span class="keyword">...</span>
0761                             r.styleNodoE, r.sizeNodoE, r.styleNodoD, r.sizeNodoD, <span class="keyword">...</span>
0762                             r.styleElemE, r.lwElemE, r.styleElemD, r.lwElemD, <span class="keyword">...</span>
0763                             r.styleDisipador, r.colorDisipador, r.lwDisipador, <span class="keyword">...</span>
0764                             r.unidad, r.angAzh, r.angPol);
0765                         drawnow;
0766                         Fr(i) = getframe(plt);
0767                         im = frame2im(Fr(i));
0768                         [imind, cm] = rgb2ind(im, 256);
0769                         <span class="keyword">if</span> i == 1
0770                             imwrite(imind, cm, guardaGif, <span class="string">'gif'</span>, <span class="string">'Loopcount'</span>, inf, <span class="string">'DelayTime'</span>, 0.1);
0771                         <span class="keyword">else</span>
0772                             imwrite(imind, cm, guardaGif, <span class="string">'gif'</span>, <span class="string">'WriteMode'</span>, <span class="string">'append'</span>, <span class="string">'DelayTime'</span>, 0.1);
0773                         <span class="keyword">end</span>
0774                     <span class="keyword">catch</span> <span class="comment">%#ok&lt;*CTCH&gt;</span>
0775                         fprintf(<span class="string">'\n\tSe ha cancelado el proceso del grafico\n'</span>);
0776                         <span class="keyword">return</span>;
0777                     <span class="keyword">end</span>
0778                     hold off;
0779                     
0780                     msg = sprintf(<span class="string">'\tGraficando ... %.1f/100'</span>, i/numCuadros*100);
0781                     fprintf([reverse_porcent, msg]);
0782                     reverse_porcent = repmat(sprintf(<span class="string">'\b'</span>), 1, length(msg));
0783                     
0784                 <span class="keyword">end</span> <span class="comment">% for i</span>
0785                 
0786                 <span class="keyword">if</span> guardarGif
0787                     fprintf(<span class="string">'\n\tGuardando animacion gif en: %s\n'</span>, guardaGif);
0788                 <span class="keyword">end</span>
0789                 
0790                 <span class="comment">% Imprime en consola el tiempo que se demoro el proceso</span>
0791                 fprintf(<span class="string">'\tProceso finalizado en %.2f segundos\n'</span>, cputime-tinicial);
0792                 
0793                 <span class="comment">% Reproduce la pelicula y cierra el grafico anterior</span>
0794                 close(fig_num);
0795                 <span class="keyword">if</span> analisisObj.cargarAnimacion
0796                     fprintf(<span class="string">'\n\tAbriendo animacion\n'</span>);
0797                     <span class="keyword">try</span>
0798                         <a href="../../tefame/lib/gifPlayerGUI.html" class="code" title="function gifPlayerGUI(fname, delayTime)">gifPlayerGUI</a>(guardaGif, 1/min(numCuadros, 60));
0799                     <span class="keyword">catch</span>
0800                         error(<span class="string">'Ha ocurrido un error al abrir el gif generado'</span>);
0801                     <span class="keyword">end</span>
0802                 <span class="keyword">else</span>
0803                     fprintf(<span class="string">'\n'</span>);
0804                 <span class="keyword">end</span>
0805                 
0806                 <span class="comment">% Cierra la linea</span>
0807                 <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
0808                 
0809             <span class="keyword">end</span>
0810             
0811         <span class="keyword">end</span> <span class="comment">% plot function</span>
0812         
0813         <a name="_sub15" href="#_subfunctions" class="code">function calcularDesplazamientoDrift(analisisObj, carga, xanalisis, varargin)</a>
0814             <span class="comment">% calcularDesplazamientoDrift: Funcion que calcula el desplazamiento y</span>
0815             <span class="comment">% drift a partir de una carga</span>
0816             <span class="comment">%</span>
0817             <span class="comment">% calcularDesplazamientoDrift(analisisObj,carga,xanalisis,varargin)</span>
0818             <span class="comment">%</span>
0819             <span class="comment">% Parametros opcionales:</span>
0820             <span class="comment">%   'unidad'        Unidad de largo</span>
0821             
0822             <span class="comment">% Inicia proceso</span>
0823             tinicial = cputime;
0824             
0825             <span class="comment">% Define variables opcionales</span>
0826             p = inputParser;
0827             p.KeepUnmatched = true;
0828             addOptional(p, <span class="string">'unidad'</span>, <span class="string">'m'</span>);
0829             parse(p, varargin{:});
0830             r = p.Results;
0831             
0832             <span class="comment">% Verifica que la carga se haya calculado</span>
0833             <span class="keyword">if</span> ~(isa(carga, <span class="string">'CargaDinamica'</span>) || isa(carga, <span class="string">'CombinacionCargas'</span>))
0834                 error(<span class="string">'Solo se pueden graficar cargas dinamicas o combinaciones de cargas'</span>);
0835             <span class="keyword">end</span>
0836             desp = carga.obtenerDesplazamiento();
0837             <span class="keyword">if</span> isempty(desp)
0838                 error(<span class="string">'La carga %s no se ha calculado'</span>, carga.obtenerEtiqueta());
0839             <span class="keyword">end</span>
0840             
0841             fprintf(<span class="string">'Calculando desplazamiento y drift:\n'</span>);
0842             ctitle = analisisObj.imprimirPropiedadesAnalisisCarga(carga);
0843             
0844             <span class="comment">% Se genera vector en que las filas contienen nodos en un mismo piso,</span>
0845             <span class="comment">% rellenando con ceros la matriz en caso de diferencia de nodos por piso.</span>
0846             <span class="comment">% Tambien se genera vector que contiene alturas de piso</span>
0847             nodos = analisisObj.modeloObj.obtenerNodos();
0848             nnodos = length(nodos);
0849             habs = zeros(1, 1);
0850             hNodos = zeros(1, 1);
0851             
0852             j = 1;
0853             k = 1;
0854             l = 1;
0855             ini = 1;
0856             ndrift = [];
0857             <span class="keyword">for</span> i = 1:nnodos
0858                 CoordNodo = nodos{i}.obtenerCoordenadas;
0859                 xNodo = CoordNodo(1);
0860                 yNodo = CoordNodo(2);
0861                 <span class="keyword">if</span> yNodo ~= habs(j)
0862                     k = 1;
0863                     j = j + 1;
0864                     habs(j, 1) = yNodo;
0865                     hNodos(j, k) = i;
0866                 <span class="keyword">elseif</span> i == 1
0867                     hNodos(j, k) = i;
0868                 <span class="keyword">else</span>
0869                     k = k + 1;
0870                     hNodos(j, k) = i;
0871                 <span class="keyword">end</span>
0872                 <span class="keyword">if</span> yNodo == 0
0873                     ini = ini + 1;
0874                 <span class="keyword">end</span>
0875                 <span class="keyword">if</span> xNodo == xanalisis
0876                     ndrift(l) = i; <span class="comment">%#ok&lt;AGROW&gt;</span>
0877                     l = l + 1;
0878                 <span class="keyword">end</span>
0879             <span class="keyword">end</span> <span class="comment">% for i</span>
0880             
0881             [~, s] = size(desp);
0882             nndrift = length(ndrift);
0883             
0884             <span class="keyword">if</span> isempty(ndrift)
0885                 error(<span class="string">'Posicion direccion analisis %.2f invalida'</span>, xanalisis);
0886             <span class="keyword">end</span>
0887             
0888             despx = zeros(nndrift, s);
0889             driftx = zeros(nndrift-1, s);
0890             
0891             <span class="comment">% Calculo de drift y desplazamiento en linea de analisis</span>
0892             <span class="keyword">for</span> i = 2:nndrift
0893                 nodosup = ndrift(i);
0894                 gdls = nodos{nodosup}.obtenerGDLIDCondensado();
0895                 gdlx = gdls(1);
0896                 despx(i, :) = desp(gdlx, :);
0897                 driftx(i-1, :) = abs(despx(i, :)-despx(i-1, :)) ./ (habs(i) - habs(i-1));
0898                 
0899             <span class="keyword">end</span> <span class="comment">% for i</span>
0900             
0901             <span class="comment">% Determinacion de envolvente maxima de desplazamiento y drift</span>
0902             despxmax = max(abs(despx'))';
0903             driftxmax = max(abs(driftx'))';
0904             VecDesp = flipud(despxmax);
0905             VecDrift = flipud(driftxmax);
0906             hgen = flipud(habs);
0907             hplot = zeros(2*length(hgen), 1);
0908             Despplot = zeros(2*length(hgen)-1, 1);
0909             Driftplot = zeros(2*length(hgen)-1, 1);
0910             aux1 = 1;
0911             aux2 = 2;
0912             <span class="keyword">for</span> i = 1:length(hgen)
0913                 hplot(aux1, 1) = hgen(i);
0914                 hplot(aux1+1, 1) = hgen(i);
0915                 <span class="keyword">if</span> aux2 &lt;= 2 * length(hgen) - 1
0916                     Driftplot(aux2, 1) = VecDrift(i);
0917                     Driftplot(aux2+1, 1) = VecDrift(i);
0918                     Despplot(aux2, 1) = VecDesp(i);
0919                     Despplot(aux2+1, 1) = VecDesp(i);
0920                 <span class="keyword">end</span>
0921                 aux1 = aux1 + 2;
0922                 aux2 = aux2 + 2;
0923             <span class="keyword">end</span> <span class="comment">% for i</span>
0924             hplot(length(hplot)) = [];
0925             
0926             <span class="comment">% Crea las figuras</span>
0927             fig_title = sprintf(<span class="string">'Envolvente de Deriva Entre Piso - %s %s'</span>, ctitle, carga.obtenerEtiqueta());
0928             plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
0929             movegui(plt, <span class="string">'center'</span>);
0930             <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(Driftplot.*100, hplot, <span class="string">'*-'</span>, <span class="string">'LineWidth'</span>, 1, <span class="string">'Color'</span>, <span class="string">'black'</span>);
0931             grid on;
0932             grid minor;
0933             xlabel(<span class="string">'Drift (%)'</span>);
0934             ylabel(sprintf(<span class="string">'Altura (%s)'</span>, r.unidad));
0935             title(fig_title);
0936             
0937             fig_title = sprintf(<span class="string">'Envolvente de Desplazamiento - %s %s'</span>, ctitle, carga.obtenerEtiqueta());
0938             plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
0939             movegui(plt, <span class="string">'center'</span>);
0940             <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(Despplot, hplot, <span class="string">'*-'</span>, <span class="string">'LineWidth'</span>, 1, <span class="string">'Color'</span>, <span class="string">'black'</span>);
0941             grid on;
0942             grid minor;
0943             xlabel(sprintf(<span class="string">'Desplazamiento (%s)'</span>, r.unidad));
0944             ylabel(sprintf(<span class="string">'Altura (%s)'</span>, r.unidad));
0945             title(fig_title);
0946             
0947             <span class="comment">% Finaliza proceso</span>
0948             drawnow();
0949             fprintf(<span class="string">'\tProceso finalizado en %.2f segundos\n'</span>, cputime-tinicial);
0950             <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
0951             
0952         <span class="keyword">end</span> <span class="comment">% calcularDesplazamientoDrift function</span>
0953         
0954         <a name="_sub16" href="#_subfunctions" class="code">function calcularMomentoCorteBasal(analisisObj, carga, varargin)</a>
0955             <span class="comment">% calcularMomentoCorteBasal: Funcion que calcula el momento y</span>
0956             <span class="comment">% corte basal a partir de una carga</span>
0957             <span class="comment">%</span>
0958             <span class="comment">% calcularMomentoCorteBasal(analisisObj,carga,varargin)</span>
0959             <span class="comment">%</span>
0960             <span class="comment">% Parametros opcionales:</span>
0961             <span class="comment">%   'plot'      'all','momento','corte','envmomento','envcorte'</span>
0962             <span class="comment">%   'modo'      Vector con graficos de modos</span>
0963             <span class="comment">%   'closeall'  Cierra todos los graficos</span>
0964             <span class="comment">%   'unidadC'   Unidad corte del modelo</span>
0965             <span class="comment">%   'unidadM'   Unidad momento del modelo</span>
0966             
0967             <span class="comment">% Inicia proceso</span>
0968             tinicial = cputime;
0969             fprintf(<span class="string">'Calculando grafico momento corte basal:\n'</span>);
0970             
0971             <span class="comment">% Rescata parametros</span>
0972             p = inputParser;
0973             p.KeepUnmatched = true;
0974             addOptional(p, <span class="string">'plot'</span>, <span class="string">'all'</span>);
0975             addOptional(p, <span class="string">'modo'</span>, []);
0976             addOptional(p, <span class="string">'closeall'</span>, false);
0977             addOptional(p, <span class="string">'unidadC'</span>, <span class="string">'tonf'</span>);
0978             addOptional(p, <span class="string">'unidadM'</span>, <span class="string">'tonf-m'</span>);
0979             parse(p, varargin{:});
0980             r = p.Results;
0981             tipoplot = r.plot;
0982             envmodo = r.modo;
0983             
0984             <span class="keyword">if</span> r.closeall
0985                 close all;
0986             <span class="keyword">end</span>
0987             
0988             <span class="comment">% Verifica que la carga se haya calculado</span>
0989             <span class="keyword">if</span> ~(isa(carga, <span class="string">'CargaDinamica'</span>) || isa(carga, <span class="string">'CombinacionCargas'</span>))
0990                 error(<span class="string">'Solo se pueden graficar cargas dinamicas o combinaciones de cargas'</span>);
0991             <span class="keyword">end</span>
0992             acel = carga.obtenerAceleracion();
0993             <span class="keyword">if</span> isempty(acel)
0994                 error(<span class="string">'La carga %s no se ha calculado'</span>, carga.obtenerEtiqueta());
0995             <span class="keyword">end</span>
0996             ctitle = analisisObj.imprimirPropiedadesAnalisisCarga(carga);
0997             
0998             <span class="comment">% Verifica que envmodo sea correcto</span>
0999             [~, lphi] = size(analisisObj.phin);
1000             lenvmodo = length(envmodo);
1001             envmodo = sort(envmodo);
1002             <span class="keyword">for</span> i = 1:lenvmodo
1003                 envmodo(i) = floor(envmodo(i));
1004                 <span class="keyword">if</span> envmodo(i) &lt; 0 || envmodo(i) &gt; lphi
1005                     error(<span class="string">'Analisis modo %d invalido'</span>, envmodo(i));
1006                 <span class="keyword">end</span>
1007             <span class="keyword">end</span> <span class="comment">% for i</span>
1008             
1009             <span class="comment">% Calcula el momento</span>
1010             [Cortante, Momento, CBplot, MBplot, hplot] = analisisObj.calcularMomentoCorteBasalAcel(acel);
1011             
1012             <span class="comment">% Graficos</span>
1013             t = carga.obtenerVectorTiempo(); <span class="comment">% Vector de tiempo</span>
1014             dplot = false; <span class="comment">% Indica si se realizo algun grafico</span>
1015             
1016             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'corte'</span>)
1017                 fig_title = sprintf(<span class="string">'Historial de Cortante Basal - %s %s'</span>, ctitle, carga.obtenerEtiqueta());
1018                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1019                 movegui(plt, <span class="string">'center'</span>);
1020                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, Cortante(<span class="keyword">end</span>, :), <span class="string">'k-'</span>, <span class="string">'LineWidth'</span>, 1);
1021                 grid on;
1022                 grid minor;
1023                 xlabel(<span class="string">'Tiempo (s)'</span>);
1024                 ylabel(sprintf(<span class="string">'Corte (%s)'</span>, r.unidadC));
1025                 title(fig_title);
1026                 dplot = true;
1027             <span class="keyword">end</span>
1028             
1029             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'momento'</span>)
1030                 fig_title = sprintf(<span class="string">'Historial de Momento Basal - %s %s'</span>, ctitle, carga.obtenerEtiqueta());
1031                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1032                 movegui(plt, <span class="string">'center'</span>);
1033                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, Momento(<span class="keyword">end</span>, :), <span class="string">'k-'</span>, <span class="string">'LineWidth'</span>, 1);
1034                 grid on;
1035                 grid minor;
1036                 xlabel(<span class="string">'Tiempo (s)'</span>);
1037                 ylabel(sprintf(<span class="string">'Momento (%s)'</span>, r.unidadM));
1038                 title(fig_title);
1039                 dplot = true;
1040             <span class="keyword">end</span>
1041             
1042             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'envcorte'</span>)
1043                 fig_title = sprintf(<span class="string">'Envolvente de Cortante Basal - %s %s'</span>, ctitle, carga.obtenerEtiqueta());
1044                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1045                 movegui(plt, <span class="string">'center'</span>);
1046                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(CBplot, hplot, <span class="string">'*-'</span>, <span class="string">'LineWidth'</span>, 1, <span class="string">'Color'</span>, <span class="string">'black'</span>);
1047                 hold on;
1048                 grid on;
1049                 grid minor;
1050                 xlabel(sprintf(<span class="string">'Corte (%s)'</span>, r.unidadC));
1051                 ylabel(<span class="string">'Altura (m)'</span>);
1052                 title(fig_title);
1053                 
1054                 <span class="comment">% Realiza los analisis por modo</span>
1055                 CBLegend = cell(1, 1+lenvmodo);
1056                 CBplotModoAnt = false;
1057                 CBLegend{1} = <span class="string">'Envolvente'</span>;
1058                 phiac = analisisObj.phin' * acel;
1059                 <span class="keyword">for</span> i = 1:lenvmodo
1060                     [~, ~, CBplotModo, ~, ~] = analisisObj.calcularMomentoCorteBasalAcel(analisisObj.phin(:, envmodo(i))*phiac(envmodo(i), :));
1061                     <span class="keyword">if</span> i &gt; 1
1062                         CBplotModo = CBplotModo + CBplotModoAnt;
1063                     <span class="keyword">end</span>
1064                     CBplotModoAnt = CBplotModo;
1065                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(CBplotModo, hplot, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, 1);
1066                     CBLegend{i+1} = sprintf(<span class="string">'Modo %d'</span>, envmodo(i));
1067                 <span class="keyword">end</span> <span class="comment">% for i</span>
1068                 <span class="keyword">if</span> lenvmodo &gt; 0
1069                     legend(CBLegend);
1070                 <span class="keyword">end</span>
1071                 dplot = true;
1072             <span class="keyword">end</span>
1073             
1074             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'envmomento'</span>)
1075                 fig_title = sprintf(<span class="string">'Envolvente de Momento Basal - %s %s'</span>, ctitle, carga.obtenerEtiqueta());
1076                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1077                 movegui(plt, <span class="string">'center'</span>);
1078                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(MBplot, hplot, <span class="string">'*-'</span>, <span class="string">'LineWidth'</span>, 1, <span class="string">'Color'</span>, <span class="string">'black'</span>);
1079                 grid on;
1080                 grid minor;
1081                 xlabel(sprintf(<span class="string">'Momento (%s)'</span>, r.unidadM));
1082                 ylabel(<span class="string">'Altura (m)'</span>);
1083                 title(fig_title);
1084                 dplot = true;
1085             <span class="keyword">end</span>
1086             
1087             <span class="comment">% Si no se realizo ningun grafico</span>
1088             <span class="keyword">if</span> ~dplot
1089                 error(<span class="string">'Tipo de grafico %s incorrecto, valores aceptados: %s'</span>, tipoplot, <span class="keyword">...</span>
1090                     <span class="string">'corte, momento, envcorte, envmomento'</span>);
1091             <span class="keyword">end</span>
1092             
1093             <span class="comment">% Finaliza proceso</span>
1094             drawnow();
1095             fprintf(<span class="string">'\tProceso finalizado en %.2f segundos\n'</span>, cputime-tinicial);
1096             <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
1097             
1098         <span class="keyword">end</span> <span class="comment">% calcularMomentoCorteBasal function</span>
1099         
1100         <a name="_sub17" href="#_subfunctions" class="code">function calcularCurvasEnergia(analisisObj, carga, varargin)</a>
1101             <span class="comment">% calcularCurvasEnergia: Genera las curvas de energia a partir</span>
1102             <span class="comment">% de una carga</span>
1103             <span class="comment">%</span>
1104             <span class="comment">% calcularCurvasEnergia(analisisObj,carga,varargin)</span>
1105             <span class="comment">%</span>
1106             <span class="comment">% Parametros opcionales:</span>
1107             <span class="comment">%   'plot'          'all','ek','ev','ekev','ebe','et','ed'</span>
1108             <span class="comment">%   'carga'         Booleano que indica si se grafica la carga o no</span>
1109             <span class="comment">%   'mfilt'         Porcentaje de filtrado por numero de datos</span>
1110             <span class="comment">%   'linewidth'     Ancho de linea de los graficos</span>
1111             <span class="comment">%   'norm1'         Normaliza con respecto al primer valor</span>
1112             <span class="comment">%   'closeall'      Cierra todos los graficos</span>
1113             
1114             <span class="comment">% Inicia el proceso</span>
1115             tinicial = cputime;
1116             
1117             <span class="comment">% Recorre parametros opcionales</span>
1118             p = inputParser;
1119             p.KeepUnmatched = true;
1120             addOptional(p, <span class="string">'plot'</span>, <span class="string">'all'</span>);
1121             addOptional(p, <span class="string">'plotcarga'</span>, false);
1122             addOptional(p, <span class="string">'mfilt'</span>, 0.005);
1123             addOptional(p, <span class="string">'linewidth'</span>, 1.2);
1124             addOptional(p, <span class="string">'norm1'</span>, false);
1125             addOptional(p, <span class="string">'closeall'</span>, false);
1126             parse(p, varargin{:});
1127             r = p.Results;
1128             
1129             <span class="keyword">if</span> r.closeall
1130                 close all;
1131             <span class="keyword">end</span>
1132             
1133             <span class="comment">% Obtiene variables</span>
1134             tipoplot = r.plot;
1135             plotcarga = r.plotcarga;
1136             
1137             <span class="comment">% Verifica que la carga se haya calculado</span>
1138             <span class="keyword">if</span> ~(isa(carga, <span class="string">'CargaDinamica'</span>) || isa(carga, <span class="string">'CombinacionCargas'</span>))
1139                 error(<span class="string">'Solo se pueden graficar cargas dinamicas o una combinacion de cargas'</span>);
1140             <span class="keyword">end</span>
1141             c_u = carga.obtenerDesplazamiento();
1142             c_v = carga.obtenerVelocidad();
1143             c_p = carga.obtenerCarga();
1144             
1145             <span class="keyword">if</span> isempty(c_u)
1146                 error(<span class="string">'La carga %s no se ha calculado'</span>, carga.obtenerEtiqueta());
1147             <span class="keyword">end</span>
1148             
1149             <span class="comment">% Realiza calculos de energia</span>
1150             fprintf(<span class="string">'Calculando curvas de energia:\n'</span>);
1151             ctitle = analisisObj.imprimirPropiedadesAnalisisCarga(carga);
1152             
1153             <span class="comment">% Obtiene las matrices</span>
1154             k = analisisObj.obtenerMatrizRigidez();
1155             m = analisisObj.obtenerMatrizMasa();
1156             c = analisisObj.obtenerMatrizAmortiguamiento(carga.usoAmortiguamientoRayleigh());
1157             
1158             <span class="comment">% Si se usaron disipadores</span>
1159             <span class="keyword">if</span> carga.usoDeDisipadores()
1160                 cdv = analisisObj.obtenerMatrizAmortiguamientoDisipadores();
1161                 kdv = analisisObj.obtenerMatrizRigidezDisipadores();
1162                 fprintf(<span class="string">'\t\tLa %s se calculo con disipadores\n'</span>, lower(ctitle));
1163             <span class="keyword">else</span>
1164                 fprintf(<span class="string">'\t\tLa %s se calculo sin disipadores\n'</span>, lower(ctitle));
1165             <span class="keyword">end</span>
1166             
1167             <span class="comment">% Graficos</span>
1168             [~, s] = size(c_u);
1169             t = carga.obtenerVectorTiempo(); <span class="comment">% Vector de tiempo</span>
1170             
1171             <span class="comment">% Energia cinetica</span>
1172             e_k = zeros(1, s);
1173             ek1 = 0;
1174             fprintf(<span class="string">'\tCalculando energia cinetica\n'</span>);
1175             <span class="keyword">for</span> i = 1:s
1176                 vv = c_v(:, i); <span class="comment">% Obtiene el vector de velocidad para el tiempo i</span>
1177                 e_k(i) = 0.5 * vv' * m * vv;
1178                 <span class="keyword">if</span> i == 1
1179                     ek1 = e_k(i);
1180                 <span class="keyword">end</span>
1181                 <span class="keyword">if</span> r.norm1
1182                     e_k(i) = e_k(i) - ek1;
1183                 <span class="keyword">end</span>
1184             <span class="keyword">end</span> <span class="comment">% for i</span>
1185             
1186             <span class="comment">% Energia elastica</span>
1187             e_v = zeros(1, s);
1188             fprintf(<span class="string">'\tCalculando energia elastica\n'</span>);
1189             ev1 = 0;
1190             <span class="keyword">for</span> i = 1:s
1191                 vv = c_u(:, i); <span class="comment">% Obtiene el vector de desplazamiento para el tiempo i</span>
1192                 e_v(i) = 0.5 * vv' * k * vv;
1193                 <span class="keyword">if</span> i == 1
1194                     ev1 = e_v(1);
1195                 <span class="keyword">end</span>
1196                 <span class="keyword">if</span> r.norm1
1197                     e_v(i) = e_v(i) - ev1; <span class="comment">% Normaliza restando el valor inicial</span>
1198                 <span class="keyword">end</span>
1199             <span class="keyword">end</span> <span class="comment">% for i</span>
1200             
1201             <span class="comment">% Energia elastica disipadores</span>
1202             e_vamori = zeros(1, s); <span class="comment">% Parcial</span>
1203             e_vamor = zeros(1, s); <span class="comment">% Integral</span>
1204             ev1a = 0;
1205             
1206             <span class="keyword">if</span> carga.usoDeDisipadores()
1207                 fprintf(<span class="string">'\tCalculando energia elastica de los amortiguadores\n'</span>);
1208                 <span class="keyword">for</span> i = 1:s
1209                     uu = c_u(:, i); <span class="comment">% Obtiene el vector de desplazamiento para el tiempo i</span>
1210                     e_vamori(i) = uu' * kdv * uu;
1211                     <span class="keyword">if</span> i == 1
1212                         ev1a = e_vamori(1);
1213                     <span class="keyword">end</span>
1214                     <span class="keyword">if</span> r.norm1 <span class="comment">% Normaliza con el primer valor</span>
1215                         e_vamori(i) = e_vamori(i) - ev1a;
1216                     <span class="keyword">end</span>
1217                     <span class="keyword">if</span> i &gt; 1
1218                         dt = t(i) - t(i - 1);
1219                         e_vamor(i) = e_vamor(i - 1) + 0.5 * (e_vamori(i) + e_vamori(i - 1)) * dt;
1220                     <span class="keyword">end</span>
1221                 <span class="keyword">end</span> <span class="comment">% for i</span>
1222             <span class="keyword">end</span>
1223             
1224             <span class="comment">% Energia disipada</span>
1225             e_di = zeros(1, s); <span class="comment">% Parcial</span>
1226             e_d = zeros(1, s); <span class="comment">% Integral</span>
1227             ed1 = 0;
1228             
1229             fprintf(<span class="string">'\tCalculando energia disipada por la estructura\n'</span>);
1230             <span class="keyword">for</span> i = 1:s
1231                 vv = c_v(:, i); <span class="comment">% Obtiene el vector de velocidad para el tiempo i</span>
1232                 e_di(i) = vv' * c * vv;
1233                 <span class="keyword">if</span> i == 1
1234                     ed1 = e_di(1);
1235                 <span class="keyword">end</span>
1236                 <span class="keyword">if</span> r.norm1 <span class="comment">% Normaliza con el primer valor</span>
1237                     e_di(i) = e_di(i) - ed1;
1238                 <span class="keyword">end</span>
1239                 <span class="keyword">if</span> i &gt; 1
1240                     dt = t(i) - t(i-1);
1241                     e_d(i) = e_d(i-1) + 0.5 * (e_di(i) + e_di(i-1)) * dt;
1242                 <span class="keyword">end</span>
1243             <span class="keyword">end</span> <span class="comment">% for i</span>
1244             
1245             <span class="comment">% Energia disipada amortiguadores</span>
1246             e_damori = zeros(1, s); <span class="comment">% Parcial</span>
1247             e_damor = zeros(1, s); <span class="comment">% Integral</span>
1248             eda1 = 0;
1249             
1250             <span class="keyword">if</span> carga.usoDeDisipadores()
1251                 fprintf(<span class="string">'\tCalculando energia disipada por los amortiguadores\n'</span>);
1252                 <span class="keyword">for</span> i = 1:s
1253                     vv = c_v(:, i); <span class="comment">% Obtiene el vector de velocidad para el tiempo i</span>
1254                     e_damori(i) = vv' * cdv * vv;
1255                     <span class="keyword">if</span> i == 1
1256                         eda1 = e_damori(1);
1257                     <span class="keyword">end</span>
1258                     <span class="keyword">if</span> r.norm1 <span class="comment">% Normaliza con el primer valor</span>
1259                         e_damori(i) = e_damori(i) - eda1;
1260                     <span class="keyword">end</span>
1261                     <span class="keyword">if</span> i &gt; 1
1262                         dt = t(i) - t(i - 1);
1263                         e_damor(i) = e_damor(i - 1) + 0.5 * (e_damori(i) + e_damori(i - 1)) * dt;
1264                     <span class="keyword">end</span>
1265                 <span class="keyword">end</span> <span class="comment">% for i</span>
1266             <span class="keyword">end</span>
1267             
1268             <span class="comment">% Trabajo externo</span>
1269             w_ei = zeros(1, s); <span class="comment">% Parcial</span>
1270             w_e = zeros(1, s); <span class="comment">% Integral</span>
1271             fprintf(<span class="string">'\tCalculando trabajo externo\n'</span>);
1272             <span class="keyword">for</span> i = 1:s
1273                 w_ei(i) = c_p(:, i)' * c_v(:, i);
1274                 <span class="keyword">if</span> i &gt; 1
1275                     dt = t(i) - t(i-1);
1276                     w_e(i) = w_e(i-1) + 0.5 * (w_ei(i) + w_ei(i-1)) * dt;
1277                 <span class="keyword">end</span>
1278             <span class="keyword">end</span> <span class="comment">% for i</span>
1279             
1280             <span class="comment">% Energia total</span>
1281             e_t = zeros(1, s);
1282             fprintf(<span class="string">'\tCalculando energia total\n'</span>);
1283             <span class="keyword">for</span> i = 1:s
1284                 e_t(i) = e_k(1) + (e_v(1) + e_vamor(1)) + w_e(i) - (e_d(i) + e_damor(i));
1285             <span class="keyword">end</span> <span class="comment">% for i</span>
1286             
1287             <span class="comment">% Balance energetico normalizado</span>
1288             ebe = zeros(1, s);
1289             fprintf(<span class="string">'\tCalculando balance energetico\n'</span>);
1290             <span class="keyword">for</span> i = 1:s
1291                 ebe(i) = abs(w_e(i)-e_k(i)-(e_d(i) + e_damor(i))) / abs(w_e(i)) * 100;
1292             <span class="keyword">end</span> <span class="comment">% for i</span>
1293             
1294             <span class="comment">% Graficos</span>
1295             fprintf(<span class="string">'\tGenerando graficos\n'</span>);
1296             lw = r.linewidth; <span class="comment">% Linewidth de los graficos</span>
1297             dplot = false; <span class="comment">% Indica que un grafico se realizo</span>
1298             
1299             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'ek'</span>)
1300                 fig_title = sprintf(<span class="string">'E_K Energia Cinetica - %s %s'</span>, ctitle, carga.obtenerEtiqueta());
1301                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1302                 movegui(plt, <span class="string">'center'</span>);
1303                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_k, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1304                 grid on;
1305                 grid minor;
1306                 xlabel(<span class="string">'Tiempo (s)'</span>);
1307                 ylabel(<span class="string">'Energia cinetica'</span>);
1308                 title(fig_title);
1309                 ylims = get(gca, <span class="string">'YLim'</span>);
1310                 ylim([0, max(ylims)]);
1311                 <span class="keyword">if</span> plotcarga <span class="comment">% Grafica la carga</span>
1312                     axes(<span class="string">'Position'</span>, [.59, .70, .29, .20]);
1313                     box on;
1314                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, c_p, <span class="string">'k-'</span>, <span class="string">'Linewidth'</span>, 0.8);
1315                     grid on;
1316                 <span class="keyword">end</span>
1317                 dplot = true;
1318             <span class="keyword">end</span>
1319             
1320             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'ev'</span>)
1321                 fig_title = sprintf(<span class="string">'E_V Energia Elastica - %s %s'</span>, <span class="keyword">...</span>
1322                     ctitle, carga.obtenerEtiqueta());
1323                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1324                 movegui(plt, <span class="string">'center'</span>);
1325                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_v+e_vamor, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1326                 grid on;
1327                 grid minor;
1328                 xlabel(<span class="string">'Tiempo (s)'</span>);
1329                 ylabel(<span class="string">'Energia elastica'</span>);
1330                 title(fig_title);
1331                 ylims = get(gca, <span class="string">'YLim'</span>);
1332                 ylim([0, max(ylims)]);
1333                 <span class="keyword">if</span> plotcarga <span class="comment">% Grafica la carga</span>
1334                     axes(<span class="string">'Position'</span>, [.59, .70, .29, .20]);
1335                     box on;
1336                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, c_p, <span class="string">'k-'</span>, <span class="string">'Linewidth'</span>, 0.8);
1337                     grid on;
1338                 <span class="keyword">end</span>
1339                 dplot = true;
1340             <span class="keyword">end</span>
1341             
1342             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'ebe'</span>)
1343                 fig_title = sprintf(<span class="string">'Balance Energetico Normalizado - %s %s'</span>, <span class="keyword">...</span>
1344                     ctitle, carga.obtenerEtiqueta());
1345                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1346                 movegui(plt, <span class="string">'center'</span>);
1347                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, ebe, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1348                 grid on;
1349                 grid minor;
1350                 xlabel(<span class="string">'Tiempo (s)'</span>);
1351                 ylabel(<span class="string">'EBE (%)'</span>);
1352                 title(fig_title);
1353                 ylims = get(gca, <span class="string">'YLim'</span>);
1354                 ylim([0, max(ylims)]);
1355                 <span class="keyword">if</span> plotcarga <span class="comment">% Grafica la carga</span>
1356                     axes(<span class="string">'Position'</span>, [.59, .70, .29, .20]);
1357                     box on;
1358                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, c_p, <span class="string">'k-'</span>, <span class="string">'Linewidth'</span>, 0.8);
1359                     grid on;
1360                 <span class="keyword">end</span>
1361                 dplot = true;
1362             <span class="keyword">end</span>
1363             
1364             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'evek'</span>) || strcmp(tipoplot, <span class="string">'ekev'</span>)
1365                 fig_title = sprintf(<span class="string">'Energia Potencial - Cinetica - %s %s'</span>, <span class="keyword">...</span>
1366                     ctitle, carga.obtenerEtiqueta());
1367                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1368                 movegui(plt, <span class="string">'center'</span>);
1369                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_k, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1370                 hold on;
1371                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_v+e_vamor, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1372                 grid on;
1373                 grid minor;
1374                 xlabel(<span class="string">'Tiempo (s)'</span>);
1375                 ylabel(<span class="string">'Energia'</span>);
1376                 legend({<span class="string">'E_K Energia cinetica'</span>, <span class="string">'E_V Energia elastica'</span>}, <span class="keyword">...</span>
1377                     <span class="string">'location'</span>, <span class="string">'northeast'</span>);
1378                 title(fig_title);
1379                 ylims = get(gca, <span class="string">'YLim'</span>);
1380                 ylim([0, max(ylims)]);
1381                 <span class="keyword">if</span> plotcarga <span class="comment">% Grafica la carga</span>
1382                     axes(<span class="string">'Position'</span>, [.59, .55, .29, .20]);
1383                     box on;
1384                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, c_p, <span class="string">'k-'</span>, <span class="string">'Linewidth'</span>, 0.8);
1385                     grid on;
1386                 <span class="keyword">end</span>
1387                 dplot = true;
1388             <span class="keyword">end</span>
1389             
1390             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'et'</span>)
1391                 fig_title = sprintf(<span class="string">'Energia Total - Disipada - Ingresada - %s %s'</span>, <span class="keyword">...</span>
1392                     ctitle, carga.obtenerEtiqueta());
1393                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1394                 movegui(plt, <span class="string">'center'</span>);
1395                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_t, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1396                 hold on;
1397                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_d+e_damor, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1398                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, w_e, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1399                 grid on;
1400                 grid minor;
1401                 xlabel(<span class="string">'Tiempo (s)'</span>);
1402                 ylabel(<span class="string">'Energia'</span>);
1403                 legend({<span class="string">'E_t Energia total'</span>, <span class="string">'E_D Energia disipada total'</span>, <span class="keyword">...</span>
1404                     <span class="string">'W_E Trabajo externo'</span>}, <span class="string">'location'</span>, <span class="string">'southeast'</span>);
1405                 title(fig_title);
1406                 ylims = get(gca, <span class="string">'YLim'</span>);
1407                 ylim([0, max(ylims)]);
1408                 <span class="keyword">if</span> plotcarga <span class="comment">% Grafica la carga</span>
1409                     axes(<span class="string">'Position'</span>, [.59, .36, .29, .20]);
1410                     box on;
1411                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, c_p, <span class="string">'k-'</span>, <span class="string">'Linewidth'</span>, 0.8);
1412                     grid on;
1413                 <span class="keyword">end</span>
1414                 dplot = true;
1415             <span class="keyword">end</span>
1416             
1417             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'ed'</span>)
1418                 
1419                 <span class="comment">% Graficos energia disipada</span>
1420                 fig_title = sprintf(<span class="string">'Energia Disipada - %s %s'</span>, <span class="keyword">...</span>
1421                     ctitle, carga.obtenerEtiqueta());
1422                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1423                 movegui(plt, <span class="string">'center'</span>);
1424                 <span class="keyword">if</span> carga.usoDeDisipadores()
1425                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_d+e_damor, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1426                     hold on;
1427                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_d, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1428                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_damor, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1429                     legend({<span class="string">'Energia disipada total'</span>, <span class="string">'Energia disipada por la estructura'</span>, <span class="keyword">...</span>
1430                         <span class="string">'Energia disipada por disipadores'</span>}, <span class="string">'location'</span>, <span class="string">'Best'</span>);
1431                 <span class="keyword">else</span>
1432                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_d, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1433                     <span class="comment">% legend({'Energia disipada por la estructura'}, 'location', 'Best');</span>
1434                 <span class="keyword">end</span>
1435                 grid on;
1436                 grid minor;
1437                 xlabel(<span class="string">'Tiempo (s)'</span>);
1438                 ylabel(<span class="string">'Energia'</span>);
1439                 title(fig_title);
1440                 ylims = get(gca, <span class="string">'YLim'</span>);
1441                 ylim([0, max(ylims)]);
1442                 <span class="comment">% if plotcarga % Grafica la carga</span>
1443                 <span class="comment">%     axes('Position', [.59, .36, .29, .20]);</span>
1444                 <span class="comment">%     box on;</span>
1445                 <span class="comment">%     plot(t, c_p, 'k-', 'Linewidth', 0.8);</span>
1446                 <span class="comment">%     grid on;</span>
1447                 <span class="comment">% end</span>
1448                 dplot = true;
1449                 
1450                 <span class="comment">% Comparacion energia estructura y disipador</span>
1451                 <span class="keyword">if</span> carga.usoDeDisipadores()
1452                     fig_title = {<span class="string">'Razon energia estructura - disipador'</span>, <span class="keyword">...</span>
1453                         sprintf(<span class="string">'%s %s'</span>, ctitle, carga.obtenerEtiqueta())};
1454                     plt = figure(<span class="string">'Name'</span>, fig_title{1}, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1455                     movegui(plt, <span class="string">'center'</span>);
1456                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, medfilt1(e_d./e_damor, floor(r.mfilt*length(e_d))), <span class="keyword">...</span>
1457                         <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1458                     grid on;
1459                     grid minor;
1460                     xlabel(<span class="string">'Tiempo (s)'</span>);
1461                     ylabel(<span class="string">'Razon estructura/disipador'</span>);
1462                     title(fig_title);
1463                     ylims = get(gca, <span class="string">'YLim'</span>);
1464                     ylim([0, max(ylims)]);
1465                     <span class="keyword">if</span> plotcarga <span class="comment">% Grafica la carga</span>
1466                         axes(<span class="string">'Position'</span>, [.59, .68, .29, .20]);
1467                         box on;
1468                         <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, c_p, <span class="string">'k-'</span>, <span class="string">'Linewidth'</span>, 0.8);
1469                         grid on;
1470                     <span class="keyword">end</span>
1471                 <span class="keyword">end</span>
1472                 
1473             <span class="keyword">end</span>
1474             
1475             <span class="comment">% Si no se realizo ningun grafico</span>
1476             <span class="keyword">if</span> ~dplot
1477                 error(<span class="string">'Tipo de grafico %s incorrecto, valores aceptados: %s'</span>, tipoplot, <span class="keyword">...</span>
1478                     <span class="string">'ek, ev, ekev, ebe, et, ed'</span>);
1479             <span class="keyword">end</span>
1480             
1481             <span class="comment">% Finaliza proceso</span>
1482             drawnow();
1483             fprintf(<span class="string">'\tProceso finalizado en %.2f segundos\n'</span>, cputime-tinicial);
1484             <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
1485             
1486         <span class="keyword">end</span> <span class="comment">% calcularCurvasEnergia function</span>
1487         
1488         <a name="_sub18" href="#_subfunctions" class="code">function e_v = calcularModosEnergia(analisisObj, carga, dispinfo)</a>
1489             <span class="comment">% calcularModosEnergia: Metodo que calcula las energias</span>
1490             <span class="comment">% elasticas asociadas a una carga por cada modo y retorna una</span>
1491             <span class="comment">% matriz ordenada por energia y numero de modos</span>
1492             <span class="comment">%</span>
1493             <span class="comment">% w = calcularModosEnergia(analisisObj,carga,dispinfo)</span>
1494             
1495             <span class="keyword">if</span> ~exist(<span class="string">'dispinfo'</span>, <span class="string">'var'</span>)
1496                 dispinfo = true;
1497             <span class="keyword">end</span>
1498             
1499             <span class="comment">% Verifica que la carga se haya calculado</span>
1500             <span class="keyword">if</span> ~isa(carga, <span class="string">'CargaDinamica'</span>)
1501                 error(<span class="string">'Solo se pueden graficar cargas dinamicas'</span>);
1502             <span class="keyword">end</span>
1503             c_u = carga.obtenerDesplazamiento();
1504             
1505             <span class="keyword">if</span> isempty(c_u)
1506                 error(<span class="string">'La carga %s no se ha calculado'</span>, carga.obtenerEtiqueta());
1507             <span class="keyword">end</span>
1508             
1509             <span class="keyword">if</span> dispinfo
1510                 fprintf(<span class="string">'\tCalculando energia elastica por cada modo:\n'</span>);
1511                 analisisObj.imprimirPropiedadesAnalisisCarga(carga);
1512             <span class="keyword">end</span>
1513             
1514             <span class="comment">% Obtiene las matrices</span>
1515             k = analisisObj.obtenerMatrizRigidez();
1516             phi = analisisObj.obtenerMatrizPhi();
1517             
1518             <span class="comment">% Realiza calculos de energia elastica</span>
1519             [~, s] = size(c_u);
1520             
1521             <span class="comment">% Energia elastica total</span>
1522             e_v = zeros(analisisObj.numModos, 5);
1523             <span class="keyword">for</span> j = 1:analisisObj.numModos <span class="comment">% Recorre cada modo</span>
1524                 e_vsum = 0; <span class="comment">% Suma la energia asociada a un modo para todo el tiempo</span>
1525                 kj = phi(:, j)' * k;
1526                 <span class="keyword">for</span> i = 1:s <span class="comment">% Recorre el tiempo</span>
1527                     vv = c_u(:, i); <span class="comment">% Obtiene el vector de desplazamiento para el tiempo i</span>
1528                     e_vsum = e_vsum + 0.5 * vv' * phi(:, j) * kj * vv;
1529                 <span class="keyword">end</span> <span class="comment">% for i</span>
1530                 e_v(j, 1) = j;
1531                 e_v(j, 2) = analisisObj.wn(j);
1532                 e_v(j, 3) = 2 * pi() / analisisObj.wn(j);
1533                 e_v(j, 4) = abs(e_vsum);
1534             <span class="keyword">end</span> <span class="comment">% for j</span>
1535             
1536             <span class="comment">% Normaliza por el maximo</span>
1537             e_vmax = max(e_v(:, 4));
1538             <span class="keyword">for</span> j = 1:analisisObj.numModos
1539                 e_v(j, 4) = e_v(j, 4) / e_vmax;
1540             <span class="keyword">end</span> <span class="comment">% for j</span>
1541             
1542             <span class="comment">% Suma</span>
1543             e_vsum = sum(e_v(:, 4));
1544             <span class="keyword">for</span> j = 1:analisisObj.numModos
1545                 e_v(j, 5) = e_v(j, 4) / e_vsum;
1546             <span class="keyword">end</span> <span class="comment">% for j</span>
1547             
1548             <span class="comment">% Ordena la matriz</span>
1549             e_v = sortrows(e_v, -4);
1550             
1551         <span class="keyword">end</span> <span class="comment">% calcularModosEnergia function</span>
1552         
1553         <a name="_sub19" href="#_subfunctions" class="code">function esfmax = plotEsfuerzosElemento(analisisObj, carga, elemento, direccion, varargin)</a>
1554             <span class="comment">% plotEsfuerzosElemento: Grafica los esfuerzos de un elemento</span>
1555             <span class="comment">%</span>
1556             <span class="comment">% esfmax = plotEsfuerzosElemento(analisisObj,carga,elemento,direccion,varargin)</span>
1557             <span class="comment">%</span>
1558             <span class="comment">% Parametros opcionales:</span>
1559             <span class="comment">%   'tlim'      Tiempo de analisis limite</span>
1560             <span class="comment">%   'unidadC'   Unidad corte</span>
1561             <span class="comment">%   'unidadM'   Unidad momento</span>
1562             
1563             <span class="comment">% Inicia el proceso</span>
1564             tinicial = cputime;
1565             
1566             <span class="comment">% Recorre parametros opcionales</span>
1567             p = inputParser;
1568             p.KeepUnmatched = true;
1569             addOptional(p, <span class="string">'tlim'</span>, 0);
1570             addOptional(p, <span class="string">'unidadC'</span>, <span class="string">'tonf'</span>);
1571             addOptional(p, <span class="string">'unidadM'</span>, <span class="string">'tonf-m'</span>);
1572             parse(p, varargin{:});
1573             r = p.Results;
1574             
1575             <span class="comment">% Obtiene las variables</span>
1576             tlim = r.tlim;
1577             
1578             <span class="comment">% Obtiene resultados de la carga</span>
1579             u_c = carga.obtenerDesplazamiento();
1580             
1581             <span class="comment">% Verifica que la carga se haya calculado</span>
1582             <span class="keyword">if</span> ~(isa(carga, <span class="string">'CargaDinamica'</span>) || isa(carga, <span class="string">'CombinacionCargas'</span>))
1583                 error(<span class="string">'Solo se pueden graficar cargas dinamicas o combinaciones de cargas'</span>);
1584             <span class="keyword">end</span>
1585             <span class="keyword">if</span> isempty(u_c)
1586                 error(<span class="string">'La carga %s no se ha calculado'</span>, carga.obtenerEtiqueta());
1587             <span class="keyword">end</span>
1588             
1589             <span class="comment">% Realiza calculos de esfuerzo</span>
1590             fprintf(<span class="string">'Calculando esfuerzos elemento:\n'</span>);
1591             fprintf(<span class="string">'\tElemento %s\n'</span>, elemento.obtenerEtiqueta());
1592             ctitle = analisisObj.imprimirPropiedadesAnalisisCarga(carga);
1593             
1594             <span class="comment">% Verifica que el elemento este bien definido</span>
1595             <span class="keyword">if</span> ~isa(elemento, <span class="string">'Elemento'</span>)
1596                 error(<span class="string">'El elemento no pertenece a la clase Elemento'</span>);
1597             <span class="keyword">end</span>
1598             
1599             <span class="comment">% Genera el vector de tiempo</span>
1600             t = carga.obtenerVectorTiempo(); <span class="comment">% Vector de tiempo</span>
1601             <span class="keyword">if</span> tlim == 0
1602                 tlim = [min(t), max(t)];
1603             <span class="keyword">else</span>
1604                 tlim = [max(min(tlim), min(t)), min(max(tlim), max(t))];
1605             <span class="keyword">end</span>
1606             
1607             <span class="comment">% Genera el esfuerzo por el tiempo</span>
1608             esf = zeros(analisisObj.modeloObj.obtenerNumerosGDL(), length(t));
1609             esfmax = zeros(analisisObj.modeloObj.obtenerNumerosGDL(), 1);
1610             
1611             <span class="comment">% Obtiene desplazamientos originales de los nodos del elemento</span>
1612             nodos = elemento.obtenerNodos();
1613             despl = {};
1614             <span class="keyword">for</span> i = 1:length(nodos)
1615                 despl{i} = nodos{i}.obtenerDesplazamientos(); <span class="comment">%#ok&lt;AGROW&gt;</span>
1616             <span class="keyword">end</span>
1617             ngdl = nodos{1}.obtenerNumeroGDL();
1618             
1619             <span class="comment">% Verifica la direccion</span>
1620             <span class="keyword">if</span> ~(<a href="../../tefame/utils/verificarVectorDireccion.html" class="code" title="function y = verificarVectorDireccion(vec, ndg)">verificarVectorDireccion</a>(direccion, nodos{1}.obtenerNumeroGDL())) || sum(direccion) ~= 1
1621                 error(<span class="string">'Direccion de analisis del elemento mal definido'</span>);
1622             <span class="keyword">end</span>
1623             dirk = 1; <span class="comment">% Direccion de analisis de cada elemento</span>
1624             <span class="keyword">for</span> i = 1:length(direccion)
1625                 <span class="keyword">if</span> direccion(i) == 1
1626                     dirk = i;
1627                     <span class="keyword">break</span>;
1628                 <span class="keyword">end</span>
1629             <span class="keyword">end</span> <span class="comment">% for i</span>
1630             
1631             dirn = <span class="string">''</span>;
1632             diru = <span class="string">''</span>;
1633             <span class="keyword">if</span> dirk == 1
1634                 dirn = <span class="string">'Axial'</span>;
1635                 diru = r.unidadC;
1636             <span class="keyword">elseif</span> dirk == 2
1637                 dirn = <span class="string">'Corte'</span>;
1638                 diru = r.unidadC;
1639             <span class="keyword">elseif</span> dirk == 3
1640                 dirn = <span class="string">'Giro'</span>;
1641                 diru = r.unidadM;
1642             <span class="keyword">end</span>
1643             
1644             <span class="comment">% Posicion del maximo</span>
1645             maxp = 1;
1646             maxv = 0;
1647             
1648             <span class="comment">% Por cada tiempo obtiene la fuerza resistente local</span>
1649             <span class="keyword">for</span> i = 1:length(t)
1650                 
1651                 <span class="comment">% Define los desplazamientos del nodo</span>
1652                 <span class="keyword">for</span> j = 1:length(nodos)
1653                     k = nodos{j}.obtenerGDLIDCondensado();
1654                     unodo = zeros(1, ngdl);
1655                     <span class="keyword">for</span> n = 1:ngdl <span class="comment">% Recorre cada desplazamiento de ese grado para el tiempo i</span>
1656                         <span class="keyword">if</span> k(n) &gt; 0
1657                             unodo(n) = u_c(k(n), i);
1658                         <span class="keyword">end</span>
1659                     <span class="keyword">end</span> <span class="comment">% for n</span>
1660                     nodos{j}.definirDesplazamientos(unodo);
1661                 <span class="keyword">end</span> <span class="comment">% for j</span>
1662                 
1663                 <span class="comment">% Obtiene la fuerza resistente</span>
1664                 fr = elemento.obtenerFuerzaResistenteCoordLocal();
1665                 <span class="keyword">for</span> j = 1:length(fr) / 2
1666                     esf(j, i) = fr(j);
1667                 <span class="keyword">end</span> <span class="comment">% for j</span>
1668                 
1669                 <span class="comment">% Actualiza el maximo</span>
1670                 <span class="keyword">if</span> abs(esf(dirk, i)) &gt; maxv
1671                     maxv = abs(esf(dirk, i));
1672                     maxp = i;
1673                 <span class="keyword">end</span>
1674                 
1675                 <span class="keyword">for</span> j = 1:length(esfmax)
1676                     <span class="keyword">if</span> abs(esf(j, i)) &gt; abs(esfmax(j))
1677                         esfmax(j) = esf(j, i);
1678                     <span class="keyword">end</span>
1679                 <span class="keyword">end</span> <span class="comment">% for j</span>
1680                 
1681             <span class="keyword">end</span> <span class="comment">% for i</span>
1682             
1683             <span class="comment">% Resetea los desplazamientos originales</span>
1684             <span class="keyword">for</span> i = 1:length(nodos)
1685                 nodos{i}.definirDesplazamientos(despl{i});
1686             <span class="keyword">end</span> <span class="comment">% for i</span>
1687             
1688             <span class="comment">% Crea el grafico</span>
1689             fig_title = sprintf(<span class="string">'%s %s - Elemento %s - Direccion %s'</span>, <span class="keyword">...</span>
1690                 ctitle, carga.obtenerEtiqueta(), elemento.obtenerEtiqueta(), dirn);
1691             plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1692             movegui(plt, <span class="string">'center'</span>);
1693             
1694             <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, esf(dirk, :), <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, 1);
1695             ylabel(sprintf(<span class="string">'Esfuerzo (%s)'</span>, diru));
1696             xlabel(<span class="string">'t (s)'</span>);
1697             hold on;
1698             
1699             <span class="comment">% Grafica el maximo</span>
1700             <a href="../../tefame/lib/drawVyLine.html" class="code" title="function obj = drawVyLine(y, style, lw)">drawVyLine</a>(esf(dirk, maxp), <span class="string">'k--'</span>, 1.25);
1701             xlim(tlim);
1702             grid on;
1703             title(fig_title);
1704             
1705             legend({sprintf(<span class="string">'Esfuerzo elemento: %s'</span>, carga.obtenerEtiqueta()), <span class="keyword">...</span>
1706                 sprintf(<span class="string">'Esfuerzo maximo: %.2f (%s)'</span>, esf(dirk, maxp), diru)}, <span class="keyword">...</span>
1707                 <span class="string">'location'</span>, <span class="string">'southeast'</span>);
1708             
1709             <span class="comment">% Finaliza proceso</span>
1710             fprintf(<span class="string">'\tProceso finalizado en %.2f segundos\n'</span>, cputime-tinicial);
1711             <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
1712             
1713         <span class="keyword">end</span> <span class="comment">% plotEsfuerzosElemento function</span>
1714         
1715         <a name="_sub20" href="#_subfunctions" class="code">function plotTrayectoriaNodo(analisisObj, carga, nodo, direccion, varargin)</a>
1716             <span class="comment">% plotTrayectoriaNodo: Grafica la trayectoria de un nodo</span>
1717             <span class="comment">% (desplazamiento, velocidad y aceleracion) para todo el tiempo</span>
1718             <span class="comment">%</span>
1719             <span class="comment">% plotTrayectoriaNodo(analisisObj,carga,nodo,direccion,varargin)</span>
1720             <span class="comment">%</span>
1721             <span class="comment">% Parametros opcionales:</span>
1722             <span class="comment">%   'tlim'      Tiempo de analisis limite</span>
1723             <span class="comment">%   'unidadC'   Unidad carga</span>
1724             <span class="comment">%   'unidadL'   Unidad longitud</span>
1725             
1726             <span class="comment">% Inicia proceso</span>
1727             tinicial = cputime;
1728             
1729             <span class="comment">% Verifica que la direccion sea correcta</span>
1730             <span class="keyword">if</span> sum(direccion) ~= 1
1731                 error(<span class="string">'Direccion invalida'</span>);
1732             <span class="keyword">end</span>
1733             <span class="keyword">if</span> ~<a href="../../tefame/utils/verificarVectorDireccion.html" class="code" title="function y = verificarVectorDireccion(vec, ndg)">verificarVectorDireccion</a>(direccion, nodo.obtenerNumeroGDL())
1734                 error(<span class="string">'Vector direccion mal definido'</span>);
1735             <span class="keyword">end</span>
1736             
1737             <span class="comment">% Recorre parametros opcionales</span>
1738             p = inputParser;
1739             p.KeepUnmatched = true;
1740             addOptional(p, <span class="string">'tlim'</span>, 0);
1741             addOptional(p, <span class="string">'unidadC'</span>, <span class="string">'tonf'</span>);
1742             addOptional(p, <span class="string">'unidadL'</span>, <span class="string">'m'</span>);
1743             parse(p, varargin{:});
1744             r = p.Results;
1745             
1746             <span class="comment">% Obtiene las variables</span>
1747             tlim = r.tlim;
1748             
1749             <span class="comment">% Obtiene resultados de la carga</span>
1750             p_c = carga.obtenerCarga();
1751             u_c = carga.obtenerDesplazamiento();
1752             v_c = carga.obtenerVelocidad();
1753             a_c = carga.obtenerAceleracion();
1754             
1755             <span class="comment">% Verifica que la carga se haya calculado</span>
1756             <span class="keyword">if</span> ~(isa(carga, <span class="string">'CargaDinamica'</span>) || isa(carga, <span class="string">'CombinacionCargas'</span>))
1757                 error(<span class="string">'Solo se pueden graficar cargas dinamicas o combinaciones de cargas'</span>);
1758             <span class="keyword">end</span>
1759             <span class="keyword">if</span> isempty(a_c)
1760                 error(<span class="string">'La carga %s no se ha calculado'</span>, carga.obtenerEtiqueta());
1761             <span class="keyword">end</span>
1762             
1763             fprintf(<span class="string">'Calculando trayectoria nodo:\n'</span>);
1764             fprintf(<span class="string">'\tNodo %s\n'</span>, nodo.obtenerEtiqueta());
1765             ctitle = analisisObj.imprimirPropiedadesAnalisisCarga(carga);
1766             
1767             <span class="comment">% Elige al nodo</span>
1768             [r, ~] = size(a_c);
1769             ngd = nodo.obtenerGDLIDCondensado();
1770             ng = 0; <span class="comment">% Numero grado analisis</span>
1771             nd = 0; <span class="comment">% Numero direccion analisis</span>
1772             <span class="keyword">for</span> i = 1:length(direccion)
1773                 <span class="keyword">if</span> direccion(i) == 1
1774                     ng = ngd(i);
1775                     nd = i;
1776                 <span class="keyword">end</span>
1777             <span class="keyword">end</span> <span class="comment">% for i</span>
1778             <span class="keyword">if</span> ng == 0
1779                 error(<span class="string">'No se ha obtenido el GDLID del nodo, es posible que corresponda a un apoyo o bien que el grado de libertad fue condensado'</span>);
1780             <span class="keyword">end</span>
1781             <span class="keyword">if</span> ng &gt; r
1782                 error(<span class="string">'El GDLID excede al soporte del sistema'</span>);
1783             <span class="keyword">end</span>
1784             
1785             <span class="comment">% Genera el vector de tiempo</span>
1786             t = carga.obtenerVectorTiempo(); <span class="comment">% Vector de tiempo</span>
1787             <span class="keyword">if</span> tlim == 0
1788                 tlim = [min(t), max(t)];
1789             <span class="keyword">else</span>
1790                 tlim = [max(min(tlim), min(t)), min(max(tlim), max(t))];
1791             <span class="keyword">end</span>
1792             
1793             <span class="comment">% Crea el grafico</span>
1794             fig_title = sprintf(<span class="string">'%s %s - Nodo %s - GDLID condensado %d - Direccion %d'</span>, <span class="keyword">...</span>
1795                 ctitle, carga.obtenerEtiqueta(), nodo.obtenerEtiqueta(), ng, nd);
1796             plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1797             movegui(plt, <span class="string">'center'</span>);
1798             
1799             subplot(4, 1, 1);
1800             <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, p_c(ng, :), <span class="string">'k-'</span>, <span class="string">'LineWidth'</span>, 1);
1801             ylabel(sprintf(<span class="string">'carga (%s)'</span>, r.unidadC));
1802             xlabel(<span class="string">'t (s)'</span>);
1803             xlim(tlim);
1804             grid on;
1805             title(fig_title);
1806             
1807             subplot(4, 1, 2);
1808             <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, u_c(ng, :), <span class="string">'k-'</span>, <span class="string">'LineWidth'</span>, 1);
1809             title(<span class="string">'Desplazamiento'</span>);
1810             ylabel(sprintf(<span class="string">'u (%s)'</span>, r.unidadL));
1811             xlabel(<span class="string">'t (s)'</span>);
1812             xlim(tlim);
1813             grid on;
1814             
1815             subplot(4, 1, 3);
1816             <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, v_c(ng, :), <span class="string">'k-'</span>, <span class="string">'LineWidth'</span>, 1);
1817             title(<span class="string">'Velocidad'</span>);
1818             ylabel(sprintf(<span class="string">'v (%s/s)'</span>, r.unidadL));
1819             xlabel(<span class="string">'t (s)'</span>);
1820             xlim(tlim);
1821             grid on;
1822             
1823             subplot(4, 1, 4);
1824             <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, a_c(ng, :), <span class="string">'k-'</span>, <span class="string">'LineWidth'</span>, 1);
1825             title(<span class="string">'Aceleracion'</span>);
1826             ylabel(sprintf(<span class="string">'a (%s/s^s)'</span>, r.unidadL));
1827             xlabel(<span class="string">'t (s)'</span>);
1828             xlim(tlim);
1829             grid on;
1830             
1831             <span class="comment">% Finaliza proceso</span>
1832             fprintf(<span class="string">'\tProceso finalizado en %.2f segundos\n'</span>, cputime-tinicial);
1833             <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
1834             
1835         <span class="keyword">end</span> <span class="comment">% plotTrayectoriaNodo function</span>
1836         
1837         <a name="_sub21" href="#_subfunctions" class="code">function activarCargaAnimacion(analisisObj)</a>
1838             <span class="comment">% activarCargaAnimacion: Carga la animacion  una vez calculada</span>
1839             <span class="comment">%</span>
1840             <span class="comment">% activarCargaAnimacion(analisisObj)</span>
1841             
1842             analisisObj.cargarAnimacion = true;
1843             
1844         <span class="keyword">end</span> <span class="comment">% activarCargaAnimacion funcion</span>
1845         
1846         <a name="_sub22" href="#_subfunctions" class="code">function desactivarCargaAnimacion(analisisObj)</a>
1847             <span class="comment">% desactivarCargaAnimacion: Desactiva la animacion una vez calculada</span>
1848             <span class="comment">%</span>
1849             <span class="comment">% desactivarCargaAnimacion(analisisObj)</span>
1850             
1851             analisisObj.cargarAnimacion = false;
1852             
1853         <span class="keyword">end</span> <span class="comment">% desactivarCargaAnimacion funcion</span>
1854         
1855         <a name="_sub23" href="#_subfunctions" class="code">function activarPlotDeformadaInicial(analisisObj)</a>
1856             <span class="comment">% activarPlotDeformadaInicial: Activa el grafico de la deformada inicial</span>
1857             <span class="comment">%</span>
1858             <span class="comment">% activarPlotDeformadaInicial(analisisObj)</span>
1859             
1860             analisisObj.mostrarDeformada = true;
1861             
1862         <span class="keyword">end</span> <span class="comment">% activarPlotDeformadaInicial function</span>
1863         
1864         <a name="_sub24" href="#_subfunctions" class="code">function desactivarPlotDeformadaInicial(analisisObj)</a>
1865             <span class="comment">% desactivarPlotDeformadaInicial: Desactiva el grafico de la deformada inicial</span>
1866             <span class="comment">%</span>
1867             <span class="comment">% desactivarPlotDeformadaInicial(analisisObj)</span>
1868             
1869             analisisObj.mostrarDeformada = false;
1870             
1871         <span class="keyword">end</span> <span class="comment">% desactivarPlotDeformadaInicial function</span>
1872         
1873         <a name="_sub25" href="#_subfunctions" class="code">function disp(analisisObj)</a>
1874             <span class="comment">% disp: es un metodo de la clase ModalEspectral que se usa para imprimir en</span>
1875             <span class="comment">% command Window la informacion del analisis espectral realizado</span>
1876             <span class="comment">%</span>
1877             <span class="comment">% disp(analisisObj)</span>
1878             <span class="comment">%</span>
1879             <span class="comment">% Imprime la informacion guardada en el ModalEspectral (analisisObj) en</span>
1880             <span class="comment">% pantalla</span>
1881             
1882             <span class="keyword">if</span> ~analisisObj.analisisFinalizado
1883                 error(<span class="string">'El analisis modal aun no ha sido calculado'</span>);
1884             <span class="keyword">end</span>
1885             
1886             fprintf(<span class="string">'Propiedades analisis modal espectral:\n'</span>);
1887             
1888             <span class="comment">% Muestra los grados de libertad</span>
1889             fprintf(<span class="string">'\tNumero de grados de libertad: %d\n'</span>, <span class="keyword">...</span>
1890                 analisisObj.numeroGDL-analisisObj.gdlCond);
1891             fprintf(<span class="string">'\tNumero de grados condensados: %d\n'</span>, analisisObj.gdlCond);
1892             fprintf(<span class="string">'\tNumero de direcciones por grado: %d\n'</span>, analisisObj.numDG);
1893             fprintf(<span class="string">'\tNumero de modos en el analisis: %d\n'</span>, analisisObj.numModos);
1894             
1895             <span class="comment">% Propiedades de las matrices</span>
1896             detKt = det(analisisObj.Kt);
1897             detMt = det(analisisObj.Mt);
1898             <span class="keyword">if</span> detKt ~= Inf
1899                 fprintf(<span class="string">'\tMatriz de rigidez:\n'</span>);
1900                 fprintf(<span class="string">'\t\tDeterminante: %f\n'</span>, detKt);
1901             <span class="keyword">end</span>
1902             <span class="keyword">if</span> abs(detMt) &gt;= 1e-20
1903                 fprintf(<span class="string">'\tMatriz de Masa:\n'</span>);
1904                 fprintf(<span class="string">'\t\tDeterminante: %f\n'</span>, detMt);
1905             <span class="keyword">end</span>
1906             fprintf(<span class="string">'\tMasa total de la estructura: %.3f\n'</span>, analisisObj.Mtotal);
1907             
1908             fprintf(<span class="string">'\tPeriodos y participacion modal:\n'</span>);
1909             <span class="keyword">if</span> analisisObj.numDG == 2
1910                 fprintf(<span class="string">'\t\tN\t|\tT (s)\t| w (rad/s)\t|\tU1\t\t|\tU2\t\t|\tSum U1\t|\tSum U2\t|\n'</span>);
1911                 fprintf(<span class="string">'\t\t-----------------------------------------------------------------------------\n'</span>);
1912             <span class="keyword">elseif</span> analisisObj.numDG == 3
1913                 fprintf(<span class="string">'\t\tN\t|\tT (s)\t| w (rad/s)\t|\tU1\t\t|\tU2\t\t|\tU3\t\t|\tSum U1\t|\tSum U2\t|\tSum U3\t|\n'</span>);
1914                 fprintf(<span class="string">'\t\t----------------------------------------------------------------------------------------------------\n'</span>);
1915             <span class="keyword">end</span>
1916             
1917             <span class="keyword">for</span> i = 1:analisisObj.numModos
1918                 <span class="keyword">if</span> analisisObj.numDG == 2
1919                     fprintf(<span class="string">'\t\t%d\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\n'</span>, i, analisisObj.Tn(i), <span class="keyword">...</span>
1920                         analisisObj.wn(i), analisisObj.Mmeff(i, 1), analisisObj.Mmeff(i, 2), <span class="keyword">...</span>
1921                         analisisObj.Mmeffacum(i, 1), analisisObj.Mmeffacum(i, 2));
1922                 <span class="keyword">elseif</span> analisisObj.numDG == 3
1923                     fprintf(<span class="string">'\t\t%d\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\n'</span>, i, analisisObj.Tn(i), <span class="keyword">...</span>
1924                         analisisObj.wn(i), analisisObj.Mmeff(i, 1), analisisObj.Mmeff(i, 2), analisisObj.Mmeff(i, 3), <span class="keyword">...</span>
1925                         analisisObj.Mmeffacum(i, 1), analisisObj.Mmeffacum(i, 2), analisisObj.Mmeffacum(i, 3));
1926                 <span class="keyword">end</span>
1927                 fprintf(<span class="string">'\n'</span>);
1928             <span class="keyword">end</span> <span class="comment">% for i</span>
1929             
1930             <span class="comment">% Busca los periodos para los cuales se logra el 90%</span>
1931             mt90p = zeros(analisisObj.numDG, 1);
1932             <span class="keyword">for</span> i = 1:analisisObj.numDG
1933                 fprintf(<span class="string">'\t\tN periodo en U%d para el 90%% de la masa: '</span>, i);
1934                 <span class="keyword">for</span> j = 1:analisisObj.numModos
1935                     <span class="keyword">if</span> analisisObj.Mmeffacum(j, i) &gt;= 0.90
1936                         mt90p(i) = j;
1937                         <span class="keyword">break</span>;
1938                     <span class="keyword">end</span>
1939                 <span class="keyword">end</span> <span class="comment">% for j</span>
1940                 <span class="keyword">if</span> mt90p(i) &gt; 0
1941                     fprintf(<span class="string">'%d\n'</span>, mt90p(i));
1942                 <span class="keyword">else</span>
1943                     fprintf(<span class="string">'Incrementar modos de analisis\n'</span>);
1944                 <span class="keyword">end</span>
1945             <span class="keyword">end</span> <span class="comment">% for i</span>
1946             
1947             <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
1948             
1949         <span class="keyword">end</span> <span class="comment">% disp function</span>
1950         
1951         <a name="_sub26" href="#_subfunctions" class="code">function c = obtenerCargaEstatica(analisisObj, varargin)</a>
1952             <span class="comment">% obtenerCargaEstatica: Obtiene la carga estatica del modelo</span>
1953             <span class="comment">% como una carga dinamica para ser incluida en las</span>
1954             <span class="comment">% combinaciones de cargas</span>
1955             <span class="comment">%</span>
1956             <span class="comment">% c = obtenerCargaEstatica(analisisObj,varargin)</span>
1957             <span class="comment">%</span>
1958             <span class="comment">% Parametros opcionales:</span>
1959             <span class="comment">%   'etiqueta'      Nombre de la carga</span>
1960             
1961             <span class="comment">% Recorre parametros opcionales</span>
1962             p = inputParser;
1963             p.KeepUnmatched = true;
1964             addOptional(p, <span class="string">'etiqueta'</span>, <span class="string">'Carga Estatica'</span>);
1965             parse(p, varargin{:});
1966             r = p.Results;
1967             
1968             c = <a href="../../tefame/modelo/cargas/CargaDinamica.html" class="code" title="">CargaDinamica</a>(r.etiqueta);
1969             c.dt = 1;
1970             c.tAnalisis = 1;
1971             
1972             <span class="comment">% Crea vector de velocidad y aceleracion ceros</span>
1973             v = zeros(length(analisisObj.u), 1);
1974             a = zeros(length(analisisObj.u), 1);
1975             
1976             c.guardarCarga(analisisObj.F);
1977             c.guardarDesplazamiento(analisisObj.u);
1978             c.guardarVelocidad(v);
1979             c.guardarAceleracion(a);
1980             
1981         <span class="keyword">end</span> <span class="comment">% obtenerCargaEstatica function</span>
1982         
1983     <span class="keyword">end</span> <span class="comment">% methods(public) ModalEspectral</span>
1984     
1985     methods(Access = private)
1986         
1987         <a name="_sub27" href="#_subfunctions" class="code">function definirNumeracionGDL(analisisObj)</a>
1988             <span class="comment">% definirNumeracionGDL: es un metodo de la clase ModalEspectral que</span>
1989             <span class="comment">% se usa para definir como se enumeran los GDL en el modelo</span>
1990             <span class="comment">%</span>
1991             <span class="comment">% definirNumeracionGDL(analisisObj)</span>
1992             <span class="comment">%</span>
1993             <span class="comment">% Define y asigna la enumeracion de los GDL en el modelo</span>
1994             
1995             fprintf(<span class="string">'\tDefiniendo numeracion GDL\n'</span>);
1996             
1997             <span class="comment">% Primero se aplican las restricciones al modelo</span>
1998             analisisObj.modeloObj.aplicarRestricciones();
1999             
2000             <span class="comment">% Extraemos los nodos para que sean enumerados</span>
2001             nodoObjetos = analisisObj.modeloObj.obtenerNodos();
2002             numeroNodos = length(nodoObjetos);
2003             
2004             <span class="comment">% Inicializamos en cero el contador de GDL</span>
2005             contadorGDL = 0;
2006             <span class="keyword">for</span> i = 1:numeroNodos
2007                 
2008                 gdlidNodo = nodoObjetos{i}.obtenerGDLID;
2009                 
2010                 <span class="comment">% Si no es reaccion entonces se agrega como GDL</span>
2011                 <span class="keyword">for</span> j = 1:length(gdlidNodo)
2012                     <span class="keyword">if</span> (gdlidNodo(j) == -1)
2013                         contadorGDL = contadorGDL + 1;
2014                         gdlidNodo(j) = contadorGDL;
2015                     <span class="keyword">end</span> <span class="comment">% if</span>
2016                 <span class="keyword">end</span> <span class="comment">% for j</span>
2017                 nodoObjetos{i}.definirGDLID(gdlidNodo);
2018                 
2019             <span class="keyword">end</span> <span class="comment">% for i</span>
2020             
2021             <span class="comment">% Guardamos el numero de GDL, es decir el numero de ecuaciones</span>
2022             <span class="comment">% del sistema</span>
2023             analisisObj.numeroGDL = contadorGDL;
2024             
2025             <span class="comment">% Extraemos los Elementos del modelo</span>
2026             elementoObjetos = analisisObj.modeloObj.obtenerElementos();
2027             disipadorObjetos = analisisObj.modeloObj.obtenerDisipadores();
2028             numeroElementos = length(elementoObjetos);
2029             numeroDisipadores = length(disipadorObjetos);
2030             <span class="comment">% Definimos los GDLID en los elementos para poder formar la matriz de rigidez</span>
2031             <span class="keyword">for</span> i = 1:numeroElementos
2032                 elementoObjetos{i}.definirGDLID();
2033             <span class="keyword">end</span> <span class="comment">% for i</span>
2034             
2035             <span class="keyword">for</span> i = 1:numeroDisipadores
2036                 disipadorObjetos{i}.definirGDLID();
2037             <span class="keyword">end</span> <span class="comment">% for i</span>
2038             
2039         <span class="keyword">end</span> <span class="comment">% definirNumeracionGDL function</span>
2040         
2041         <a name="_sub28" href="#_subfunctions" class="code">function calcularModalEspectral(analisisObj, nModos, betacR, modocR, </a><span class="keyword">...</span>
2042                 direcR, betacP, maxcond, valvecAlgoritmo, valvecTolerancia, <span class="keyword">...</span>
2043                 muIterDesplazamiento)
2044             <span class="comment">% calcularModalEspectral: Calcula el metodo modal espectral</span>
2045             <span class="comment">%</span>
2046             <span class="comment">% calcularModalEspectral(analisisObj,nModos,betacR,modocR,direcR,</span>
2047             <span class="comment">%   betacP,maxcond,valvecAlgoritmo,valvecTolerancia,muIterDesplazamiento)</span>
2048             
2049             <span class="comment">% Calcula tiempo inicio</span>
2050             fprintf(<span class="string">'\tCalculando metodo modal espectral:\n'</span>);
2051             tInicio = cputime;
2052             
2053             <span class="comment">% Obtiene matriz de masa</span>
2054             diagMt = diag(analisisObj.Mt);
2055             analisisObj.Mtotal = sum(diagMt) / 2;
2056             
2057             <span class="comment">% Obtiene los grados de libertad</span>
2058             ngdl = length(analisisObj.Mt); <span class="comment">% Numero de grados de libertad</span>
2059             ndg = analisisObj.modeloObj.obtenerNumerosGDL(); <span class="comment">% Grados de libertad por nodo</span>
2060             
2061             <span class="comment">% ---------------- CONDENSACION ESTATICA DE GUYAN ---------------</span>
2062             <span class="comment">% Primero se genera matriz para reordenar elementos (rot)</span>
2063             vz = []; <span class="comment">% Vector que identifica indices a condensar</span>
2064             j = 1;
2065             <span class="keyword">if</span> maxcond &gt;= 0
2066                 <span class="keyword">for</span> i = 1:length(diagMt)
2067                     <span class="keyword">if</span> diagMt(i) &lt;= maxcond
2068                         vz(j) = i; <span class="comment">%#ok&lt;AGROW&gt;</span>
2069                         j = j + 1;
2070                     <span class="keyword">end</span>
2071                 <span class="keyword">end</span> <span class="comment">% for i</span>
2072             <span class="keyword">end</span>
2073             
2074             <span class="comment">% Si condensa grados</span>
2075             analisisObj.gdlCond = length(vz);
2076             realizaCond = false;
2077             <span class="keyword">if</span> analisisObj.gdlCond &gt; 0
2078                 
2079                 realizaCond = true;
2080                 <span class="comment">% Chequea cuantos grados quedan</span>
2081                 nndg = ndg;
2082                 <span class="keyword">if</span> ndg &gt; 2
2083                     <span class="keyword">for</span> i = 2:ndg
2084                         <span class="comment">% Si todos los grados se dividen por 3, entonces se borra</span>
2085                         <span class="comment">% el tercer grado de libertad (giro por ejemplo)</span>
2086                         <span class="keyword">if</span> <a href="../../tefame/lib/allDivMod.html" class="code" title="function t = allDivMod(y, r)">allDivMod</a>(vz, i)
2087                             nndg = nndg - 1;
2088                         <span class="keyword">end</span>
2089                     <span class="keyword">end</span> <span class="comment">% for i</span>
2090                 <span class="keyword">end</span>
2091                 ndg = nndg;
2092                 
2093                 lpasivos = length(vz);
2094                 lactivos = length(diagMt) - lpasivos;
2095                 rot = zeros(length(diagMt), length(diagMt));
2096                 aux0 = 1;
2097                 aux1 = 1;
2098                 aux2 = length(diagMt) - lpasivos + 1;
2099                 <span class="keyword">for</span> i = 1:1:length(rot)
2100                     <span class="keyword">if</span> aux0 &lt;= length(vz) &amp;&amp; i == vz(aux0)
2101                         rot(i, aux2) = 1;
2102                         aux2 = aux2 + 1;
2103                         aux0 = aux0 + 1;
2104                     <span class="keyword">else</span>
2105                         rot(i, aux1) = 1;
2106                         aux1 = aux1 + 1;
2107                     <span class="keyword">end</span>
2108                 <span class="keyword">end</span> <span class="comment">% for i</span>
2109                 
2110                 <span class="comment">% Se realiza rotacion de matriz de rigidez</span>
2111                 Krot = rot' * analisisObj.Kt * rot;
2112                 
2113                 <span class="comment">% Se determina matriz de rigidez condensada (Keq)</span>
2114                 Kaa = Krot(1:lactivos, 1:lactivos);
2115                 Kap = Krot(1:lactivos, lactivos+1:end);
2116                 Kpa = Krot(lactivos+1:<span class="keyword">end</span>, 1:lactivos);
2117                 Kpp = Krot(lactivos+1:<span class="keyword">end</span>, lactivos+1:end);
2118                 Keq = Kaa - Kap * Kpp^(-1) * Kpa;
2119                 
2120                 <span class="comment">% Generacion de matriz T de condensacion</span>
2121                 If = size(Kaa, 1);
2122                 T1 = eye(If);
2123                 T2 = -(Kpp)^(-1) * (Kpa);
2124                 T = vertcat(T1, T2);
2125                 
2126                 <span class="comment">% Se determina matriz de masa condensada (Meq)</span>
2127                 Mrot = rot' * analisisObj.Mt * rot;
2128                 Meq = T' * Mrot * T;
2129                 
2130                 <span class="comment">% Condensa la fuerza estatica</span>
2131                 analisisObj.F = rot' * analisisObj.F;
2132                 analisisObj.F = T' * analisisObj.F;
2133                 
2134                 <span class="comment">% Condensa los desplazamientos estaticos</span>
2135                 analisisObj.u = rot' * analisisObj.u;
2136                 analisisObj.u = T' * analisisObj.u;
2137                 
2138                 <span class="comment">% Actualiza los grados</span>
2139                 cngdl = length(Meq);
2140                 <span class="keyword">if</span> cngdl &lt; ngdl
2141                     fprintf(<span class="string">'\t\tSe han condensado %d grados de libertad\n'</span>, ngdl-cngdl);
2142                     ngdl = cngdl;
2143                 <span class="keyword">end</span>
2144                 
2145                 <span class="comment">% Actualiza los nodos</span>
2146                 nodos = analisisObj.modeloObj.obtenerNodos();
2147                 nnodos = length(nodos);
2148                 <span class="keyword">for</span> i = 1:nnodos
2149                     gdl = nodos{i}.obtenerGDLID();
2150                     gdlaux = gdl;
2151                     <span class="keyword">for</span> j = 1:length(gdl)
2152                         <span class="keyword">for</span> k = 1:length(vz) <span class="comment">% Recorre los grados condensados</span>
2153                             <span class="keyword">if</span> vz(k) == gdl(j)
2154                                 gdlaux(j) = 0; <span class="comment">% gdl condensado</span>
2155                             <span class="keyword">elseif</span> vz(k) &lt; gdl(j)
2156                                 gdlaux(j) = gdlaux(j) - 1;
2157                             <span class="keyword">else</span>
2158                                 gdlaux(j) = gdlaux(j);
2159                             <span class="keyword">end</span>
2160                         <span class="keyword">end</span> <span class="comment">% for k</span>
2161                     <span class="keyword">end</span> <span class="comment">% for j</span>
2162                     nodos{i}.definirGDLIDCondensado(gdlaux);
2163                 <span class="keyword">end</span> <span class="comment">% for i</span>
2164                 
2165                 MtotalRed = sum(diag(Meq)) / 2;
2166                 fprintf(<span class="string">'\t\tTras la condensacion la masa se redujo en %.2f (%.2f%%)\n'</span>, <span class="keyword">...</span>
2167                     analisisObj.Mtotal-MtotalRed, 100*(analisisObj.Mtotal - MtotalRed)/analisisObj.Mtotal);
2168                 
2169             <span class="keyword">else</span> <span class="comment">% No condensa grados</span>
2170                 
2171                 Meq = analisisObj.Mt;
2172                 Keq = analisisObj.Kt;
2173                 fprintf(<span class="string">'\t\tNo se han condensado grados de libertad\n'</span>);
2174                 
2175             <span class="keyword">end</span>
2176             
2177             <span class="comment">% Una vez pasado este punto no deberian haber masas nulas o</span>
2178             <span class="comment">% incorrectas</span>
2179             <span class="keyword">for</span> i = 1:ngdl
2180                 <span class="keyword">if</span> Meq(i, i) &lt;= 0
2181                     error(<span class="string">'La matriz de masa esta mal definida, M(%d,%d)&lt;=0'</span>, i, i);
2182                 <span class="keyword">end</span>
2183             <span class="keyword">end</span> <span class="comment">% for i</span>
2184             
2185             fprintf(<span class="string">'\t\tGrados de libertad totales: %d\n'</span>, ngdl);
2186             fprintf(<span class="string">'\t\tNumero de direcciones de analisis: %d\n'</span>, ndg);
2187             nModos = min(nModos, ngdl);
2188             
2189             <span class="comment">%------------- CALCULO VALORES Y VECTORES PROPIOS ---------------</span>
2190             eigCalcT = cputime;
2191             
2192             <span class="keyword">if</span> strcmp(valvecAlgoritmo, <span class="string">'eigs'</span>)
2193                 fprintf(<span class="string">'\t\tCalculo valores y vectores propios con metodo eigs\n'</span>);
2194                 [modalPhin, modalWn] = <a href="../../tefame/analisis/eig/calculoEigEigs.html" class="code" title="function [w, v] = calculoEigEigs(M, K, nModos)">calculoEigEigs</a>(Meq, Keq, nModos);
2195             <span class="keyword">elseif</span> strcmp(valvecAlgoritmo, <span class="string">'itDir'</span>)
2196                 fprintf(<span class="string">'\t\tCalculo valores y vectores con algoritmo iteracion directa\n'</span>);
2197                 fprintf(<span class="string">'\t\t\tTolerancia: %.4f\n'</span>, valvecTolerancia);
2198                 [modalPhin, modalWn] = <a href="../../tefame/analisis/eig/calculoEigIterDirecta.html" class="code" title="function [v, w, error] = calculoEigIterDirecta(M, K, tol)">calculoEigIterDirecta</a>(Meq, Keq, valvecTolerancia);
2199                 nModos = length(modalWn);
2200             <span class="keyword">elseif</span> strcmp(valvecAlgoritmo, <span class="string">'matBarr'</span>)
2201                 fprintf(<span class="string">'\t\tCalculo valores y vectores propios con algoritmo matriz de barrido\n'</span>);
2202                 fprintf(<span class="string">'\t\t\tTolerancia: %.4f\n'</span>, valvecTolerancia);
2203                 [modalPhin, modalWn] = <a href="../../tefame/analisis/eig/calculoEigDirectaBarrido.html" class="code" title="function [v, w, error] = calculoEigDirectaBarrido(M, K, nModos, tol)">calculoEigDirectaBarrido</a>(Meq, Keq, nModos, valvecTolerancia);
2204             <span class="comment">% elseif strcmp(valvecAlgoritmo, 'itInv')</span>
2205             <span class="comment">%     fprintf('\t\tCalculo valores y vectores propios con metodo iteracion inversa\n');</span>
2206             <span class="keyword">elseif</span> strcmp(valvecAlgoritmo, <span class="string">'itInvDesp'</span>)
2207                 fprintf(<span class="string">'\t\tCalculo valores y vectores propios con metodo iteracion inversa con desplazamientos\n'</span>);
2208                 fprintf(<span class="string">'\t\t\tTolerancia: %.4f\n'</span>, valvecTolerancia);
2209                 fprintf(<span class="string">'\t\t\tMu: %.4f\n'</span>, muIterDesplazamiento);
2210                 [modalPhin, modalWn] = <a href="../../tefame/analisis/eig/calculoEigIterInvDesplazamiento.html" class="code" title="function [v, w, error] = calculoEigIterInvDesplazamiento(M, K, mu, tol)">calculoEigIterInvDesplazamiento</a>(Meq, Keq, muIterDesplazamiento, valvecTolerancia);
2211                 nModos = length(modalWn);
2212             <span class="keyword">elseif</span> strcmp(valvecAlgoritmo, <span class="string">'itSubesp'</span>)
2213                 fprintf(<span class="string">'\t\tCalculo valores y vectores propios con metodo iteracion del subespacio\n'</span>);
2214                 fprintf(<span class="string">'\t\t\tTolerancia: %.4f\n'</span>, valvecTolerancia);
2215                 [modalPhin, modalWn] = <a href="../../tefame/analisis/eig/calculoEigItSubespacio.html" class="code" title="function [v, w] = calculoEigItSubespacio(M, K, nModos, tol)">calculoEigItSubespacio</a>(Meq, Keq, nModos, valvecTolerancia);                
2216             <span class="keyword">else</span>
2217                 error(<span class="string">'Algoritmo valvec:%s incorrecto, valores posibles: eigvc,itDir,matBarr,itInvDesp,itSubesp'</span>, <span class="keyword">...</span>
2218                     valvecAlgoritmo);
2219             <span class="keyword">end</span>
2220             fprintf(<span class="string">'\t\t\tFinalizado en %.3f segundos\n'</span>, cputime-eigCalcT);
2221             analisisObj.numModos = nModos;
2222             
2223             <span class="comment">% Se recuperan los grados de libertad condensados y se</span>
2224             <span class="comment">% ordenan de acuerdo a la configuracion original</span>
2225             <span class="keyword">if</span> realizaCond
2226                 modalPhinFull = T * modalPhin;
2227                 rot_inv = rot^(-1);
2228                 modalPhinFull = rot_inv' * modalPhinFull;
2229                 analisisObj.condMatT = T;
2230                 analisisObj.condMatRot = rot_inv;
2231             <span class="keyword">else</span>
2232                 modalPhinFull = modalPhin;
2233                 analisisObj.condMatT = eye(length(modalPhin));
2234                 analisisObj.condMatRot = eye(length(modalPhin));
2235             <span class="keyword">end</span>
2236             
2237             <span class="comment">% Calcula las frecuencias del sistema</span>
2238             modalTn = (modalWn.^-1) .* 2 * pi(); <span class="comment">% Calcula los periodos</span>
2239             
2240             <span class="comment">% Calcula las matrices</span>
2241             modalMmt = modalPhin' * Meq * modalPhin;
2242             modalPhin = modalPhin * diag(diag(modalMmt).^-0.5);
2243             modalMm = diag(diag(modalPhin'*Meq*modalPhin));
2244             modalKm = diag(diag(modalPhin'*Keq*modalPhin));
2245             
2246             <span class="comment">% Reordena los periodos</span>
2247             Torder = zeros(nModos, 1);
2248             Tpos = 1;
2249             <span class="keyword">for</span> i = 1:nModos
2250                 maxt = 0; <span class="comment">% Periodo</span>
2251                 maxi = 0; <span class="comment">% Indice</span>
2252                 <span class="keyword">for</span> j = 1:nModos <span class="comment">% Se busca el elemento para etiquetar</span>
2253                     <span class="keyword">if</span> Torder(j) == 0 <span class="comment">% Si aun no se ha etiquetado</span>
2254                         <span class="keyword">if</span> modalTn(j) &gt; maxt
2255                             maxt = modalTn(j);
2256                             maxi = j;
2257                         <span class="keyword">end</span>
2258                     <span class="keyword">end</span>
2259                 <span class="keyword">end</span> <span class="comment">% for j</span>
2260                 Torder(maxi) = Tpos;
2261                 Tpos = Tpos + 1;
2262             <span class="keyword">end</span> <span class="comment">% for i</span>
2263             <span class="comment">% ngdl = length(Meq); % Numero de grados de libertad</span>
2264             
2265             <span class="comment">% Asigna valores</span>
2266             analisisObj.phinExt = modalPhinFull;
2267             analisisObj.Tn = zeros(nModos, 1);
2268             analisisObj.wn = zeros(nModos, 1);
2269             analisisObj.phin = zeros(ngdl, nModos);
2270             analisisObj.Mm = modalMm;
2271             analisisObj.Km = modalKm;
2272             analisisObj.Mteq = Meq;
2273             analisisObj.Kteq = Keq;
2274             <span class="keyword">for</span> i = 1:nModos
2275                 analisisObj.Tn(Torder(i)) = modalTn(i);
2276                 analisisObj.wn(Torder(i)) = modalWn(i);
2277                 analisisObj.phin(:, Torder(i)) = modalPhin(:, i);
2278             <span class="keyword">end</span> <span class="comment">% for i</span>
2279             
2280             <span class="comment">% Crea vector influencia</span>
2281             analisisObj.rm = zeros(ngdl, ndg);
2282             <span class="keyword">for</span> j = 1:ndg
2283                 <span class="keyword">for</span> i = 1:ngdl
2284                     <span class="keyword">if</span> mod(i, ndg) == j || (mod(i, ndg) == 0 &amp;&amp; j == ndg)
2285                         analisisObj.rm(i, j) = 1;
2286                     <span class="keyword">end</span>
2287                 <span class="keyword">end</span> <span class="comment">% for i</span>
2288             <span class="keyword">end</span> <span class="comment">% for j</span>
2289             
2290             <span class="comment">% Realiza el calculo de las participaciones modales</span>
2291             analisisObj.Lm = zeros(nModos, ndg);
2292             analisisObj.Mmeff = zeros(ngdl, ndg);
2293             analisisObj.Mmeffacum = zeros(ngdl, ndg);
2294             Mtotr = zeros(ndg, 1);
2295             
2296             <span class="comment">% Recorre cada grado de libertad (horizontal, vertical, giro)</span>
2297             <span class="keyword">for</span> j = 1:ndg
2298                 Mtotr(j) = sum(Meq*analisisObj.rm(:, j));
2299                 <span class="keyword">for</span> k = 1:nModos
2300                     analisisObj.Lm(k, j) = analisisObj.phin(:, k)' * Meq * analisisObj.rm(:, j);
2301                     analisisObj.Mmeff(k, j) = analisisObj.Lm(k, j).^2 ./ modalMm(k, k);
2302                 <span class="keyword">end</span> <span class="comment">% for k</span>
2303                 
2304                 analisisObj.Mmeff(:, j) = analisisObj.Mmeff(:, j) ./ Mtotr(j);
2305                 analisisObj.Mmeffacum(1, j) = analisisObj.Mmeff(1, j);
2306                 <span class="keyword">for</span> i = 2:nModos
2307                     analisisObj.Mmeffacum(i, j) = analisisObj.Mmeffacum(i-1, j) + analisisObj.Mmeff(i, j);
2308                 <span class="keyword">end</span> <span class="comment">% for i</span>
2309             <span class="keyword">end</span> <span class="comment">% for j</span>
2310             
2311             <span class="comment">% -------- CALCULO DE AMORTIGUAMIENTO DE RAYLEIGH -------------</span>
2312             
2313             <span class="comment">% Se recorren los numero de modos, si alguno es mayor a los</span>
2314             <span class="comment">% modos de analisis se reajusta y lanza warning</span>
2315             <span class="keyword">for</span> i = 1:length(modocR)
2316                 <span class="keyword">if</span> modocR(i) &gt; nModos
2317                     warning(<span class="string">'Modo de Rayleigh %d excede al numero de modos de analisis %d, se ha reajustado este ultimo'</span>, <span class="keyword">...</span>
2318                         modocR(i), nModos);
2319                     modocR(i) = nModos;
2320                 <span class="keyword">end</span>
2321             <span class="keyword">end</span> <span class="comment">% for i</span>
2322             
2323             countcR = [0, 0];
2324             m = 0;
2325             n = 0;
2326             <span class="keyword">for</span> i = 1:min(length(analisisObj.Mmeff), nModos)
2327                 <span class="keyword">if</span> analisisObj.Mmeff(i, 1) &gt; max(analisisObj.Mmeff(i, 2:ndg))
2328                     countcR(1) = countcR(1) + 1;
2329                     <span class="keyword">if</span> direcR(1) == <span class="string">'h'</span> &amp;&amp; modocR(1) == countcR(1)
2330                         m = i;
2331                     <span class="keyword">elseif</span> direcR(2) == <span class="string">'h'</span> &amp;&amp; modocR(2) == countcR(1)
2332                         n = i;
2333                     <span class="keyword">end</span>
2334                 <span class="keyword">elseif</span> analisisObj.Mmeff(i, 2) &gt; <span class="keyword">...</span>
2335                         max(analisisObj.Mmeff(i, 1), analisisObj.Mmeff(i, max(1, ndg)))
2336                     countcR(2) = countcR(2) + 1;
2337                     <span class="keyword">if</span> direcR(1) == <span class="string">'v'</span> &amp;&amp; modocR(1) == countcR(2)
2338                         m = i;
2339                     <span class="keyword">elseif</span> direcR(2) == <span class="string">'h'</span> &amp;&amp; modocR(2) == countcR(2)
2340                         n = i;
2341                     <span class="keyword">end</span>
2342                 <span class="keyword">end</span>
2343             <span class="keyword">end</span> <span class="comment">% for i</span>
2344             
2345             <span class="keyword">if</span> m == 0 || n == 0
2346                 warning(<span class="string">'Se requiere aumentar el numero de modos para determinar matriz de amortiguamiento de Rayleigh'</span>);
2347                 m = 1;
2348                 n = 1;
2349             <span class="keyword">end</span>
2350             w = analisisObj.wn;
2351             a = (2 * w(m) * w(n)) / (w(n)^2 - w(m)^2) .* [w(n), -w(m); <span class="keyword">...</span>
2352                 -1 / w(n), 1 / w(m)] * betacR';
2353             analisisObj.cRayleigh = a(1) .* Meq + a(2) .* Keq;
2354             
2355             <span class="comment">% ------ CALCULO DE AMORTIGUAMIENTO DE WILSON-PENZIEN ----------</span>
2356             <span class="comment">% Se declaran todos los amortiguamientos criticos del sistema,</span>
2357             <span class="comment">% (horizontal, vertical y rotacional)</span>
2358             d = zeros(length(analisisObj.Mmeff), length(analisisObj.Mmeff));
2359             w = analisisObj.wn;
2360             Mn = modalMmt;
2361             analisisObj.cPenzien = 0;
2362             
2363             <span class="keyword">for</span> i = 1:length(Mn)
2364                 <span class="keyword">if</span> analisisObj.Mmeff(i, 1) &gt; max(analisisObj.Mmeff(i, 2:ndg))
2365                     d(i, i) = 2 * betacP(1) * w(i) / Mn(i, i);
2366                 <span class="keyword">elseif</span> analisisObj.Mmeff(i, 2) &gt; <span class="keyword">...</span>
2367                         max(analisisObj.Mmeff(i, 1), analisisObj.Mmeff(i, max(1, ndg)))
2368                     d(i, i) = 2 * betacP(2) * w(i) / Mn(i, i);
2369                 <span class="keyword">else</span>
2370                     d(i, i) = 2 * betacP(3) * w(i) / Mn(i, i);
2371                 <span class="keyword">end</span>
2372                 analisisObj.cPenzien = analisisObj.cPenzien + <span class="keyword">...</span>
2373                     Meq * (d(i, i) * modalPhin(:, i) * modalPhin(:, i)') * Meq;
2374             <span class="keyword">end</span> <span class="comment">% for i</span>
2375             
2376             <span class="comment">% Termina el analisis</span>
2377             analisisObj.analisisFinalizado = true;
2378             analisisObj.numDG = ndg;
2379             analisisObj.numDGReal = analisisObj.modeloObj.obtenerNumerosGDL();
2380             fprintf(<span class="string">'\tSe completo el analisis en %.3f segundos\n'</span>, cputime-tInicio);
2381             
2382         <span class="keyword">end</span> <span class="comment">% calcularModalEspectral function</span>
2383         
2384         <a name="_sub29" href="#_subfunctions" class="code">function ensamblarMatrizRigidez(analisisObj)</a>
2385             <span class="comment">% ensamblarMatrizRigidez: es un metodo de la clase ModalEspectral que se usa para</span>
2386             <span class="comment">% realizar el armado de la matriz de rigidez del modelo analizado</span>
2387             <span class="comment">%</span>
2388             <span class="comment">% ensamblarMatrizRigidez(analisisObj)</span>
2389             <span class="comment">%</span>
2390             <span class="comment">% Ensambla la matriz de rigidez del modelo analizado usando el metodo</span>
2391             <span class="comment">% indicial</span>
2392             
2393             fprintf(<span class="string">'\tEnsamblando matriz de rigidez\n'</span>);
2394             analisisObj.Kt = zeros(analisisObj.numeroGDL, analisisObj.numeroGDL);
2395             
2396             <span class="comment">% Extraemos los Elementos</span>
2397             elementoObjetos = analisisObj.modeloObj.obtenerElementos();
2398             numeroElementos = length(elementoObjetos);
2399             
2400             <span class="comment">% Definimos los GDLID en los elementos</span>
2401             <span class="keyword">for</span> i = 1:numeroElementos
2402                 
2403                 <span class="comment">% Se obienen los gdl del elemento metodo indicial</span>
2404                 gdl = elementoObjetos{i}.obtenerGDLID();
2405                 ngdl = elementoObjetos{i}.obtenerNumeroGDL();
2406                 
2407                 <span class="comment">% Se obtiene la matriz de rigidez global del elemento-i</span>
2408                 k_globl_elem = elementoObjetos{i}.obtenerMatrizRigidezCoordGlobal();
2409                 
2410                 <span class="comment">% Se calcula el metodo indicial</span>
2411                 <span class="keyword">for</span> r = 1:ngdl
2412                     <span class="keyword">for</span> s = 1:ngdl
2413                         i_ = gdl(r);
2414                         j_ = gdl(s);
2415                         
2416                         <span class="comment">% Si corresponden a grados de libertad -&gt; puntos en (i,j)</span>
2417                         <span class="comment">% se suma contribucion metodo indicial</span>
2418                         <span class="keyword">if</span> (i_ ~= 0 &amp;&amp; j_ ~= 0)
2419                             analisisObj.Kt(i_, j_) = analisisObj.Kt(i_, j_) + k_globl_elem(r, s);
2420                         <span class="keyword">end</span>
2421                         
2422                     <span class="keyword">end</span> <span class="comment">% for s</span>
2423                 <span class="keyword">end</span> <span class="comment">% for r</span>
2424                 
2425             <span class="keyword">end</span> <span class="comment">% for i</span>
2426             
2427         <span class="keyword">end</span> <span class="comment">% ensamblarMatrizRigidez function</span>
2428         
2429         <a name="_sub30" href="#_subfunctions" class="code">function ensamblarMatrizMasa(analisisObj)</a>
2430             <span class="comment">% ensamblarMatrizMasa: es un metodo de la clase ModalEspectral que se usa para</span>
2431             <span class="comment">% realizar el armado de la matriz de masa del modelo</span>
2432             <span class="comment">%</span>
2433             <span class="comment">% ensamblarMatrizMasa(analisisObj)</span>
2434             <span class="comment">%</span>
2435             <span class="comment">% Ensambla la matriz de masa del modelo analizado usando el metodo</span>
2436             <span class="comment">% indicial</span>
2437             
2438             fprintf(<span class="string">'\tEnsamblando matriz de masa\n'</span>);
2439             analisisObj.Mt = zeros(analisisObj.numeroGDL, analisisObj.numeroGDL);
2440             
2441             <span class="comment">% Extraemos los Elementos</span>
2442             fprintf(<span class="string">'\t\tAgrega masa de elementos\n'</span>);
2443             elementoObjetos = analisisObj.modeloObj.obtenerElementos();
2444             numeroElementos = length(elementoObjetos);
2445             
2446             <span class="comment">% Definimos los GDLID en los elementos</span>
2447             <span class="keyword">for</span> i = 1:numeroElementos
2448                 
2449                 <span class="comment">% Se obienen los gdl del elemento metodo indicial</span>
2450                 gdl = elementoObjetos{i}.obtenerGDLID();
2451                 ngdl = elementoObjetos{i}.obtenerNumeroGDL();
2452                 
2453                 <span class="comment">% Se obtiene la matriz de masa</span>
2454                 m_elem = elementoObjetos{i}.obtenerVectorMasa();
2455                 
2456                 <span class="comment">% Se calcula el metodo indicial</span>
2457                 <span class="keyword">for</span> r = 1:ngdl
2458                     <span class="keyword">for</span> s = 1:ngdl
2459                         i_ = gdl(r);
2460                         j_ = gdl(s);
2461                         
2462                         <span class="comment">% Si corresponden a grados de libertad -&gt; puntos en (i,j)</span>
2463                         <span class="comment">% se suma contribucion metodo indicial</span>
2464                         <span class="keyword">if</span> (i_ ~= 0 &amp;&amp; j_ ~= 0 &amp;&amp; r == s)
2465                             analisisObj.Mt(i_, j_) = analisisObj.Mt(i_, j_) + m_elem(r);
2466                         <span class="keyword">end</span>
2467                         
2468                     <span class="keyword">end</span> <span class="comment">% for s</span>
2469                 <span class="keyword">end</span> <span class="comment">% for r</span>
2470                 
2471             <span class="keyword">end</span> <span class="comment">% for i</span>
2472             
2473             <span class="comment">% Masa de los elementos</span>
2474             mElementos = sum(diag(analisisObj.Mt)) / 2;
2475             
2476             <span class="comment">% Agrega las cargas</span>
2477             fprintf(<span class="string">'\t\tAgrega masa de cargas\n'</span>);
2478             pat = analisisObj.modeloObj.obtenerPatronesDeCargas();
2479             <span class="keyword">for</span> i = 1:length(pat)
2480                 
2481                 cargas = pat{i}.obtenerCargas();
2482                 <span class="keyword">for</span> j = 1:length(cargas)
2483                     
2484                     <span class="comment">% Si la carga ya sumo masa se bloquea</span>
2485                     <span class="keyword">if</span> ~cargas{j}.cargaSumaMasa()
2486                         <span class="keyword">continue</span>;
2487                     <span class="keyword">end</span>
2488                     
2489                     nodoCarga = cargas{j}.obtenerNodos();
2490                     m = cargas{j}.obtenerMasa();
2491                     
2492                     <span class="comment">% Recorre los nodos</span>
2493                     <span class="keyword">for</span> k = 1:length(nodoCarga)
2494                         
2495                         n = nodoCarga{i}.obtenerGDLID();
2496                         analisisObj.Mt(n(1), n(1)) = analisisObj.Mt(n(1), n(1)) + 0.5 * m;
2497                         analisisObj.Mt(n(2), n(2)) = analisisObj.Mt(n(2), n(2)) + 0.5 * m;
2498                         <span class="keyword">if</span> length(n) == 3
2499                             analisisObj.Mt(n(3), n(3)) = analisisObj.Mt(n(3), n(3)) + 1e-6;
2500                         <span class="keyword">end</span>
2501                         <span class="comment">% u(3) no se agrega dado que es el giro</span>
2502                         
2503                     <span class="keyword">end</span> <span class="comment">% for k</span>
2504                     
2505                     <span class="comment">% Bloquea la suma de masa de esta carga</span>
2506                     cargas{j}.bloquearCargaMasa();
2507                     
2508                 <span class="keyword">end</span> <span class="comment">% for j</span>
2509                 
2510             <span class="keyword">end</span> <span class="comment">% for i</span>
2511             
2512             <span class="comment">% Masa total</span>
2513             mTotal = sum(diag(analisisObj.Mt)) / 2;
2514             
2515             <span class="comment">% Masa de las cargas</span>
2516             mCargas = mTotal - mElementos;
2517             
2518             <span class="comment">% Despliega informacion</span>
2519             fprintf(<span class="string">'\tDistribucion de masa\n'</span>);
2520             fprintf(<span class="string">'\t\tMasa de elementos: %.1f (%.2f%%)\n'</span>, mElementos, <span class="keyword">...</span>
2521                 mElementos/mTotal*100);
2522             fprintf(<span class="string">'\t\tMasa de cargas: %.1f (%.2f%%)\n'</span>, mCargas, <span class="keyword">...</span>
2523                 mCargas/mTotal*100);
2524             fprintf(<span class="string">'\t\tMasa total: %.1f\n'</span>, mTotal);
2525             
2526         <span class="keyword">end</span> <span class="comment">% ensamblarMatrizMasa function</span>
2527         
2528         <a name="_sub31" href="#_subfunctions" class="code">function Cdv = ensamblarMatrizAmortiguamientoDisipadores(analisisObj)</a>
2529             <span class="comment">% ensamblarMatrizRigidez: es un metodo de la clase ModalEspectral</span>
2530             <span class="comment">% que se usa para realizar el armado de la matriz de</span>
2531             <span class="comment">% amortiguamiento de los disipadores del modelo</span>
2532             <span class="comment">%</span>
2533             <span class="comment">% Cdv = ensamblarMatrizAmortiguamientoDisipadores(analisisObj)</span>
2534             <span class="comment">%</span>
2535             <span class="comment">% Ensambla la matriz de rigidez del modelo analizado usando el metodo</span>
2536             <span class="comment">% indicial</span>
2537             
2538             <span class="comment">% fprintf('\tEnsamblando matriz de amortiguamiento disipadores\n');</span>
2539             ndglc = analisisObj.numeroGDL - analisisObj.gdlCond; <span class="comment">% Numero de grados de libertad condensados</span>
2540             Cdv = zeros(ndglc, ndglc);
2541             
2542             <span class="comment">% Extraemos los Elementos</span>
2543             disipadorObjetos = analisisObj.modeloObj.obtenerDisipadores();
2544             numeroDisipadores = length(disipadorObjetos);
2545             
2546             <span class="comment">% Definimos los GDLID en los elementos</span>
2547             <span class="keyword">for</span> i = 1:numeroDisipadores
2548                 
2549                 <span class="comment">% Se obienen los gdl del elemento metodo indicial</span>
2550                 gdl = disipadorObjetos{i}.obtenerGDLIDCondensado();
2551                 ngdl = disipadorObjetos{i}.obtenerNumeroGDL();
2552                 
2553                 <span class="comment">% Se obtiene la matriz de amortiguamiento global del elemento-i</span>
2554                 c_globl_elem = disipadorObjetos{i}.obtenerMatrizAmortiguamientoCoordGlobal();
2555                 
2556                 <span class="comment">% Se calcula el metodo indicial</span>
2557                 <span class="keyword">for</span> r = 1:ngdl
2558                     <span class="keyword">for</span> s = 1:ngdl
2559                         i_ = gdl(r);
2560                         j_ = gdl(s);
2561                         
2562                         <span class="comment">% Si corresponden a grados de libertad -&gt; puntos en (i,j)</span>
2563                         <span class="comment">% se suma contribucion metodo indicial</span>
2564                         <span class="keyword">if</span> (i_ ~= 0 &amp;&amp; j_ ~= 0)
2565                             Cdv(i_, j_) = Cdv(i_, j_) + c_globl_elem(r, s);
2566                         <span class="keyword">end</span>
2567                         
2568                     <span class="keyword">end</span> <span class="comment">% for s</span>
2569                 <span class="keyword">end</span> <span class="comment">% for r</span>
2570                 
2571             <span class="keyword">end</span> <span class="comment">% for i</span>
2572             
2573         <span class="keyword">end</span> <span class="comment">% ensamblarMatrizAmortiguamientoDisipadores function</span>
2574         
2575         <a name="_sub32" href="#_subfunctions" class="code">function Kdv = ensamblarMatrizRigidezDisipadores(analisisObj)</a>
2576             <span class="comment">% ensamblarMatrizRigidezDisipadores: es un metodo de la clase</span>
2577             <span class="comment">% ModalEspectral que se usa para realizar el armado de la matriz</span>
2578             <span class="comment">% de rigidez del modelo analizado</span>
2579             <span class="comment">%</span>
2580             <span class="comment">% Kdv = ensamblarMatrizRigidezDisipadores(analisisObj)</span>
2581             <span class="comment">%</span>
2582             <span class="comment">% Ensambla la matriz de rigidez de los disipadores del modelo</span>
2583             <span class="comment">% analizado usando el metodo indicial</span>
2584             
2585             <span class="comment">% fprintf('\tEnsamblando matriz de rigidez disipadores\n');</span>
2586             ndglc = analisisObj.numeroGDL - analisisObj.gdlCond; <span class="comment">% Numero de grados de libertad condensados</span>
2587             Kdv = zeros(ndglc, ndglc);
2588             
2589             <span class="comment">% Extraemos los elementos</span>
2590             disipadorObj = analisisObj.modeloObj.obtenerDisipadores();
2591             numeroDisipadores = length(disipadorObj);
2592             
2593             <span class="comment">% Definimos los GDLID en los elementos</span>
2594             <span class="keyword">for</span> i = 1:numeroDisipadores
2595                 
2596                 <span class="comment">% Se obienen los gdl del elemento metodo indicial</span>
2597                 gdl = disipadorObj{i}.obtenerGDLIDCondensado();
2598                 ngdl = disipadorObj{i}.obtenerNumeroGDL();
2599                 
2600                 <span class="comment">% Se obtiene la matriz de amortiguamiento global del elemento-i</span>
2601                 k_globl_elem = disipadorObj{i}.obtenerMatrizRigidezCoordGlobal();
2602                 
2603                 <span class="comment">% Se calcula el metodo indicial</span>
2604                 <span class="keyword">for</span> r = 1:ngdl
2605                     <span class="keyword">for</span> s = 1:ngdl
2606                         i_ = gdl(r);
2607                         j_ = gdl(s);
2608                         
2609                         <span class="comment">% Si corresponden a grados de libertad -&gt; puntos en (i,j)</span>
2610                         <span class="comment">% se suma contribucion metodo indicial</span>
2611                         <span class="keyword">if</span> (i_ ~= 0 &amp;&amp; j_ ~= 0)
2612                             Kdv(i_, j_) = Kdv(i_, j_) + k_globl_elem(r, s);
2613                         <span class="keyword">end</span>
2614                         
2615                     <span class="keyword">end</span> <span class="comment">% for s</span>
2616                 <span class="keyword">end</span> <span class="comment">% for r</span>
2617                 
2618             <span class="keyword">end</span> <span class="comment">% for i</span>
2619             
2620         <span class="keyword">end</span> <span class="comment">% ensamblarMatrizAmortiguamientoDisipadores function</span>
2621         
2622         <a name="_sub33" href="#_subfunctions" class="code">function ensamblarVectorFuerzas(analisisObj)</a>
2623             <span class="comment">% ensamblarVectorFuerzas: es un metodo de la clase ModalEspectral que se usa para</span>
2624             <span class="comment">% realizar el armado del vector de fuerzas del modelo analizado</span>
2625             <span class="comment">%</span>
2626             <span class="comment">% ensamblarVectorFuerzas(analisisObj)</span>
2627             <span class="comment">%</span>
2628             <span class="comment">% Ensambla el vector de fuerzas del modelo analizado usando el metodo</span>
2629             <span class="comment">% indicial</span>
2630             
2631             analisisObj.F = zeros(analisisObj.numeroGDL, 1);
2632             
2633             <span class="comment">% En esta funcion se tiene que ensamblar el vector de fuerzas</span>
2634             <span class="comment">% Extraemos los nodos</span>
2635             nodoObjetos = analisisObj.modeloObj.obtenerNodos();
2636             numeroNodos = length(nodoObjetos);
2637             
2638             <span class="comment">% Definimos los GDLID en los nodos</span>
2639             <span class="keyword">for</span> i = 1:numeroNodos
2640                 
2641                 ngdlid = nodoObjetos{i}.obtenerNumeroGDL(); <span class="comment">% Numero grados de libertad del nodo</span>
2642                 gdl = nodoObjetos{i}.obtenerGDLID(); <span class="comment">% Grados de libertad del nodo</span>
2643                 reacc = nodoObjetos{i}.obtenerReacciones(); <span class="comment">% Reacciones del nodo</span>
2644                 
2645                 <span class="comment">% Recorre cada grado de libertad, si no es cero entonces</span>
2646                 <span class="comment">% hay una carga aplicada en ese grado de libertad para</span>
2647                 <span class="comment">% lograr el equilibrio</span>
2648                 <span class="keyword">for</span> j = 1:ngdlid
2649                     <span class="keyword">if</span> (gdl(j) ~= 0)
2650                         analisisObj.F(gdl(j)) = -reacc(j);
2651                     <span class="keyword">end</span>
2652                 <span class="keyword">end</span> <span class="comment">% for j</span>
2653                 
2654             <span class="keyword">end</span> <span class="comment">% for i</span>
2655             
2656         <span class="keyword">end</span> <span class="comment">% ensamblarVectorFuerzas function</span>
2657         
2658         <a name="_sub34" href="#_subfunctions" class="code">function plotAnimado(analisisObj, deformada, modo, factor, phif, limx, limy, limz, </a><span class="keyword">...</span>
2659                 per, cuadro, totCuadros, defElem, defCarga, carga, tcarga, tcargaEq, <span class="keyword">...</span>
2660                 mostrarEstatico, mostrarDisipadores, styleNodoE, sizeNodoE, <span class="keyword">...</span>
2661                 styleNodoD, sizeNodoD, styleElemE, lwElemE, styleElemD, lwElemD, <span class="keyword">...</span>
2662                 styleDisipador, colorDisipador, lwDisipador, unidad, <span class="keyword">...</span>
2663                 angAzh, angPol)
2664             <span class="comment">% plotAnimado: Anima el grafico en funcion del numero del modo</span>
2665             
2666             <span class="comment">% Si se grafica la carga no se aplica el factor sin(wt)</span>
2667             <span class="keyword">if</span> defCarga
2668                 phif = 1;
2669             <span class="keyword">end</span>
2670             
2671             <span class="comment">% Carga objetos</span>
2672             nodoObjetos = analisisObj.modeloObj.obtenerNodos();
2673             numeroNodos = length(nodoObjetos);
2674             
2675             <span class="comment">% Obtiene cuantos GDL tiene el modelo</span>
2676             gdl = 2;
2677             ngdl = analisisObj.modeloObj.obtenerNumeroDimensiones();
2678             j = 1;
2679             <span class="keyword">for</span> i = 1:numeroNodos
2680                 coords = nodoObjetos{i}.obtenerCoordenadas();
2681                 ngdlid = length(coords);
2682                 gdl = max(gdl, ngdlid);
2683                 <span class="keyword">if</span> ~deformada &amp;&amp; mostrarEstatico
2684                     <span class="keyword">if</span> modo ~= 0 || defCarga
2685                         nodoObjetos{i}.plot([], styleNodoE, sizeNodoE);
2686                     <span class="keyword">else</span>
2687                         nodoObjetos{i}.plot([], styleNodoD, sizeNodoD);
2688                     <span class="keyword">end</span>
2689                     <span class="keyword">if</span> j == 1
2690                         hold on;
2691                     <span class="keyword">end</span>
2692                     j = j + 1;
2693                 <span class="keyword">end</span>
2694             <span class="keyword">end</span> <span class="comment">% for i</span>
2695             
2696             <span class="comment">% Grafica los elementos</span>
2697             elementoObjetos = analisisObj.modeloObj.obtenerElementos();
2698             numeroElementos = length(elementoObjetos);
2699             <span class="keyword">for</span> i = 1:numeroElementos
2700                 
2701                 <span class="comment">% Se obienen los gdl del elemento metodo indicial</span>
2702                 nodoElemento = elementoObjetos{i}.obtenerNodos();
2703                 numNodo = length(nodoElemento);
2704                 
2705                 <span class="keyword">if</span> (~deformada || analisisObj.mostrarDeformada) &amp;&amp; mostrarEstatico
2706                     <span class="keyword">if</span> modo ~= 0 || defCarga
2707                         elementoObjetos{i}.plot({}, styleElemE, lwElemE, false);
2708                     <span class="keyword">else</span>
2709                         elementoObjetos{i}.plot({}, styleElemD, lwElemD, false);
2710                     <span class="keyword">end</span>
2711                 <span class="keyword">end</span>
2712                 
2713                 <span class="keyword">if</span> deformada
2714                     def = cell(numNodo, 1);
2715                     <span class="keyword">for</span> j = 1:numNodo
2716                         def{j} = factor * phif * analisisObj.obtenerDeformadaNodo(nodoElemento{j}, <span class="keyword">...</span>
2717                             modo, analisisObj.numDGReal, defCarga, carga, tcarga);
2718                     <span class="keyword">end</span> <span class="comment">% for j</span>
2719                     elementoObjetos{i}.plot(def, styleElemD, lwElemD, defElem);
2720                     <span class="keyword">if</span> i == 1
2721                         hold on;
2722                     <span class="keyword">end</span>
2723                 <span class="keyword">end</span>
2724                 
2725             <span class="keyword">end</span> <span class="comment">% for i</span>
2726             
2727             <span class="comment">% Grafica los nodos deformados</span>
2728             <span class="keyword">if</span> deformada
2729                 <span class="keyword">for</span> i = 1:numeroNodos
2730                     coords = nodoObjetos{i}.obtenerCoordenadas();
2731                     ngdlid = length(coords);
2732                     gdl = max(gdl, ngdlid);
2733                     def = analisisObj.obtenerDeformadaNodo(nodoObjetos{i}, modo, <span class="keyword">...</span>
2734                         gdl, defCarga, carga, tcarga);
2735                     nodoObjetos{i}.plot(def.*factor*phif, styleNodoD, sizeNodoD);
2736                 <span class="keyword">end</span> <span class="comment">% for i</span>
2737             <span class="keyword">end</span>
2738             
2739             <span class="comment">% Grafica los disipadores</span>
2740             <span class="keyword">if</span> mostrarDisipadores
2741                 disipadores = analisisObj.modeloObj.obtenerDisipadores();
2742                 <span class="keyword">for</span> i = 1:length(disipadores)
2743                     nodoDisipador = disipadores{i}.obtenerNodos();
2744                     numnodoDisipador = disipadores{i}.obtenerNumeroNodos();
2745                     def = cell(numnodoDisipador, 1);
2746                     <span class="keyword">for</span> j = 1:numnodoDisipador
2747                         def{j} = factor * phif * analisisObj.obtenerDeformadaNodo(nodoDisipador{j}, <span class="keyword">...</span>
2748                             modo, analisisObj.numDGReal, defCarga, carga, tcarga);
2749                     <span class="keyword">end</span> <span class="comment">% for j</span>
2750                     disipadores{i}.plot(def, styleDisipador, lwDisipador, colorDisipador);
2751                 <span class="keyword">end</span> <span class="comment">% for i</span>
2752             <span class="keyword">end</span>
2753             
2754             <span class="comment">% Setea el titulo</span>
2755             <span class="keyword">if</span> ~defCarga <span class="comment">% Se grafica los modos</span>
2756                 <span class="keyword">if</span> ~deformada
2757                     title(<span class="string">'Analisis modal espectral'</span>);
2758                 <span class="keyword">else</span>
2759                     a = sprintf(<span class="string">'Analisis modal espectral - Modo %d (T: %.3fs)'</span>, modo, per);
2760                     <span class="keyword">if</span> totCuadros &gt; 1
2761                         b = sprintf(<span class="string">'Escala deformacion x%d - Cuadro %s/%d'</span>, <span class="keyword">...</span>
2762                             factor, <a href="../../tefame/lib/padFillNum.html" class="code" title="function y = padFillNum(x, a)">padFillNum</a>(cuadro, totCuadros), totCuadros);
2763                     <span class="keyword">else</span>
2764                         b = sprintf(<span class="string">'Escala deformacion x%d'</span>, factor);
2765                     <span class="keyword">end</span>
2766                     title({a; b});
2767                 <span class="keyword">end</span>
2768             <span class="keyword">else</span> <span class="comment">% Grafica una carga</span>
2769                 a = sprintf(<span class="string">'Analisis modal espectral - Carga %s'</span>, carga.obtenerEtiqueta());
2770                 b = sprintf(<span class="string">'Escala deformacion x%d - Cuadro %s/%d - t:%.3fs'</span>, <span class="keyword">...</span>
2771                     factor, <a href="../../tefame/lib/padFillNum.html" class="code" title="function y = padFillNum(x, a)">padFillNum</a>(cuadro, totCuadros), totCuadros, tcargaEq(cuadro));
2772                 title({a; b});
2773             <span class="keyword">end</span>
2774             grid on;
2775             
2776             <span class="comment">% Limita en los ejes</span>
2777             <span class="keyword">if</span> deformada || modo == 0
2778                 <span class="keyword">if</span> limx(1) &lt; limx(2)
2779                     xlim(limx);
2780                 <span class="keyword">end</span>
2781                 <span class="keyword">if</span> limy(1) &lt; limy(2)
2782                     ylim(limy);
2783                 <span class="keyword">end</span>
2784                 <span class="keyword">if</span> gdl == 3 &amp;&amp; limz(1) &lt; limz(2)
2785                     zlim(limz);
2786                 <span class="keyword">end</span>
2787             <span class="keyword">end</span>
2788             
2789             <span class="keyword">if</span> ngdl == 2
2790                 xlabel(sprintf(<span class="string">'X (%s)'</span>, unidad));
2791                 ylabel(sprintf(<span class="string">'Y (%s)'</span>, unidad));
2792             <span class="keyword">else</span>
2793                 xlabel(sprintf(<span class="string">'X (%s)'</span>, unidad));
2794                 ylabel(sprintf(<span class="string">'Y (%s)'</span>, unidad));
2795                 zlabel(sprintf(<span class="string">'Z (%s)'</span>, unidad));
2796                 view(angAzh, angPol);
2797             <span class="keyword">end</span>
2798             
2799         <span class="keyword">end</span> <span class="comment">% plotAnimado function</span>
2800         
2801         <a name="_sub35" href="#_subfunctions" class="code">function [limx, limy, limz] = obtenerLimitesDeformada(analisisObj, modo, factor, defcarga, carga)</a>
2802             <span class="comment">% obtenerLimitesDeformada: Obtiene los limites de deformacion</span>
2803             <span class="comment">%</span>
2804             <span class="comment">% obtenerLimitesDeformada(analisisObj,modo,factor,defcarga,carga)</span>
2805             
2806             fprintf(<span class="string">'\tCalculando los limites del grafico\n'</span>);
2807             factor = 2.5 * factor;
2808             limx = [inf, -inf];
2809             limy = [inf, -inf];
2810             limz = [inf, -inf];
2811             
2812             <span class="comment">% Carga objetos</span>
2813             nodoObjetos = analisisObj.modeloObj.obtenerNodos();
2814             numeroNodos = length(nodoObjetos);
2815             gdl = 2;
2816             <span class="keyword">for</span> i = 1:numeroNodos
2817                 coords = nodoObjetos{i}.obtenerCoordenadas();
2818                 ngdlid = length(coords);
2819                 gdl = max(gdl, ngdlid);
2820             <span class="keyword">end</span> <span class="comment">% for i</span>
2821             
2822             elementoObjetos = analisisObj.modeloObj.obtenerElementos();
2823             numeroElementos = length(elementoObjetos);
2824             <span class="keyword">for</span> i = 1:numeroElementos
2825                 nodoElemento = elementoObjetos{i}.obtenerNodos();
2826                 numNodo = length(nodoElemento);
2827                 <span class="keyword">for</span> j = 1:numNodo
2828                     coord = nodoElemento{j}.obtenerCoordenadas();
2829                     <span class="keyword">if</span> (analisisObj.analisisFinalizado &amp;&amp; modo &gt; 0) || defcarga
2830                         def = analisisObj.obtenerDeformadaNodo(nodoElemento{j}, modo, gdl, defcarga, carga, -1);
2831                         coordi = coord + def .* factor;
2832                     <span class="keyword">else</span>
2833                         coordi = coord;
2834                     <span class="keyword">end</span>
2835                     limx(1) = min(limx(1), coordi(1));
2836                     limy(1) = min(limy(1), coordi(2));
2837                     limx(2) = max(limx(2), coordi(1));
2838                     limy(2) = max(limy(2), coordi(2));
2839                     <span class="keyword">if</span> gdl == 3
2840                         limz(1) = min(limz(1), coordi(3));
2841                         limz(2) = max(limz(2), coordi(3));
2842                     <span class="keyword">end</span>
2843                     <span class="keyword">if</span> (analisisObj.analisisFinalizado &amp;&amp; modo &gt; 0) || defcarga
2844                         coordf = coord - def .* factor;
2845                     <span class="keyword">else</span>
2846                         coordf = coord;
2847                     <span class="keyword">end</span>
2848                     limx(1) = min(limx(1), coordf(1));
2849                     limy(1) = min(limy(1), coordf(2));
2850                     limx(2) = max(limx(2), coordf(1));
2851                     limy(2) = max(limy(2), coordf(2));
2852                     <span class="keyword">if</span> gdl == 3
2853                         limz(1) = min(limz(1), coordf(3));
2854                         limz(2) = max(limz(2), coordf(3));
2855                     <span class="keyword">end</span>
2856                 <span class="keyword">end</span> <span class="comment">% for j</span>
2857             <span class="keyword">end</span> <span class="comment">% for i</span>
2858             
2859         <span class="keyword">end</span> <span class="comment">% obtenerLimitesDeformada function</span>
2860         
2861         <a name="_sub36" href="#_subfunctions" class="code">function def = obtenerDeformadaNodo(analisisObj, nodo, modo, gdl, defcarga, carga, tcarga)</a>
2862             <span class="comment">% obtenerDeformadaNodo: Obtiene la deformada de un nodo</span>
2863             <span class="comment">%</span>
2864             <span class="comment">% obtenerDeformadaNodo(analisisObj,nodo,modo,gdl,defcarga,carga,tcarga)</span>
2865             
2866             ngdl = nodo.obtenerGDLIDCondensado();
2867             def = zeros(gdl, 1);
2868             gdl = min(gdl, length(ngdl));
2869             <span class="keyword">for</span> i = 1:gdl
2870                 <span class="keyword">if</span> ngdl(i) &gt; 0
2871                     <span class="keyword">if</span> ~defcarga <span class="comment">% La deformada la saca a partir del modo</span>
2872                         <span class="keyword">if</span> modo &gt; 0
2873                             def(i) = analisisObj.phin(ngdl(i), modo);
2874                         <span class="keyword">else</span>
2875                             def(i) = 0;
2876                         <span class="keyword">end</span>
2877                     <span class="keyword">else</span>
2878                         def(i) = carga.obtenerDesplazamientoTiempo(ngdl(i), tcarga);
2879                     <span class="keyword">end</span>
2880                 <span class="keyword">else</span>
2881                     def(i) = 0;
2882                 <span class="keyword">end</span>
2883             <span class="keyword">end</span> <span class="comment">% for i</span>
2884             
2885         <span class="keyword">end</span> <span class="comment">% obtenerDeformadaNodo function</span>
2886         
2887         <a name="_sub37" href="#_subfunctions" class="code">function [Cortante, Momento, CBplot, MBplot, hplot] = calcularMomentoCorteBasalAcel(analisisObj, acel)</a>
2888             <span class="comment">% calcularMomentoCorteBasalAcel: Calcula el momento y corte</span>
2889             <span class="comment">% basal en funcion de una aceleracion</span>
2890             <span class="comment">%</span>
2891             <span class="comment">% [Cortante,Momento,CBplot,MBplot,hplot] = calcularMomentoCorteBasalAcel(analisisObj,acel)</span>
2892             <span class="comment">%</span>
2893             <span class="comment">% Se genera vector en que las filas contienen nodos en un mismo piso,</span>
2894             <span class="comment">% rellenando con ceros la matriz en caso de diferencia de nodos por piso.</span>
2895             <span class="comment">% Tambien se genera vector que contiene alturas de piso</span>
2896             
2897             <span class="comment">% Iniciando el proceso</span>
2898             
2899             
2900             nodos = analisisObj.modeloObj.obtenerNodos();
2901             nnodos = length(nodos);
2902             
2903             habs = zeros(1, 1);
2904             hNodos = zeros(1, 1);
2905             j = 1;
2906             k = 1;
2907             ini = 1;
2908             <span class="keyword">for</span> i = 1:nnodos
2909                 CoordNodo = nodos{i}.obtenerCoordenadas;
2910                 yNodo = CoordNodo(2);
2911                 <span class="keyword">if</span> yNodo ~= habs(j)
2912                     k = 1;
2913                     j = j + 1;
2914                     habs(j, 1) = yNodo;
2915                     hNodos(j, k) = i;
2916                 <span class="keyword">elseif</span> i == 1
2917                     hNodos(j, k) = i;
2918                 <span class="keyword">else</span>
2919                     k = k + 1;
2920                     hNodos(j, k) = i;
2921                 <span class="keyword">end</span>
2922                 <span class="keyword">if</span> yNodo == 0
2923                     ini = ini + 1;
2924                 <span class="keyword">end</span>
2925             <span class="keyword">end</span> <span class="comment">% for i</span>
2926             
2927             [~, s] = size(acel);
2928             M = analisisObj.obtenerMatrizMasa();
2929             m = zeros(nnodos-ini+1, 1);
2930             acelx = zeros(nnodos-ini+1, s);
2931             Fnodos = zeros(nnodos-ini+1, s);
2932             Fpisos = zeros(length(habs)-1, s);
2933             
2934             <span class="comment">% Calculo de fuerzas inerciales nodales que generan corte, fuerzas nodales</span>
2935             <span class="comment">% y fuerzas por piso</span>
2936             <span class="keyword">for</span> i = ini:nnodos
2937                 gdls = nodos{i}.obtenerGDLIDCondensado();
2938                 gdlx = gdls(1);
2939                 acelx(i-ini+1, :) = acel(gdlx, :);
2940                 m(i-ini+1, 1) = M(gdlx, gdlx);
2941                 Fnodos(i-ini+1, :) = M(gdlx, gdlx) .* acel(gdlx, :);
2942                 [fil, ~] = find(hNodos == i);
2943                 Fpisos(fil-1, :) = Fpisos(fil-1, :) + Fnodos(i-ini+1, :);
2944             <span class="keyword">end</span> <span class="comment">% for i</span>
2945             
2946             <span class="comment">% Calculo de cortante y momento acumulado por piso</span>
2947             Fpisos_ud = flipud(Fpisos);
2948             habs_ud = flipud(habs);
2949             Cortante = zeros(length(habs)-1, s);
2950             Momento = zeros(length(habs)-1, s);
2951             <span class="keyword">for</span> i = 1:length(habs) - 1
2952                 hcero = habs_ud(i+1);
2953                 <span class="keyword">for</span> j = 1:i
2954                     Cortante(i, :) = Cortante(i, :) + Fpisos_ud(j, :);
2955                     Momento(i, :) = Momento(i, :) + Fpisos_ud(j, :) .* (habs_ud(j) - hcero);
2956                 <span class="keyword">end</span> <span class="comment">% for j</span>
2957             <span class="keyword">end</span> <span class="comment">% for i</span>
2958             
2959             <span class="comment">% Determinacion de envolvente maxima de cortante y momento basal</span>
2960             icor = 1;
2961             imom = 1;
2962             CorB_max = 1;
2963             MomB_max = 1;
2964             [nfil, ~] = size(Cortante);
2965             <span class="keyword">for</span> i = 1:s
2966                 <span class="keyword">if</span> abs(Cortante(nfil, i)) &gt; abs(CorB_max)
2967                     icor = i;
2968                     CorB_max = Cortante(nfil, i);
2969                 <span class="keyword">end</span>
2970                 <span class="keyword">if</span> abs(Momento(nfil, i)) &gt; abs(MomB_max)
2971                     imom = i;
2972                     MomB_max = Momento(nfil, i);
2973                 <span class="keyword">end</span>
2974             <span class="keyword">end</span> <span class="comment">% for i</span>
2975             
2976             <span class="comment">% Calcula las envolventes, aplica valor absoluto</span>
2977             VecCB = abs(Cortante(:, icor));
2978             VecMB = abs(Momento(:, imom));
2979             hgen = habs_ud;
2980             hplot = zeros(2*length(hgen), 1);
2981             CBplot = zeros(2*length(hgen)-1, 1);
2982             MBplot = zeros(2*length(hgen)-1, 1);
2983             aux1 = 1;
2984             aux2 = 2;
2985             <span class="keyword">for</span> i = 1:length(hgen)
2986                 hplot(aux1, 1) = hgen(i);
2987                 hplot(aux1+1, 1) = hgen(i);
2988                 <span class="keyword">if</span> aux2 &lt;= 2 * length(hgen) - 1
2989                     CBplot(aux2, 1) = VecCB(i);
2990                     CBplot(aux2+1, 1) = VecCB(i);
2991                     MBplot(aux2, 1) = VecMB(i);
2992                     MBplot(aux2+1, 1) = VecMB(i);
2993                 <span class="keyword">end</span>
2994                 aux1 = aux1 + 2;
2995                 aux2 = aux2 + 2;
2996             <span class="keyword">end</span> <span class="comment">% for i</span>
2997             hplot(length(hplot)) = [];
2998             
2999         <span class="keyword">end</span> <span class="comment">% calcularMomentoCorteBasalAcel function</span>
3000         
3001         <a name="_sub38" href="#_subfunctions" class="code">function ctitle = imprimirPropiedadesAnalisisCarga(analisisObj, carga) </a><span class="comment">%#ok&lt;INUSL&gt;</span>
3002             <span class="comment">% imprimirPropiedadesAnalisisCarga: Imprime propiedades de</span>
3003             <span class="comment">% analisis de la carga o combinacion de cargas</span>
3004             <span class="comment">%</span>
3005             <span class="comment">% ctitle = imprimirPropiedadesAnalisisCarga(analisisObj, carga)</span>
3006             
3007             ctitle = <span class="string">'Carga'</span>;
3008             <span class="keyword">if</span> isa(carga, <span class="string">'CombinacionCargas'</span>)
3009                 ctitle = <span class="string">'Combinacion'</span>;
3010             <span class="keyword">end</span>
3011             fprintf(<span class="string">'\t%s %s\n'</span>, ctitle, carga.obtenerEtiqueta());
3012             
3013             <span class="keyword">if</span> carga.usoAmortiguamientoRayleigh()
3014                 fprintf(<span class="string">'\t\tLa %s se calculo con amortiguamiento Rayleigh\n'</span>, lower(ctitle));
3015             <span class="keyword">else</span>
3016                 fprintf(<span class="string">'\t\tLa %s se calculo con amortiguamiento de Wilson-Penzien\n'</span>, lower(ctitle));
3017             <span class="keyword">end</span>
3018             
3019             <span class="keyword">if</span> carga.usoDescomposicionModal()
3020                 fprintf(<span class="string">'\t\tLa %s se calculo usando descomposicion modal\n'</span>, lower(ctitle));
3021             <span class="keyword">else</span>
3022                 fprintf(<span class="string">'\t\tLa %s se calculo sin usar descomposicion modal\n'</span>, lower(ctitle));
3023             <span class="keyword">end</span>
3024             
3025         <span class="keyword">end</span> <span class="comment">% imprimirPropiedadesAnalisisCarga function</span>
3026         
3027     <span class="keyword">end</span> <span class="comment">% methods(private) ModalEspectral</span>
3028     
3029 <span class="keyword">end</span> <span class="comment">% class ModalEspectral</span></pre></div>
<hr><address>Generated on Sun 12-May-2019 12:27:52 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>