<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ModalEspectral</title>
  <meta name="keywords" content="ModalEspectral">
  <meta name="description" content="______________________________________________________________________">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # tefame --><!-- menu.html analisis -->
<h1>ModalEspectral
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>______________________________________________________________________</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> ______________________________________________________________________
|                                                                      |
|           TEFAME - Toolbox para Elementos Finitos y Analisis         |
|                  Matricial de Estructuras en MATLAB                  |
|                                                                      |
|                   Area  de Estructuras y Geotecnia                   |
|                   Departamento de Ingenieria Civil                   |
|              Facultad de Ciencias Fisicas y Matematicas              |
|                         Universidad de Chile                         |
|                                                                      |
| TEFAME es una  plataforma en base a objetos para modelar, analizar y |
| visualizar  la respuesta de sistemas  estructurales usando el metodo |
| de elementos finitos y analisis matricial de estructuras en MATLAB.  |
| La plataforma es desarrollada en  propagacion orientada a objetos en |
| MATLAB.                                                              |
|______________________________________________________________________|
 ______________________________________________________________________
|                                                                      |
| Clase ModalEspectral                                                 |
|                                                                      |
| Este archivo contiene la definicion de la Clase ModalEspectral       |
| ModalEspectral es una clase que se usa para resolver la estructura   |
| aplicando el metodo modal espectral. Para ello se calcula la matriz  |
| de masa y de rigidez.                                                |
|                                                                      |
| Programado: Pablo Pizarro @ppizarror                                 |
| Fecha: 18/03/2019                                                    |
|______________________________________________________________________|

  Properties (Access=private):
       analisisFinalizado
       cargarAnimacion
       condMatRot
       condMatT
       cPenzien
       cRayleigh
       F
       gdlCond
       Km
       Kt
       Lm
       Mm
       Mmeff
       Mmeffacum
       modeloObj
       mostrarDeformada
       Mt
       Mtotal
       numDG
       numDGReal
       numeroGDL
       numModos
       phiExt
       phin
       rm
       Tn
       u
       wn
  Methods:
       analisisObj = ModalEspectral(modeloObjeto)
       [esfmax,esf,maxp,dirk] = calcularEsfuerzosElemento(analisisObj,carga,elemento,direccion)
       activarCargaAnimacion(analisisObj)
       activarPlotDeformadaInicial(analisisObj)
       analizar(analisisObj,varargin)
       c = obtenerCargaEstatica(analisisObj,varargin)
       C_Modelo = obtenerMatrizAmortiguamiento(analisisObj,rayleigh)
       calcularCurvasEnergia(analisisObj,carga)
       calcularDesplazamientoDrift(analisisObj,xanalisis)
       calcularMomentoCorteBasal(analisisObj,carga)
       Cdv_Modelo = obtenerMatrizAmortiguamientoDisipadores(analisisObj)
       definirNumeracionGDL(analisisObj)
       desactivarCargaAnimacion(analisisObj)
       desactivarPlotDeformadaInicial(analisisObj)
       disp(analisisObj)
       F_Modelo = obtenerVectorFuerzas(analisisObj)
       K_Modelo = obtenerMatrizRigidez(analisisObj)
       Kdv_Modelo = obtenerMatrizRigidezDisipadores(analisisObj)
       M_Modelo = obtenerMatrizMasa(analisisObj)
       numeroEcuaciones = obtenerNumeroEcuaciones(analisisObj)
       phi_Modelo = obtenerMatrizPhi(analisisObj)
       plot(analisisObj,varargin)
       plotEsfuerzosElemento(analisisObj,carga)
       plotTrayectoriaNodo(analisisObj,carga,nodo,direccion)
       r_Modelo = obtenerVectorInfluencia(analisisObj)
       u_Modelo = obtenerDesplazamientos(analisisObj)
       wn_Modelo = obtenerValoresPropios(analisisObj)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="Analisis.html" class="code" title="">Analisis</a>	______________________________________________________________________</li><li><a href="ModalEspectral.html" class="code" title="">ModalEspectral</a>	______________________________________________________________________</li><li><a href="../../tefame/analisis/eig/calculoEigDirectaBarrido.html" class="code" title="function [v, w, error] = calculoEigDirectaBarrido(M, K, nModos, tol)">calculoEigDirectaBarrido</a>	calculoEigIterDirecta: Calcula los valores y vectores propios del sistema</li><li><a href="../../tefame/analisis/eig/calculoEigEigs.html" class="code" title="function [w, v] = calculoEigEigs(M, K, nModos)">calculoEigEigs</a>	calculoEigEigs: Calcula los valores y vectores propios del sistema usando</li><li><a href="../../tefame/analisis/eig/calculoEigItSubespacio.html" class="code" title="function [v, w] = calculoEigItSubespacio(M, K, nModos, tol)">calculoEigItSubespacio</a>	calculoEigItSubespacio: Calcula los valores y vectores propios del sistema</li><li><a href="../../tefame/analisis/eig/calculoEigIterDirecta.html" class="code" title="function [v, w, error] = calculoEigIterDirecta(M, K, tol)">calculoEigIterDirecta</a>	calculoEigIterDirecta: Calcula los valores y vectores propios del sistema</li><li><a href="../../tefame/analisis/eig/calculoEigIterInvDesplazamiento.html" class="code" title="function [v, w, error] = calculoEigIterInvDesplazamiento(M, K, mu, tol)">calculoEigIterInvDesplazamiento</a>	calculoEigIterDirecta: Calcula los valores y vectores propios del sistema</li><li><a href="../../tefame/lib/allDivMod.html" class="code" title="function t = allDivMod(y, r)">allDivMod</a>	ALLDIVMOD Retorna verdadero si todos los elementos de y son divisibles por r.</li><li><a href="../../tefame/lib/arrayIntNum2str.html" class="code" title="function textCell = arrayIntNum2str(a, num)">arrayIntNum2str</a>	textCell = array2str(a,num) function that transform the array of number to a</li><li><a href="../../tefame/lib/arrayNum2str.html" class="code" title="function textCell = arrayNum2str(a, num)">arrayNum2str</a>	textCell = array2str(a,num) function that transform the array of number to a</li><li><a href="../../tefame/lib/arrayStr2str.html" class="code" title="function textCell = arrayStr2str(a, num)">arrayStr2str</a>	textCell = array2str(a,num) function that transform the array of string to a</li><li><a href="../../tefame/lib/drawVyLine.html" class="code" title="function obj = drawVyLine(y, style, lw)">drawVyLine</a>	DRAW VX LINE</li><li><a href="../../tefame/lib/gifPlayerGUI.html" class="code" title="function gifPlayerGUI(fname, delayTime)">gifPlayerGUI</a>	</li><li><a href="../../tefame/lib/padFillNum.html" class="code" title="function y = padFillNum(x, a)">padFillNum</a>	PADFILLNUM Full a number respect to <a></li><li><a href="../../tefame/modelo/cargas/CargaDinamica.html" class="code" title="">CargaDinamica</a>	______________________________________________________________________</li><li><a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>	dispMetodoTEFAME: Normaliza la salida estandar disp en consola de los</li><li><a href="../../tefame/utils/verificarVectorDireccion.html" class="code" title="function y = verificarVectorDireccion(vec, ndg)">verificarVectorDireccion</a>	verificarVectorDireccion: Verifica que un vector direccion tenga sentido y</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="ModalEspectral.html" class="code" title="">ModalEspectral</a>	______________________________________________________________________</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function analisisObj = ModalEspectral(modeloObjeto)</a></li><li><a href="#_sub2" class="code">function analizar(analisisObj, varargin)</a></li><li><a href="#_sub3" class="code">function resolverCargasDinamicas(analisisObj, varargin)</a></li><li><a href="#_sub4" class="code">function numeroEcuaciones = obtenerNumeroEcuaciones(analisisObj)</a></li><li><a href="#_sub5" class="code">function M_Modelo = obtenerMatrizMasa(analisisObj)</a></li><li><a href="#_sub6" class="code">function C_Modelo = obtenerMatrizAmortiguamiento(analisisObj, rayleigh)</a></li><li><a href="#_sub7" class="code">function K_Modelo = obtenerMatrizRigidez(analisisObj)</a></li><li><a href="#_sub8" class="code">function Cdv_Modelo = obtenerMatrizAmortiguamientoDisipadores(analisisObj)</a></li><li><a href="#_sub9" class="code">function Kdv_Modelo = obtenerMatrizRigidezDisipadores(analisisObj)</a></li><li><a href="#_sub10" class="code">function r_Modelo = obtenerVectorInfluencia(analisisObj)</a></li><li><a href="#_sub11" class="code">function F_Modelo = obtenerVectorFuerzas(analisisObj)</a></li><li><a href="#_sub12" class="code">function u_Modelo = obtenerDesplazamientos(analisisObj)</a></li><li><a href="#_sub13" class="code">function wn_Modelo = obtenerValoresPropios(analisisObj)</a></li><li><a href="#_sub14" class="code">function phi_Modelo = obtenerMatrizPhi(analisisObj)</a></li><li><a href="#_sub15" class="code">function plt = plot(analisisObj, varargin)</a></li><li><a href="#_sub16" class="code">function guardarResultados(analisisObj, nombreArchivo, cargas)</a></li><li><a href="#_sub17" class="code">function calcularDesplazamientoDrift(analisisObj, carga, xanalisis, varargin)</a></li><li><a href="#_sub18" class="code">function calcularMomentoCorteBasal(analisisObj, carga, varargin)</a></li><li><a href="#_sub19" class="code">function calcularCurvasEnergia(analisisObj, carga, varargin)</a></li><li><a href="#_sub20" class="code">function e_v = calcularModosEnergia(analisisObj, carga, dispinfo)</a></li><li><a href="#_sub21" class="code">function [esfmax, esf, maxp, dirk] = calcularEsfuerzosElemento(analisisObj, carga, elemento, direccion)</a></li><li><a href="#_sub22" class="code">function plotEsfuerzosElemento(analisisObj, carga, elemento, direccion, varargin)</a></li><li><a href="#_sub23" class="code">function plotTrayectoriaNodo(analisisObj, carga, nodo, direccion, varargin)</a></li><li><a href="#_sub24" class="code">function activarCargaAnimacion(analisisObj)</a></li><li><a href="#_sub25" class="code">function desactivarCargaAnimacion(analisisObj)</a></li><li><a href="#_sub26" class="code">function activarPlotDeformadaInicial(analisisObj)</a></li><li><a href="#_sub27" class="code">function desactivarPlotDeformadaInicial(analisisObj)</a></li><li><a href="#_sub28" class="code">function disp(analisisObj)</a></li><li><a href="#_sub29" class="code">function c = obtenerCargaEstatica(analisisObj, varargin)</a></li><li><a href="#_sub30" class="code">function definirNumeracionGDL(analisisObj)</a></li><li><a href="#_sub31" class="code">function calcularModalEspectral(analisisObj, nModos, betacR, modocR,</a></li><li><a href="#_sub32" class="code">function ensamblarMatrizRigidez(analisisObj)</a></li><li><a href="#_sub33" class="code">function ensamblarMatrizMasa(analisisObj)</a></li><li><a href="#_sub34" class="code">function Cdv = ensamblarMatrizAmortiguamientoDisipadores(analisisObj)</a></li><li><a href="#_sub35" class="code">function Kdv = ensamblarMatrizRigidezDisipadores(analisisObj)</a></li><li><a href="#_sub36" class="code">function ensamblarVectorFuerzas(analisisObj)</a></li><li><a href="#_sub37" class="code">function plotAnimado(analisisObj, deformada, modo, factor, phif, limx, limy, limz,</a></li><li><a href="#_sub38" class="code">function [limx, limy, limz] = obtenerLimitesDeformada(analisisObj, modo, factor, defcarga, carga)</a></li><li><a href="#_sub39" class="code">function def = obtenerDeformadaNodo(analisisObj, nodo, modo, gdl, defcarga, carga, tcarga)</a></li><li><a href="#_sub40" class="code">function [Cortante, Momento, CBplot, MBplot, hplot] = calcularMomentoCorteBasalAcel(analisisObj, acel)</a></li><li><a href="#_sub41" class="code">function ctitle = imprimirPropiedadesAnalisisCarga(analisisObj, carga)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% ______________________________________________________________________</span>
0002 <span class="comment">%|                                                                      |</span>
0003 <span class="comment">%|          TEFAME - Toolbox para Elementos Finitos y Analisis          |</span>
0004 <span class="comment">%|                  Matricial de Estructuras en MATLAB                  |</span>
0005 <span class="comment">%|                                                                      |</span>
0006 <span class="comment">%|                   Area  de Estructuras y Geotecnia                   |</span>
0007 <span class="comment">%|                   Departamento de Ingenieria Civil                   |</span>
0008 <span class="comment">%|              Facultad de Ciencias Fisicas y Matematicas              |</span>
0009 <span class="comment">%|                         Universidad de Chile                         |</span>
0010 <span class="comment">%|                                                                      |</span>
0011 <span class="comment">%| TEFAME es una  plataforma en base a objetos para modelar, analizar y |</span>
0012 <span class="comment">%| visualizar  la respuesta de sistemas  estructurales usando el metodo |</span>
0013 <span class="comment">%| de elementos finitos y analisis matricial de estructuras en MATLAB.  |</span>
0014 <span class="comment">%| La plataforma es desarrollada en  propagacion orientada a objetos en |</span>
0015 <span class="comment">%| MATLAB.                                                              |</span>
0016 <span class="comment">%|______________________________________________________________________|</span>
0017 <span class="comment">% ______________________________________________________________________</span>
0018 <span class="comment">%|                                                                      |</span>
0019 <span class="comment">%| Clase ModalEspectral                                                 |</span>
0020 <span class="comment">%|                                                                      |</span>
0021 <span class="comment">%| Este archivo contiene la definicion de la Clase ModalEspectral       |</span>
0022 <span class="comment">%| ModalEspectral es una clase que se usa para resolver la estructura   |</span>
0023 <span class="comment">%| aplicando el metodo modal espectral. Para ello se calcula la matriz  |</span>
0024 <span class="comment">%| de masa y de rigidez.                                                |</span>
0025 <span class="comment">%|                                                                      |</span>
0026 <span class="comment">%| Programado: Pablo Pizarro @ppizarror                                 |</span>
0027 <span class="comment">%| Fecha: 18/03/2019                                                    |</span>
0028 <span class="comment">%|______________________________________________________________________|</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%  Properties (Access=private):</span>
0031 <span class="comment">%       analisisFinalizado</span>
0032 <span class="comment">%       cargarAnimacion</span>
0033 <span class="comment">%       condMatRot</span>
0034 <span class="comment">%       condMatT</span>
0035 <span class="comment">%       cPenzien</span>
0036 <span class="comment">%       cRayleigh</span>
0037 <span class="comment">%       F</span>
0038 <span class="comment">%       gdlCond</span>
0039 <span class="comment">%       Km</span>
0040 <span class="comment">%       Kt</span>
0041 <span class="comment">%       Lm</span>
0042 <span class="comment">%       Mm</span>
0043 <span class="comment">%       Mmeff</span>
0044 <span class="comment">%       Mmeffacum</span>
0045 <span class="comment">%       modeloObj</span>
0046 <span class="comment">%       mostrarDeformada</span>
0047 <span class="comment">%       Mt</span>
0048 <span class="comment">%       Mtotal</span>
0049 <span class="comment">%       numDG</span>
0050 <span class="comment">%       numDGReal</span>
0051 <span class="comment">%       numeroGDL</span>
0052 <span class="comment">%       numModos</span>
0053 <span class="comment">%       phiExt</span>
0054 <span class="comment">%       phin</span>
0055 <span class="comment">%       rm</span>
0056 <span class="comment">%       Tn</span>
0057 <span class="comment">%       u</span>
0058 <span class="comment">%       wn</span>
0059 <span class="comment">%  Methods:</span>
0060 <span class="comment">%       analisisObj = ModalEspectral(modeloObjeto)</span>
0061 <span class="comment">%       [esfmax,esf,maxp,dirk] = calcularEsfuerzosElemento(analisisObj,carga,elemento,direccion)</span>
0062 <span class="comment">%       activarCargaAnimacion(analisisObj)</span>
0063 <span class="comment">%       activarPlotDeformadaInicial(analisisObj)</span>
0064 <span class="comment">%       analizar(analisisObj,varargin)</span>
0065 <span class="comment">%       c = obtenerCargaEstatica(analisisObj,varargin)</span>
0066 <span class="comment">%       C_Modelo = obtenerMatrizAmortiguamiento(analisisObj,rayleigh)</span>
0067 <span class="comment">%       calcularCurvasEnergia(analisisObj,carga)</span>
0068 <span class="comment">%       calcularDesplazamientoDrift(analisisObj,xanalisis)</span>
0069 <span class="comment">%       calcularMomentoCorteBasal(analisisObj,carga)</span>
0070 <span class="comment">%       Cdv_Modelo = obtenerMatrizAmortiguamientoDisipadores(analisisObj)</span>
0071 <span class="comment">%       definirNumeracionGDL(analisisObj)</span>
0072 <span class="comment">%       desactivarCargaAnimacion(analisisObj)</span>
0073 <span class="comment">%       desactivarPlotDeformadaInicial(analisisObj)</span>
0074 <span class="comment">%       disp(analisisObj)</span>
0075 <span class="comment">%       F_Modelo = obtenerVectorFuerzas(analisisObj)</span>
0076 <span class="comment">%       K_Modelo = obtenerMatrizRigidez(analisisObj)</span>
0077 <span class="comment">%       Kdv_Modelo = obtenerMatrizRigidezDisipadores(analisisObj)</span>
0078 <span class="comment">%       M_Modelo = obtenerMatrizMasa(analisisObj)</span>
0079 <span class="comment">%       numeroEcuaciones = obtenerNumeroEcuaciones(analisisObj)</span>
0080 <span class="comment">%       phi_Modelo = obtenerMatrizPhi(analisisObj)</span>
0081 <span class="comment">%       plot(analisisObj,varargin)</span>
0082 <span class="comment">%       plotEsfuerzosElemento(analisisObj,carga)</span>
0083 <span class="comment">%       plotTrayectoriaNodo(analisisObj,carga,nodo,direccion)</span>
0084 <span class="comment">%       r_Modelo = obtenerVectorInfluencia(analisisObj)</span>
0085 <span class="comment">%       u_Modelo = obtenerDesplazamientos(analisisObj)</span>
0086 <span class="comment">%       wn_Modelo = obtenerValoresPropios(analisisObj)</span>
0087 
0088 classdef <a href="ModalEspectral.html" class="code" title="">ModalEspectral</a> &lt; <a href="Analisis.html" class="code" title="">Analisis</a>
0089     
0090     properties(Access = private)
0091         cargarAnimacion <span class="comment">% Carga la animacion del grafico una vez renderizado</span>
0092         condMatRot <span class="comment">% Matriz de condensacion rotacion</span>
0093         condMatT <span class="comment">% Matriz de condensacion T</span>
0094         cPenzien <span class="comment">% Matriz de amortiguamiento de Wilson-Penzien</span>
0095         cRayleigh <span class="comment">% Matriz de amortiguamiento de Rayleigh</span>
0096         F <span class="comment">% Vector de fuerzas aplicadas sobre el modelo</span>
0097         gdlCond <span class="comment">% Grados de libertad condensados</span>
0098         Km <span class="comment">% Matriz rigidez modal</span>
0099         Kt <span class="comment">% Matriz de rigidez del modelo</span>
0100         Kteq <span class="comment">% Matriz rigidez equivalente</span>
0101         Lm <span class="comment">% Factor de participacion modal</span>
0102         Mm <span class="comment">% Matriz masa modal</span>
0103         Mmeff <span class="comment">% Masa modal efectiva</span>
0104         Mmeffacum <span class="comment">% Masa modal efectiva acumulada</span>
0105         mostrarDeformada <span class="comment">% Muestra la posicion no deformada en los graficos</span>
0106         Mt <span class="comment">% Matriz de masa del modelo</span>
0107         Mteq <span class="comment">% Matriz masa equivalente</span>
0108         Mtotal <span class="comment">% Masa total del modelo</span>
0109         numDG <span class="comment">% Numero de ejes de analisis despues de condensar</span>
0110         numDGReal <span class="comment">% Numero de ejes de analisis antes de condensar</span>
0111         numModos <span class="comment">% Numero de modos del analisis</span>
0112         phin <span class="comment">% Vectores propios del sistema</span>
0113         phinExt <span class="comment">% Vector propio del sistema extendido considerando grados condensados</span>
0114         rm <span class="comment">% Vector influencia</span>
0115         Tn <span class="comment">% Periodos del sistema</span>
0116         u <span class="comment">% Vector con los desplazamientos de los grados de libertad del modelo</span>
0117         wn <span class="comment">% Frecuencias del sistema</span>
0118     <span class="keyword">end</span> <span class="comment">% properties ModalEspectral</span>
0119     
0120     methods(Access = public)
0121         
0122         <a name="_sub0" href="#_subfunctions" class="code">function analisisObj = ModalEspectral(modeloObjeto)</a>
0123             <span class="comment">% ModalEspectral: es el constructor de la clase ModalEspectral</span>
0124             <span class="comment">%</span>
0125             <span class="comment">% analisisObj = ModalEspectral(modeloObjeto)</span>
0126             <span class="comment">%</span>
0127             <span class="comment">% Crea un objeto de la clase ModalEspectral, y guarda el modelo,</span>
0128             <span class="comment">% que necesita ser analizado</span>
0129             
0130             <span class="keyword">if</span> nargin == 0
0131                 modeloObjeto = [];
0132             <span class="keyword">end</span> <span class="comment">% if</span>
0133             
0134             analisisObj = analisisObj@<a href="Analisis.html" class="code" title="">Analisis</a>(modeloObjeto);
0135             analisisObj.Kt = [];
0136             analisisObj.Mt = [];
0137             analisisObj.u = [];
0138             analisisObj.F = [];
0139             analisisObj.mostrarDeformada = false;
0140             analisisObj.cargarAnimacion = true;
0141             
0142         <span class="keyword">end</span> <span class="comment">% ModalEspectral constructor</span>
0143         
0144         <a name="_sub1" href="#_subfunctions" class="code">function analizar(analisisObj, varargin)</a>
0145             <span class="comment">% analizar: es un metodo de la clase ModalEspectral que se usa para</span>
0146             <span class="comment">% realizar el analisis estatico</span>
0147             <span class="comment">% Analiza estaticamente el modelo lineal y elastico sometido a un</span>
0148             <span class="comment">% set de cargas, requiere el numero de modos para realizar el</span>
0149             <span class="comment">% analisis y de los modos conocidos con sus beta</span>
0150             <span class="comment">%</span>
0151             <span class="comment">% analizar(analisisObj,varargin)</span>
0152             <span class="comment">%</span>
0153             <span class="comment">% Parametros opcionales:</span>
0154             <span class="comment">%   'condensar'         Aplica condensacion (true por defecto)</span>
0155             <span class="comment">%   'cpenzienBeta'      Vector amortiguamiento Cpenzien</span>
0156             <span class="comment">%   'factorCargaE'      Factor de cargas estaticas</span>
0157             <span class="comment">%   'nModos'            Numero de modos de analisis (obligatorio)</span>
0158             <span class="comment">%   'rayleighBeta'      Vector amortiguamientos de Rayleigh</span>
0159             <span class="comment">%   'rayleighDir'       Direccion amortiguamiento Rayleigh</span>
0160             <span class="comment">%   'rayleighModo'      Vector modos de Rayleigh</span>
0161             <span class="comment">%   'toleranciaMasa'    Tolerancia de la masa para la condensacion</span>
0162             <span class="comment">%   'valvecAlgoritmo'   'eigvc','itDir','matBarr','itInvDesp','itSubesp'</span>
0163             <span class="comment">%   'valvecTolerancia'  Tolerancia calculo valores y vectores propios</span>
0164             
0165             <span class="comment">% Define parametros</span>
0166             p = inputParser;
0167             p.KeepUnmatched = true;
0168             addOptional(p, <span class="string">'condensar'</span>, true);
0169             addOptional(p, <span class="string">'cpenzienBeta'</span>, []);
0170             addOptional(p, <span class="string">'factorCargaE'</span>, 1);
0171             addOptional(p, <span class="string">'muIterDespl'</span>, 0.5);
0172             addOptional(p, <span class="string">'nModos'</span>, 0);
0173             addOptional(p, <span class="string">'rayleighBeta'</span>, []);
0174             addOptional(p, <span class="string">'rayleighDir'</span>, []);
0175             addOptional(p, <span class="string">'rayleighModo'</span>, []);
0176             addOptional(p, <span class="string">'toleranciamasa'</span>, 0.001);
0177             addOptional(p, <span class="string">'valvecAlgoritmo'</span>, <span class="string">'eigs'</span>);
0178             addOptional(p, <span class="string">'valvecTolerancia'</span>, 0.001);
0179             parse(p, varargin{:});
0180             r = p.Results;
0181             
0182             maxcond = r.toleranciamasa;
0183             <span class="keyword">if</span> ~r.condensar
0184                 maxcond = -1;
0185             <span class="keyword">end</span>
0186             
0187             <span class="comment">% Verifica que parametros obligatorios sean proporcionados</span>
0188             <span class="keyword">if</span> r.nModos &lt;= 0
0189                 error(<span class="string">'Numero de modos invalido'</span>);
0190             <span class="keyword">end</span>
0191             r.nModos = floor(r.nModos);
0192             
0193             <span class="keyword">if</span> isempty(r.rayleighBeta)
0194                 error(<span class="string">'Vector amortiguamiento de Rayleigh no puede ser nulo'</span>);
0195             <span class="keyword">end</span>
0196             
0197             <span class="keyword">if</span> isempty(r.rayleighModo)
0198                 error(<span class="string">'Vector modo Rayleigh no puede ser nulo'</span>);
0199             <span class="keyword">end</span>
0200             
0201             <span class="keyword">for</span> i = 1:length(r.rayleighModo)
0202                 <span class="keyword">if</span> r.rayleighModo(i) &lt;= 0
0203                     error(<span class="string">'Vector Rayleigh modo mal definido'</span>);
0204                 <span class="keyword">end</span>
0205             <span class="keyword">end</span> <span class="comment">% for i</span>
0206             
0207             <span class="keyword">if</span> length(r.rayleighBeta) ~= length(r.rayleighModo) || <span class="keyword">...</span>
0208                     length(r.rayleighBeta) ~= length(r.rayleighDir)
0209                 error(<span class="string">'Vectores parametros Rayleigh deben tener igual dimension'</span>);
0210             <span class="keyword">end</span>
0211             
0212             <span class="keyword">for</span> i = 1:length(r.rayleighDir)
0213                 <span class="keyword">if</span> ~(r.rayleighDir(i) == <span class="string">'h'</span> || r.rayleighDir(i) == <span class="string">'v'</span>)
0214                     error(<span class="string">'Direccion amortiguamiento Rayleigh solo puede ser (h) horizonal o (v) vertical'</span>);
0215                 <span class="keyword">end</span>
0216             <span class="keyword">end</span> <span class="comment">% for i</span>
0217             
0218             <span class="keyword">if</span> isempty(r.cpenzienBeta)
0219                 error(<span class="string">'Vector amortiguamiento cpenzien no puede ser nulo'</span>);
0220             <span class="keyword">end</span>
0221             
0222             <span class="keyword">if</span> r.valvecTolerancia &lt;= 0
0223                 error(<span class="string">'Tolerancia calculo valores y vectores propios no puede ser inferior o igual a cero'</span>);
0224             <span class="keyword">end</span>
0225             
0226             fprintf(<span class="string">'Ejecutando analisis modal espectral:\n'</span>);
0227             fprintf(<span class="string">'\tParametros analisis:\n'</span>);
0228             fprintf(<span class="string">'\t\tNumero de modos: %d\n'</span>, r.nModos);
0229             
0230             fprintf(<span class="string">'\t\tAmortiguamiento Rayleigh:\n'</span>);
0231             s = <a href="../../tefame/lib/arrayIntNum2str.html" class="code" title="function textCell = arrayIntNum2str(a, num)">arrayIntNum2str</a>(r.rayleighModo);
0232             fprintf(<span class="string">'\t\t\tModos:\t\t%s\n'</span>, [s{:}]);
0233             s = <a href="../../tefame/lib/arrayNum2str.html" class="code" title="function textCell = arrayNum2str(a, num)">arrayNum2str</a>(r.rayleighBeta);
0234             fprintf(<span class="string">'\t\t\tBeta:\t\t%s\n'</span>, [s{:}]);
0235             s = <a href="../../tefame/lib/arrayStr2str.html" class="code" title="function textCell = arrayStr2str(a, num)">arrayStr2str</a>(r.rayleighDir);
0236             fprintf(<span class="string">'\t\t\tDireccion:\t%s\n'</span>, [s{:}]);
0237             
0238             fprintf(<span class="string">'\t\tAmortiguamiento cpenzien:\n'</span>);
0239             s = <a href="../../tefame/lib/arrayNum2str.html" class="code" title="function textCell = arrayNum2str(a, num)">arrayNum2str</a>(r.cpenzienBeta);
0240             fprintf(<span class="string">'\t\t\tBeta:\t\t%s\n'</span>, [s{:}]);
0241             
0242             <span class="comment">% Se definen los grados de libertad por nodo -&gt; elementos</span>
0243             analisisObj.definirNumeracionGDL();
0244             
0245             <span class="comment">% Se aplica patron de carga</span>
0246             analisisObj.modeloObj.aplicarPatronesDeCargasEstatico(r.factorCargaE);
0247             
0248             <span class="comment">% Se calcula la matriz de rigidez</span>
0249             analisisObj.ensamblarMatrizRigidez();
0250             
0251             <span class="comment">% Se calcula la matriz de masa</span>
0252             analisisObj.ensamblarMatrizMasa();
0253             
0254             <span class="comment">% Guarda el resultado para las cargas estaticas</span>
0255             fprintf(<span class="string">'\tCalculando resultado carga estatica\n'</span>);
0256             analisisObj.ensamblarVectorFuerzas();
0257             analisisObj.u = (analisisObj.Kt^-1) * analisisObj.F;
0258             analisisObj.modeloObj.actualizar(analisisObj.u);
0259             
0260             <span class="comment">% Calcula el metodo modal espectral</span>
0261             analisisObj.calcularModalEspectral(r.nModos, r.rayleighBeta, <span class="keyword">...</span>
0262                 r.rayleighModo, r.rayleighDir, r.cpenzienBeta, <span class="keyword">...</span>
0263                 maxcond, r.valvecAlgoritmo, r.valvecTolerancia, <span class="keyword">...</span>
0264                 r.muIterDespl);
0265             
0266             <span class="comment">% Termina el analisis</span>
0267             <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
0268             
0269         <span class="keyword">end</span> <span class="comment">% analizar function</span>
0270         
0271         <a name="_sub2" href="#_subfunctions" class="code">function resolverCargasDinamicas(analisisObj, varargin)</a>
0272             <span class="comment">% resolverCargasDinamicas: Resuelve las cargas dinamicas del</span>
0273             <span class="comment">% sistema</span>
0274             <span class="comment">%</span>
0275             <span class="comment">% resolverCargasDinamicas(analisisObj,varargin)</span>
0276             <span class="comment">%</span>
0277             <span class="comment">% Parametros opcionales:</span>
0278             <span class="comment">%   'activado'          Indica que se realiza el analisis</span>
0279             <span class="comment">%   'betaGrafico'       Indica si se grafica la variacion del amortiguamiento en cada iteracion</span>
0280             <span class="comment">%   'betaObjetivo'      Beta objetivo para el calculo de disipadores</span>
0281             <span class="comment">%   'cargaDisipador'    Carga objetivo disipador para el calculo de v0</span>
0282             <span class="comment">%   'cpenzien'          Usa el amortiguamiento de cpenzien (false por defecto)</span>
0283             <span class="comment">%   'disipadores'       Usa los disipadores en el calculo (false por defecto)</span>
0284             <span class="comment">%   'factorCargasD'     Factor de cargas dinamico</span>
0285             <span class="comment">%   'iterDisipador'     Numero de iteraciones para el calculo de disipadores</span>
0286             <span class="comment">%   'tolIterDisipador'  Tolerancia usada para las iteraciones del calculo de disipadores</span>
0287             
0288             <span class="keyword">if</span> ~analisisObj.analisisFinalizado
0289                 error(<span class="string">'No se puede resolver las cargas dinamicas sin haber analizado la estructura'</span>);
0290             <span class="keyword">end</span>
0291             
0292             p = inputParser;
0293             p.KeepUnmatched = true;
0294             addOptional(p, <span class="string">'activado'</span>, true);
0295             addOptional(p, <span class="string">'betaGrafico'</span>, false);
0296             addOptional(p, <span class="string">'betaObjetivo'</span>, 0);
0297             addOptional(p, <span class="string">'cargaDisipador'</span>, false);
0298             addOptional(p, <span class="string">'cpenzien'</span>, false);
0299             addOptional(p, <span class="string">'disipadores'</span>, true);
0300             addOptional(p, <span class="string">'factorCargasD'</span>, 1);
0301             addOptional(p, <span class="string">'iterDisipador'</span>, 10);
0302             addOptional(p, <span class="string">'tolIterDisipador'</span>, 0.001);
0303             parse(p, varargin{:});
0304             r = p.Results;
0305             
0306             <span class="comment">% Chequea inconsistencias</span>
0307             <span class="keyword">if</span> ~r.activado
0308                 <span class="keyword">return</span>;
0309             <span class="keyword">end</span>
0310             <span class="keyword">if</span> r.disipadores
0311                 <span class="keyword">if</span> ~isa(r.cargaDisipador, <span class="string">'CargaDinamica'</span>)
0312                     error(<span class="string">'No se ha definido cargaDisipador'</span>);
0313                 <span class="keyword">end</span>
0314                 <span class="keyword">if</span> r.iterDisipador &lt; 0
0315                     error(<span class="string">'El numero de iteraciones no puede ser menor a cero'</span>);
0316                 <span class="keyword">end</span>
0317                 <span class="keyword">if</span> r.tolIterDisipador &lt;= 0
0318                     error(<span class="string">'Tolerancia iteracion disipador invalida'</span>);
0319                 <span class="keyword">end</span>
0320             <span class="keyword">end</span>
0321             
0322             fprintf(<span class="string">'Metodo modal espectral:\n'</span>);
0323             analisisObj.modeloObj.aplicarPatronesDeCargasDinamico(r.cpenzien, r.disipadores, <span class="keyword">...</span>
0324                 r.cargaDisipador, r.betaObjetivo, analisisObj.modeloObj.obtenerDisipadores(), <span class="keyword">...</span>
0325                 r.iterDisipador, r.tolIterDisipador, r.betaGrafico, <span class="keyword">...</span>
0326                 r.factorCargasD);
0327             
0328         <span class="keyword">end</span> <span class="comment">% resolverCargasDinamicas function</span>
0329         
0330         <a name="_sub3" href="#_subfunctions" class="code">function numeroEcuaciones = obtenerNumeroEcuaciones(analisisObj)</a>
0331             <span class="comment">% obtenerNumeroEcuaciones: es un metodo de la clase ModalEspectral</span>
0332             <span class="comment">% que se usa para obtener el numero total de GDL, es decir, ecuaciones</span>
0333             <span class="comment">% del modelo</span>
0334             <span class="comment">%</span>
0335             <span class="comment">% numeroEcuaciones = obtenerNumeroEcuaciones(analisisObj)</span>
0336             <span class="comment">%</span>
0337             <span class="comment">% Obtiene el numero total de GDL (numeroEcuaciones) que esta guardado</span>
0338             <span class="comment">% en el Analisis (analisisObj)</span>
0339             
0340             numeroEcuaciones = analisisObj.numeroGDL;
0341             
0342         <span class="keyword">end</span> <span class="comment">% obtenerNumeroEcuaciones function</span>
0343         
0344         <a name="_sub4" href="#_subfunctions" class="code">function M_Modelo = obtenerMatrizMasa(analisisObj)</a>
0345             <span class="comment">% obtenerMatrizMasa: es un metodo de la clase ModalEspectral</span>
0346             <span class="comment">% que se usa para obtener la matriz de masa del modelo</span>
0347             <span class="comment">%</span>
0348             <span class="comment">% M_Modelo = obtenerMatrizRigidez(analisisObj)</span>
0349             <span class="comment">%</span>
0350             <span class="comment">% Obtiene la matriz de masa (M_Modelo) del modelo que se genero</span>
0351             <span class="comment">% en el Analisis (analisisObj)</span>
0352             
0353             M_Modelo = analisisObj.Mteq;
0354             
0355         <span class="keyword">end</span> <span class="comment">% obtenerMatrizMasa function</span>
0356         
0357         <a name="_sub5" href="#_subfunctions" class="code">function C_Modelo = obtenerMatrizAmortiguamiento(analisisObj, rayleigh)</a>
0358             <span class="comment">% obtenerMatrizAmortiguamiento: es un metodo de la clase ModalEspectral</span>
0359             <span class="comment">% que se usa para obtener la matriz de amortiguamiento del modelo</span>
0360             <span class="comment">%</span>
0361             <span class="comment">% C_Modelo = obtenerMatrizAmortiguamiento(analisisObj,rayleigh)</span>
0362             <span class="comment">%</span>
0363             <span class="comment">% Obtiene la matriz de amortiguamiento (C_Modelo) del modelo que se genero</span>
0364             <span class="comment">% en el Analisis (analisisObj)</span>
0365             
0366             <span class="keyword">if</span> rayleigh
0367                 C_Modelo = analisisObj.cRayleigh;
0368             <span class="keyword">else</span>
0369                 C_Modelo = analisisObj.cPenzien;
0370             <span class="keyword">end</span>
0371             
0372         <span class="keyword">end</span> <span class="comment">% obtenerMatrizAmortiguamiento function</span>
0373         
0374         <a name="_sub6" href="#_subfunctions" class="code">function K_Modelo = obtenerMatrizRigidez(analisisObj)</a>
0375             <span class="comment">% obtenerMatrizRigidez: es un metodo de la clase ModalEspectral</span>
0376             <span class="comment">% que se usa para obtener la matriz de rigidez del modelo</span>
0377             <span class="comment">%</span>
0378             <span class="comment">% K_Modelo = obtenerMatrizRigidez(analisisObj)</span>
0379             <span class="comment">%</span>
0380             <span class="comment">% Obtiene la matriz de rigidez (K_Modelo) del modelo que se genero</span>
0381             <span class="comment">% en el Analisis (analisisObj)</span>
0382             
0383             K_Modelo = analisisObj.Kteq;
0384             
0385         <span class="keyword">end</span> <span class="comment">% obtenerMatrizRigidez function</span>
0386         
0387         <a name="_sub7" href="#_subfunctions" class="code">function Cdv_Modelo = obtenerMatrizAmortiguamientoDisipadores(analisisObj)</a>
0388             <span class="comment">% obtenerMatrizRigidez: es un metodo de la clase ModalEspectral</span>
0389             <span class="comment">% que se usa para obtener la matriz de amortiguamiento del modelo</span>
0390             <span class="comment">% producto de los disipadores incorporados</span>
0391             <span class="comment">%</span>
0392             <span class="comment">% Cdv_Modelo = obtenerMatrizAmortiguamientoDisipadores(analisisObj)</span>
0393             <span class="comment">%</span>
0394             <span class="comment">% Obtiene la matriz de amortiguamiento del modelo</span>
0395             
0396             Cdv_Modelo = analisisObj.ensamblarMatrizAmortiguamientoDisipadores();
0397             
0398         <span class="keyword">end</span> <span class="comment">% obtenerMatrizAmortiguamientoDisipadores function</span>
0399         
0400         <a name="_sub8" href="#_subfunctions" class="code">function Kdv_Modelo = obtenerMatrizRigidezDisipadores(analisisObj)</a>
0401             <span class="comment">% obtenerMatrizRigidezDisipadores: es un metodo de la clase ModalEspectral</span>
0402             <span class="comment">% que se usa para obtener la matriz de rigidez de los</span>
0403             <span class="comment">% disipadores</span>
0404             <span class="comment">%</span>
0405             <span class="comment">% Kdv_Modelo = obtenerMatrizRigidezDisipadores(analisisObj)</span>
0406             
0407             Kdv_Modelo = analisisObj.ensamblarMatrizRigidezDisipadores();
0408             
0409         <span class="keyword">end</span> <span class="comment">% obtenerMatrizRigidezDisipadores function</span>
0410         
0411         <a name="_sub9" href="#_subfunctions" class="code">function r_Modelo = obtenerVectorInfluencia(analisisObj)</a>
0412             <span class="comment">% obtenerVectorInfluencia: es un metodo de la clase ModalEspectral</span>
0413             <span class="comment">% que se usa para obtener el vector de influencia del modelo</span>
0414             <span class="comment">%</span>
0415             <span class="comment">% r_Modelo = obtenerVectorInfluencia(analisisObj)</span>
0416             <span class="comment">%</span>
0417             <span class="comment">% Obtiene el vector de influencia (r) del modelo que se genero</span>
0418             <span class="comment">% en el Analisis (analisisObj)</span>
0419             
0420             r_Modelo = analisisObj.rm;
0421             
0422         <span class="keyword">end</span> <span class="comment">% obtenerVectorInfluencia function</span>
0423         
0424         <a name="_sub10" href="#_subfunctions" class="code">function F_Modelo = obtenerVectorFuerzas(analisisObj)</a>
0425             <span class="comment">% obtenerMatrizRigidez: es un metodo de la clase ModalEspectral</span>
0426             <span class="comment">% que se usa para obtener el vector de fuerza del modelo</span>
0427             <span class="comment">%</span>
0428             <span class="comment">% F_Modelo = obtenerVectorFuerzas(analisisObj)</span>
0429             <span class="comment">%</span>
0430             <span class="comment">% Obtiene el vector de fuerza (F_Modelo) del modelo que se genero</span>
0431             <span class="comment">% en el Analisis (analisisObj)</span>
0432             
0433             F_Modelo = analisisObj.F;
0434             
0435         <span class="keyword">end</span> <span class="comment">% obtenerVectorFuerzas function</span>
0436         
0437         <a name="_sub11" href="#_subfunctions" class="code">function u_Modelo = obtenerDesplazamientos(analisisObj)</a>
0438             <span class="comment">% obtenerDesplazamientos: es un metodo de la clase ModalEspectral</span>
0439             <span class="comment">% que se usa para obtener el vector de desplazamiento del modelo</span>
0440             <span class="comment">% obtenido del analisis</span>
0441             <span class="comment">%</span>
0442             <span class="comment">% u_Modelo = obtenerDesplazamientos(analisisObj)</span>
0443             <span class="comment">%</span>
0444             <span class="comment">% Obtiene el vector de desplazamiento (u_Modelo) del modelo que se</span>
0445             <span class="comment">% genero como resultado del Analisis (analisisObj)</span>
0446             
0447             u_Modelo = analisisObj.u;
0448             
0449         <span class="keyword">end</span> <span class="comment">% obtenerDesplazamientos function</span>
0450         
0451         <a name="_sub12" href="#_subfunctions" class="code">function wn_Modelo = obtenerValoresPropios(analisisObj)</a>
0452             <span class="comment">% obtenerValoresPropios: es un metodo de la clase ModalEspectral</span>
0453             <span class="comment">% que se usa para obtener los valores propios del modelo</span>
0454             <span class="comment">% obtenido del analisis</span>
0455             <span class="comment">%</span>
0456             <span class="comment">% w_Modelo = obtenerValoresPropios(analisisObj)</span>
0457             <span class="comment">%</span>
0458             <span class="comment">% Obtiene los valores propios (wn_Modelo) del modelo que se</span>
0459             <span class="comment">% genero como resultado del Analisis (analisisObj)</span>
0460             
0461             wn_Modelo = analisisObj.wn;
0462             
0463         <span class="keyword">end</span> <span class="comment">% obtenerValoresPropios function</span>
0464         
0465         <a name="_sub13" href="#_subfunctions" class="code">function phi_Modelo = obtenerMatrizPhi(analisisObj)</a>
0466             <span class="comment">% obtenerMatrizPhi: es un metodo de la clase ModalEspectral</span>
0467             <span class="comment">% que se usa para obtener los vectores propios del modelo</span>
0468             <span class="comment">% obtenido del analisis</span>
0469             <span class="comment">%</span>
0470             <span class="comment">% phi_Modelo = obtenerMatrizPhi(analisisObj)</span>
0471             <span class="comment">%</span>
0472             <span class="comment">% Obtiene los vectores propios (phi_Modelo) del modelo que se</span>
0473             <span class="comment">% genero como resultado del Analisis (analisisObj)</span>
0474             
0475             phi_Modelo = analisisObj.phin;
0476             
0477         <span class="keyword">end</span> <span class="comment">% obtenerMatrizPhi function</span>
0478         
0479         <a name="_sub14" href="#_subfunctions" class="code">function plt = plot(analisisObj, varargin)</a>
0480             <span class="comment">% plot: Grafica el modelo</span>
0481             <span class="comment">%</span>
0482             <span class="comment">% plt = plot(analisisObj,'var1',val1,'var2',val2)</span>
0483             <span class="comment">%</span>
0484             <span class="comment">% Parametros opcionales:</span>
0485             <span class="comment">%   '3dAngAzh'          Angulo azimutal grafico 3D</span>
0486             <span class="comment">%   '3dAngPol'          Angulo polar grafico 3D</span>
0487             <span class="comment">%   'colorDisipador'    Color del disipador</span>
0488             <span class="comment">%   'cuadros'           Numero de cuadros de la animacion</span>
0489             <span class="comment">%   'defElem'           Dibuja la deformada de cada elemento</span>
0490             <span class="comment">%   'disipador'         Dibuja los disipadores</span>
0491             <span class="comment">%   'factor'            Escala de la deformacion</span>
0492             <span class="comment">%   'gif'               Archivo en el que se guarda la animacion</span>
0493             <span class="comment">%   'lwDisipador'       Ancho linea disipador</span>
0494             <span class="comment">%   'lwElemD'           Ancho linea elemento dinamico</span>
0495             <span class="comment">%   'lwElemE'           Ancho linea elemento estatico</span>
0496             <span class="comment">%   'modo'              Numero de modo a graficar</span>
0497             <span class="comment">%   'mostrarEstatico'   Dibuja la estructura estatica al animar</span>
0498             <span class="comment">%   'sizeNodoE'         Porte nodo dinamico</span>
0499             <span class="comment">%   'sizeNodoE'         Porte nodo estatico</span>
0500             <span class="comment">%   'styleDisipador'    Estilo linea disipador</span>
0501             <span class="comment">%   'styleElemD'        Estilo elemento dinamico</span>
0502             <span class="comment">%   'styleElemE'        Estilo elemento estatico</span>
0503             <span class="comment">%   'styleNodoD'        Estilo nodo dinamico</span>
0504             <span class="comment">%   'styleNodoE'        Estilo nodo estatico</span>
0505             <span class="comment">%   'tmax'              Tiempo maximo al graficar cargas</span>
0506             <span class="comment">%   'tmin'              Tiempo minimo al graficar cargas</span>
0507             <span class="comment">%   'unidad'            Unidad de longitud</span>
0508             
0509             <span class="comment">% Establece variables iniciales</span>
0510             fprintf(<span class="string">'Generando animacion analisis modal espectral:\n'</span>);
0511             p = inputParser;
0512             p.KeepUnmatched = true;
0513             addOptional(p, <span class="string">'angAzh'</span>, 45);
0514             addOptional(p, <span class="string">'angPol'</span>, 45);
0515             addOptional(p, <span class="string">'carga'</span>, false);
0516             addOptional(p, <span class="string">'colorDisipador'</span>, <span class="string">'r'</span>);
0517             addOptional(p, <span class="string">'cuadros'</span>, 0);
0518             addOptional(p, <span class="string">'defElem'</span>, false);
0519             addOptional(p, <span class="string">'disipadores'</span>, true);
0520             addOptional(p, <span class="string">'factor'</span>, 1);
0521             addOptional(p, <span class="string">'gif'</span>, <span class="string">''</span>);
0522             addOptional(p, <span class="string">'lwDisipador'</span>, 1.3);
0523             addOptional(p, <span class="string">'lwElemD'</span>, 1.2);
0524             addOptional(p, <span class="string">'lwElemE'</span>, 0.5);
0525             addOptional(p, <span class="string">'modo'</span>, 0);
0526             addOptional(p, <span class="string">'mostrarEstatico'</span>, analisisObj.mostrarDeformada);
0527             addOptional(p, <span class="string">'sizeNodoD'</span>, 10);
0528             addOptional(p, <span class="string">'sizeNodoE'</span>, 5);
0529             addOptional(p, <span class="string">'styleDisipador'</span>, <span class="string">'--'</span>);
0530             addOptional(p, <span class="string">'styleElemD'</span>, <span class="string">'k-'</span>);
0531             addOptional(p, <span class="string">'styleElemE'</span>, <span class="string">'b-'</span>);
0532             addOptional(p, <span class="string">'styleNodoD'</span>, <span class="string">'k'</span>);
0533             addOptional(p, <span class="string">'styleNodoE'</span>, <span class="string">'b'</span>);
0534             addOptional(p, <span class="string">'tmax'</span>, -1);
0535             addOptional(p, <span class="string">'tmin'</span>, 0);
0536             addOptional(p, <span class="string">'unidad'</span>, <span class="string">'m'</span>);
0537             parse(p, varargin{:});
0538             r = p.Results;
0539             modo = floor(r.modo);
0540             factor = r.factor;
0541             numCuadros = floor(r.cuadros);
0542             guardaGif = r.gif;
0543             defElem = r.defElem;
0544             carga = r.carga;
0545             defCarga = false; <span class="comment">% Indica que la deformada se obtiene a partir de la carga</span>
0546             mostrarEstatico = r.mostrarEstatico;
0547             disipadores = r.disipadores;
0548             
0549             <span class="comment">% Tiempos</span>
0550             tmin = max(0, r.tmin);
0551             tmax = r.tmax;
0552             tinicial = cputime;
0553             
0554             <span class="comment">% Verificaciones si se grafica una carga</span>
0555             <span class="keyword">if</span> carga ~= false
0556                 
0557                 <span class="keyword">if</span> ~(isa(carga, <span class="string">'CargaDinamica'</span>) || isa(carga, <span class="string">'CombinacionCargas'</span>))
0558                     error(<span class="string">'Solo se pueden graficar cargas dinamicas o combinaciones de cargas'</span>);
0559                 <span class="keyword">end</span>
0560                 <span class="keyword">if</span> isempty(carga.obtenerDesplazamiento())
0561                     error(<span class="string">'No se ha resuelto la carga, no es posible graficar'</span>);
0562                 <span class="keyword">end</span>
0563                 <span class="keyword">if</span> modo ~= 0
0564                     error(<span class="string">'No se puede graficar un modo y una carga de manera simultanea'</span>);
0565                 <span class="keyword">end</span>
0566                 <span class="keyword">if</span> numCuadros &lt;= 0
0567                     error(<span class="string">'Se debe especificar el numero de cuadros'</span>);
0568                 <span class="keyword">end</span>
0569                 <span class="keyword">if</span> tmax &gt; carga.tAnalisis
0570                     fprintf(<span class="string">'\tSe ha limitado el tiempo maximo de la carga a %.2fs\n'</span>, carga.tAnalisis);
0571                     tmax = carga.tAnalisis;
0572                 <span class="keyword">elseif</span> tmax &lt; carga.tAnalisis
0573                     fprintf(<span class="string">'\tLa carga se graficara a un tiempo menor que el computado originalmente\n'</span>);
0574                 <span class="keyword">end</span>
0575                 <span class="keyword">if</span> tmax &lt;= 0
0576                     tmax = carga.tAnalisis;
0577                 <span class="keyword">end</span>
0578                 <span class="keyword">if</span> tmin &gt;= tmax
0579                     error(<span class="string">'El tiempo de analisis minimo no puede exceder al maximo'</span>);
0580                 <span class="keyword">end</span>
0581                 
0582                 <span class="comment">% Compara los dt</span>
0583                 dt_plot = (tmax - tmin) / numCuadros;
0584                 dt_real = carga.dt;
0585                 
0586                 <span class="comment">% Si el dt del grafico es menor se reajustan los cuadros</span>
0587                 <span class="keyword">if</span> dt_plot &lt; dt_real
0588                     warning(<span class="string">'El numero de cuadros genera un dt=%.3f inferior al dt=%.3f de la carga %s'</span>, <span class="keyword">...</span>
0589                         dt_plot, dt_real, carga.obtenerEtiqueta());
0590                     
0591                     <span class="comment">% Se limitan los cuadros</span>
0592                     numCuadros = floor((tmax - tmin)/dt_real);
0593                     fprintf(<span class="string">'\tSe ha limitado el numero de cuadros a %d\n'</span>, numCuadros);
0594                 <span class="keyword">elseif</span> dt_plot == dt_real
0595                     fprintf(<span class="string">'\tEl numero de cuadros genera un dt igual al de la carga\n'</span>);
0596                 <span class="keyword">else</span>
0597                     fprintf(<span class="string">'\tEl numero de cuadros genera un dt=%.3f superior al de la carga, superior en %.1f veces\n'</span>, <span class="keyword">...</span>
0598                         dt_plot, dt_plot/dt_real);
0599                     dt_plot_max_factor = 10; <span class="comment">% Factor maximo de los cuadros</span>
0600                     <span class="keyword">if</span> dt_plot / dt_real &gt; dt_plot_max_factor
0601                         fprintf(<span class="string">'\t\tNo se recomienda que este factor exceda de %d, usar numero de cuadros igual a %d\n'</span>, <span class="keyword">...</span>
0602                             dt_plot_max_factor, floor((tmax - tmin)/(dt_plot_max_factor * dt_real)));
0603                     <span class="keyword">end</span>
0604                 <span class="keyword">end</span>
0605                 
0606                 <span class="comment">% Crea el vector de tiempos de analisis</span>
0607                 tCargaEq = linspace(tmin, tmax, numCuadros);
0608                 
0609                 <span class="comment">% Busca las posiciones asociadas a la carga</span>
0610                 cargaTArr = linspace(0, carga.tAnalisis, carga.tAnalisis/carga.dt);
0611                 tCargaPos = zeros(1, numCuadros); <span class="comment">% Guarda los tiempos de 'snapshot' de la carga</span>
0612                 
0613                 i = 1;
0614                 <span class="keyword">for</span> j = 1:length(cargaTArr)
0615                     <span class="keyword">if</span> cargaTArr(j) &gt;= tCargaEq(i)
0616                         tCargaPos(i) = j;
0617                         i = i + 1;
0618                     <span class="keyword">end</span>
0619                     <span class="keyword">if</span> i &gt; numCuadros
0620                         <span class="keyword">break</span>;
0621                     <span class="keyword">end</span>
0622                 <span class="keyword">end</span> <span class="comment">% for j</span>
0623                 
0624                 <span class="comment">% Activa la deformada por carga</span>
0625                 defCarga = true;
0626                 fprintf(<span class="string">'\tSe graficara la carga %s desde ti=%.3f a tf=%.3f con dt=%.3f\n'</span>, <span class="keyword">...</span>
0627                     carga.obtenerEtiqueta(), tmin, tmax, dt_plot);
0628                 
0629             <span class="keyword">else</span>
0630                 
0631                 <span class="comment">% No se grafican cargas</span>
0632                 tCargaPos = zeros(1, numCuadros);
0633                 tCargaEq = zeros(1, numCuadros);
0634                 
0635             <span class="keyword">end</span>
0636             
0637             <span class="comment">% Chequea deformada</span>
0638             deformada = false;
0639             modo = ceil(modo);
0640             <span class="keyword">if</span> exist(<span class="string">'modo'</span>, <span class="string">'var'</span>) &amp;&amp; modo &gt; 0
0641                 deformada = true;
0642             <span class="keyword">end</span>
0643             deformada = deformada || defCarga;
0644             
0645             <span class="comment">% Grafica la estructura si no se ha ejecutado el analisis</span>
0646             <span class="keyword">if</span> (~analisisObj.analisisFinalizado || modo &lt;= 0) &amp;&amp; ~defCarga
0647                 plt = figure(<span class="string">'Name'</span>, sprintf(<span class="string">'Plot %s'</span>, analisisObj.modeloObj.obtenerNombre()), <span class="keyword">...</span>
0648                     <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
0649                 movegui(<span class="string">'center'</span>);
0650                 hold on;
0651                 grid on;
0652                 [limx, limy, limz] = analisisObj.obtenerLimitesDeformada(0, factor, defCarga, carga);
0653                 <a href="#_sub37" class="code" title="subfunction plotAnimado(analisisObj, deformada, modo, factor, phif, limx, limy, limz, ">plotAnimado</a>(analisisObj, false, 0, factor, 0, limx, limy, limz, <span class="keyword">...</span>
0654                     0, 1, 1, defElem, defCarga, carga, 1, tCargaEq, mostrarEstatico, disipadores, <span class="keyword">...</span>
0655                     r.styleNodoE, r.sizeNodoE, r.styleNodoD, r.sizeNodoD, r.styleElemE, r.lwElemE, <span class="keyword">...</span>
0656                     r.styleElemD, r.lwElemD, r.styleDisipador, r.colorDisipador, r.lwDisipador, <span class="keyword">...</span>
0657                     r.unidad, r.angAzh, r.angPol);
0658                 figure(plt);
0659                 <span class="keyword">return</span>;
0660             <span class="keyword">end</span>
0661             
0662             <span class="comment">% Guarda gif</span>
0663             guardarGif = false;
0664             <span class="keyword">if</span> exist(<span class="string">'guardaGif'</span>, <span class="string">'var'</span>) &amp;&amp; ~strcmp(guardaGif, <span class="string">''</span>)
0665                 guardarGif = true;
0666                 guardaGif = sprintf(guardaGif, modo);
0667             <span class="keyword">else</span>
0668                 guardaGif = tempname;
0669             <span class="keyword">end</span>
0670             
0671             <span class="keyword">if</span> (modo &gt; analisisObj.numModos || modo &lt;= 0) &amp;&amp; ~defCarga
0672                 error(<span class="string">'El modo a graficar %d excede la cantidad de modos del sistema (%d)'</span>, <span class="keyword">...</span>
0673                     modo, analisisObj.numModos);
0674             <span class="keyword">end</span>
0675             
0676             <span class="comment">% Obtiene el periodo</span>
0677             <span class="keyword">if</span> ~defCarga
0678                 tn = analisisObj.Tn(modo);
0679             <span class="keyword">else</span>
0680                 tn = 0;
0681             <span class="keyword">end</span>
0682             
0683             <span class="comment">% Calcula los limites</span>
0684             [limx, limy, limz] = analisisObj.obtenerLimitesDeformada(modo, factor, defCarga, carga);
0685             
0686             <span class="comment">% Grafica la estructura</span>
0687             <span class="keyword">if</span> modo ~= 0
0688                 fig_nom = sprintf(<span class="string">'Plot %s - Modo %d'</span>, analisisObj.modeloObj.obtenerNombre(), <span class="keyword">...</span>
0689                     modo);
0690             <span class="keyword">else</span>
0691                 fig_nom = sprintf(<span class="string">'Plot %s - Carga %s'</span>, analisisObj.modeloObj.obtenerNombre(), <span class="keyword">...</span>
0692                     carga.obtenerEtiqueta());
0693             <span class="keyword">end</span>
0694             plt = figure(<span class="string">'Name'</span>, fig_nom, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
0695             fig_num = get(gcf, <span class="string">'Number'</span>);
0696             movegui(<span class="string">'center'</span>);
0697             hold on;
0698             grid on;
0699             <span class="comment">% axis tight manual;</span>
0700             <span class="comment">% set(gca, 'nextplot', 'replacechildren');</span>
0701             
0702             <span class="comment">% Imprime mensajes en consola</span>
0703             <span class="keyword">if</span> defElem
0704                 fprintf(<span class="string">'\tSe ha activado la deformada de los elementos\n'</span>);
0705             <span class="keyword">end</span>
0706             <span class="keyword">if</span> guardarGif &amp;&amp; numCuadros ~= 0
0707                 fprintf(<span class="string">'\tEl proceso generara un archivo gif\n'</span>);
0708             <span class="keyword">end</span>
0709             
0710             <span class="comment">% Grafica el sistema</span>
0711             <span class="keyword">if</span> numCuadros &lt;= 0
0712                 fprintf(<span class="string">'\tSe grafica el caso con la deformacion maxima\n'</span>);
0713                 <a href="#_sub37" class="code" title="subfunction plotAnimado(analisisObj, deformada, modo, factor, phif, limx, limy, limz, ">plotAnimado</a>(analisisObj, deformada, modo, factor, 1, <span class="keyword">...</span>
0714                     limx, limy, limz, tn, 1, 1, defElem, defCarga, carga, <span class="keyword">...</span>
0715                     1, tCargaEq, mostrarEstatico, disipadores, r.styleNodoE, <span class="keyword">...</span>
0716                     r.sizeNodoE, r.styleNodoD, r.sizeNodoD, r.styleElemE, <span class="keyword">...</span>
0717                     r.lwElemE, r.styleElemD, r.lwElemD, r.styleDisipador, <span class="keyword">...</span>
0718                     r.colorDisipador, r.lwDisipador, r.unidad, <span class="keyword">...</span>
0719                     r.angAzh, r.angPol);
0720                 fprintf(<span class="string">'\tProceso finalizado en %.2f segundos\n'</span>, cputime-tinicial);
0721             <span class="keyword">else</span>
0722                 <a href="#_sub37" class="code" title="subfunction plotAnimado(analisisObj, deformada, modo, factor, phif, limx, limy, limz, ">plotAnimado</a>(analisisObj, deformada, modo, factor, 0, <span class="keyword">...</span>
0723                     limx, limy, limz, tn, 1, 1, defElem, defCarga, <span class="keyword">...</span>
0724                     carga, tCargaPos(1), tCargaEq, mostrarEstatico, disipadores, <span class="keyword">...</span>
0725                     r.styleNodoE, r.sizeNodoE, r.styleNodoD, r.sizeNodoD, <span class="keyword">...</span>
0726                     r.styleElemE, r.lwElemE, r.styleElemD, r.lwElemD, <span class="keyword">...</span>
0727                     r.styleDisipador, r.colorDisipador, r.lwDisipador, <span class="keyword">...</span>
0728                     r.unidad, r.angAzh, r.angPol);
0729                 hold off;
0730                 
0731                 <span class="comment">% Obtiene el numero de cuadros</span>
0732                 t = 0;
0733                 dt = 2 * pi() / numCuadros;
0734                 reverse_porcent = <span class="string">''</span>;
0735                 
0736                 <span class="comment">% Crea la estructura de cuadros</span>
0737                 Fr(numCuadros) = struct(<span class="string">'cdata'</span>, [], <span class="string">'colormap'</span>, []);
0738                 
0739                 <span class="keyword">for</span> i = 1:numCuadros
0740                     
0741                     <span class="comment">% Si el usuario cierra el plot termina de graficar</span>
0742                     <span class="keyword">if</span> ~ishandle(plt) || ~ishghandle(plt)
0743                         delete(plt);
0744                         close(fig_num); <span class="comment">% Cierra el grafico</span>
0745                         fprintf(<span class="string">'\n\tSe ha cancelado el proceso del grafico\n'</span>);
0746                         <span class="keyword">return</span>;
0747                     <span class="keyword">end</span>
0748                     
0749                     t = t + dt;
0750                     <span class="keyword">try</span>
0751                         <span class="comment">% figure(fig_num); % Atrapa el foco</span>
0752                         <a href="#_sub37" class="code" title="subfunction plotAnimado(analisisObj, deformada, modo, factor, phif, limx, limy, limz, ">plotAnimado</a>(analisisObj, deformada, modo, factor, sin(t), <span class="keyword">...</span>
0753                             limx, limy, limz, tn, i, numCuadros, defElem, defCarga, <span class="keyword">...</span>
0754                             carga, tCargaPos(i), tCargaEq, mostrarEstatico, disipadores, <span class="keyword">...</span>
0755                             r.styleNodoE, r.sizeNodoE, r.styleNodoD, r.sizeNodoD, <span class="keyword">...</span>
0756                             r.styleElemE, r.lwElemE, r.styleElemD, r.lwElemD, <span class="keyword">...</span>
0757                             r.styleDisipador, r.colorDisipador, r.lwDisipador, <span class="keyword">...</span>
0758                             r.unidad, r.angAzh, r.angPol);
0759                         drawnow;
0760                         Fr(i) = getframe(plt);
0761                         im = frame2im(Fr(i));
0762                         [imind, cm] = rgb2ind(im, 256);
0763                         <span class="keyword">if</span> i == 1
0764                             imwrite(imind, cm, guardaGif, <span class="string">'gif'</span>, <span class="string">'Loopcount'</span>, inf, <span class="string">'DelayTime'</span>, 0.1);
0765                         <span class="keyword">else</span>
0766                             imwrite(imind, cm, guardaGif, <span class="string">'gif'</span>, <span class="string">'WriteMode'</span>, <span class="string">'append'</span>, <span class="string">'DelayTime'</span>, 0.1);
0767                         <span class="keyword">end</span>
0768                     <span class="keyword">catch</span> <span class="comment">%#ok&lt;*CTCH&gt;</span>
0769                         fprintf(<span class="string">'\n\tSe ha cancelado el proceso del grafico\n'</span>);
0770                         <span class="keyword">return</span>;
0771                     <span class="keyword">end</span>
0772                     hold off;
0773                     
0774                     msg = sprintf(<span class="string">'\tGraficando ... %.1f/100'</span>, i/numCuadros*100);
0775                     fprintf([reverse_porcent, msg]);
0776                     reverse_porcent = repmat(sprintf(<span class="string">'\b'</span>), 1, length(msg));
0777                     
0778                 <span class="keyword">end</span> <span class="comment">% for i</span>
0779                 
0780                 <span class="keyword">if</span> guardarGif
0781                     fprintf(<span class="string">'\n\tGuardando animacion gif en: %s\n'</span>, guardaGif);
0782                 <span class="keyword">end</span>
0783                 
0784                 <span class="comment">% Imprime en consola el tiempo que se demoro el proceso</span>
0785                 fprintf(<span class="string">'\tProceso finalizado en %.2f segundos\n'</span>, cputime-tinicial);
0786                 
0787                 <span class="comment">% Reproduce la pelicula y cierra el grafico anterior</span>
0788                 close(fig_num);
0789                 <span class="keyword">if</span> analisisObj.cargarAnimacion
0790                     fprintf(<span class="string">'\n\tAbriendo animacion\n'</span>);
0791                     <span class="keyword">try</span>
0792                         <a href="../../tefame/lib/gifPlayerGUI.html" class="code" title="function gifPlayerGUI(fname, delayTime)">gifPlayerGUI</a>(guardaGif, 1/min(numCuadros, 60));
0793                     <span class="keyword">catch</span>
0794                         error(<span class="string">'Ha ocurrido un error al abrir el gif generado'</span>);
0795                     <span class="keyword">end</span>
0796                 <span class="keyword">else</span>
0797                     fprintf(<span class="string">'\n'</span>);
0798                 <span class="keyword">end</span>
0799                 
0800                 <span class="comment">% Cierra la linea</span>
0801                 <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
0802                 
0803             <span class="keyword">end</span>
0804             
0805         <span class="keyword">end</span> <span class="comment">% plot function</span>
0806         
0807         <a name="_sub15" href="#_subfunctions" class="code">function guardarResultados(analisisObj, nombreArchivo, cargas)</a>
0808             <span class="comment">% guardarResultados: Guarda resultados adicionales del analisis</span>
0809             <span class="comment">%</span>
0810             <span class="comment">% guardarResultados(analisisObj,nombreArchivo,cargas)</span>
0811             
0812             <span class="comment">% Abre el archivo donde se guardara la informacion</span>
0813             <span class="keyword">try</span>
0814                 archivoSalida = fopen(nombreArchivo, <span class="string">'a'</span>);
0815             <span class="keyword">catch</span>
0816                 error(<span class="string">'No se puede abrir el archivo %s'</span>, nombreArchivo);
0817             <span class="keyword">end</span>
0818             
0819             <span class="comment">% Chequea que cargas sea un cell de cargas dinamicas</span>
0820             <span class="keyword">if</span> ~exist(<span class="string">'cargas'</span>, <span class="string">'var'</span>) || isempty(cargas)
0821                 error(<span class="string">'Cargas debe ser un cell de cargas dinamicas no nulo'</span>);
0822             <span class="keyword">end</span>
0823             
0824             <span class="comment">% Chequea que cada elemento de cargas dinamicas sea una carga</span>
0825             <span class="comment">% dinamica</span>
0826             <span class="keyword">for</span> i=1:length(cargas)
0827                 <span class="keyword">if</span> ~isa(cargas{i}, <span class="string">'CargaDinamica'</span>)
0828                     error(<span class="string">'Elemento %d del cell de cargas no es un objeto de CargaDinamica'</span>, i);
0829                 <span class="keyword">end</span>
0830             <span class="keyword">end</span> <span class="comment">% for i</span>
0831             
0832             fprintf(<span class="string">'Calculando resultados analisis dinamico\n'</span>);
0833             fprintf(archivoSalida, <span class="string">'\n'</span>);
0834             fprintf(archivoSalida, <span class="string">'-------------------------------------------------------------------------------\n'</span>);
0835             fprintf(archivoSalida, <span class="string">'Resultados del analisis dinamico\n'</span>);
0836             fprintf(archivoSalida, <span class="string">'-------------------------------------------------------------------------------\n'</span>);
0837             fprintf(archivoSalida, <span class="string">'\n'</span>);
0838             
0839             <span class="comment">% Guarda las cargas maximas de los elementos</span>
0840             elementos = analisisObj.modeloObj.obtenerElementos();
0841             
0842             <span class="comment">% Estado</span>
0843             totproc = length(elementos) * length(cargas);
0844             reverse_porcent = <span class="string">''</span>;
0845             k = 1; <span class="comment">% Contador total</span>
0846             
0847             <span class="keyword">for</span> i=1:length(elementos)
0848                 
0849                 fprintf(archivoSalida, <span class="string">'Elemento: %s\n'</span>, elementos{i}.obtenerEtiqueta());
0850                 <span class="comment">% Recorre cada carga dinamica</span>
0851                 <span class="keyword">for</span> j=1:length(cargas)
0852                     
0853                     <span class="keyword">if</span> ~cargas{j}.cargaCalculada()
0854                         fprintf(archivoSalida, <span class="string">'\tCarga %s no fue calculada\n'</span>, <span class="keyword">...</span>
0855                             cargas{j}.obtenerEtiqueta());
0856                         <span class="keyword">continue</span>;
0857                     <span class="keyword">end</span>
0858                     
0859                     <span class="keyword">if</span> ~cargas{j}.cargaCalculada()
0860                         fprintf(archivoSalida, <span class="string">'\tCarga %s no fue calculada\n'</span>, <span class="keyword">...</span>
0861                             cargas{j}.obtenerEtiqueta());
0862                         <span class="keyword">continue</span>;
0863                     <span class="keyword">end</span>
0864                     
0865                     fprintf(archivoSalida, <span class="string">'\tCarga: %s\n'</span>, cargas{j}.obtenerEtiqueta());
0866                     elmEsf = analisisObj.calcularEsfuerzosElemento(cargas{j}, elementos{i}, 0);
0867                     elmEsf = <a href="../../tefame/lib/arrayNum2str.html" class="code" title="function textCell = arrayNum2str(a, num)">arrayNum2str</a>(elmEsf);
0868                     fprintf(archivoSalida, <span class="string">'\t\tEsfuerzos: %s\n'</span>, [elmEsf{:}]); 
0869                     
0870                     <span class="comment">% Imprime estado</span>
0871                     msg = sprintf(<span class="string">'\tCalculando ... %.1f/100'</span>, k/totproc*100);
0872                     fprintf([reverse_porcent, msg]);
0873                     reverse_porcent = repmat(sprintf(<span class="string">'\b'</span>), 1, length(msg));
0874                     k = k + 1;
0875                     
0876                 <span class="keyword">end</span> <span class="comment">% for j</span>
0877                 
0878             <span class="keyword">end</span> <span class="comment">% for i</span>
0879             fprintf(<span class="string">'\n'</span>);
0880             <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
0881             
0882             <span class="comment">% Cierra el archivo</span>
0883             fclose(archivoSalida);
0884             
0885         <span class="keyword">end</span> <span class="comment">% guardarResultados function</span>
0886         
0887         <a name="_sub16" href="#_subfunctions" class="code">function calcularDesplazamientoDrift(analisisObj, carga, xanalisis, varargin)</a>
0888             <span class="comment">% calcularDesplazamientoDrift: Funcion que calcula el desplazamiento y</span>
0889             <span class="comment">% drift a partir de una carga</span>
0890             <span class="comment">%</span>
0891             <span class="comment">% calcularDesplazamientoDrift(analisisObj,carga,xanalisis,varargin)</span>
0892             <span class="comment">%</span>
0893             <span class="comment">% Parametros opcionales:</span>
0894             <span class="comment">%   'unidad'        Unidad de largo</span>
0895             
0896             <span class="comment">% Inicia proceso</span>
0897             tinicial = cputime;
0898             
0899             <span class="comment">% Define variables opcionales</span>
0900             p = inputParser;
0901             p.KeepUnmatched = true;
0902             addOptional(p, <span class="string">'unidad'</span>, <span class="string">'m'</span>);
0903             parse(p, varargin{:});
0904             r = p.Results;
0905             
0906             <span class="comment">% Verifica que la carga se haya calculado</span>
0907             <span class="keyword">if</span> ~(isa(carga, <span class="string">'CargaDinamica'</span>) || isa(carga, <span class="string">'CombinacionCargas'</span>))
0908                 error(<span class="string">'Solo se pueden graficar cargas dinamicas o combinaciones de cargas'</span>);
0909             <span class="keyword">end</span>
0910             desp = carga.obtenerDesplazamiento();
0911             <span class="keyword">if</span> ~carga.cargaCalculada()
0912                 error(<span class="string">'La carga %s no se ha calculado'</span>, carga.obtenerEtiqueta());
0913             <span class="keyword">end</span>
0914             
0915             fprintf(<span class="string">'Calculando desplazamiento y drift:\n'</span>);
0916             ctitle = analisisObj.imprimirPropiedadesAnalisisCarga(carga);
0917             
0918             <span class="comment">% Se genera vector en que las filas contienen nodos en un mismo piso,</span>
0919             <span class="comment">% rellenando con ceros la matriz en caso de diferencia de nodos por piso.</span>
0920             <span class="comment">% Tambien se genera vector que contiene alturas de piso</span>
0921             nodos = analisisObj.modeloObj.obtenerNodos();
0922             nnodos = length(nodos);
0923             habs = zeros(1, 1);
0924             hNodos = zeros(1, 1);
0925             
0926             j = 1;
0927             k = 1;
0928             l = 1;
0929             ini = 1;
0930             ndrift = [];
0931             <span class="keyword">for</span> i = 1:nnodos
0932                 CoordNodo = nodos{i}.obtenerCoordenadas;
0933                 xNodo = CoordNodo(1);
0934                 yNodo = CoordNodo(2);
0935                 <span class="keyword">if</span> yNodo ~= habs(j)
0936                     k = 1;
0937                     j = j + 1;
0938                     habs(j, 1) = yNodo;
0939                     hNodos(j, k) = i;
0940                 <span class="keyword">elseif</span> i == 1
0941                     hNodos(j, k) = i;
0942                 <span class="keyword">else</span>
0943                     k = k + 1;
0944                     hNodos(j, k) = i;
0945                 <span class="keyword">end</span>
0946                 <span class="keyword">if</span> yNodo == 0
0947                     ini = ini + 1;
0948                 <span class="keyword">end</span>
0949                 <span class="keyword">if</span> xNodo == xanalisis
0950                     ndrift(l) = i; <span class="comment">%#ok&lt;AGROW&gt;</span>
0951                     l = l + 1;
0952                 <span class="keyword">end</span>
0953             <span class="keyword">end</span> <span class="comment">% for i</span>
0954             
0955             [~, s] = size(desp);
0956             nndrift = length(ndrift);
0957             
0958             <span class="keyword">if</span> isempty(ndrift)
0959                 error(<span class="string">'Posicion direccion analisis %.2f invalida'</span>, xanalisis);
0960             <span class="keyword">end</span>
0961             
0962             despx = zeros(nndrift, s);
0963             driftx = zeros(nndrift-1, s);
0964             
0965             <span class="comment">% Calculo de drift y desplazamiento en linea de analisis</span>
0966             <span class="keyword">for</span> i = 2:nndrift
0967                 nodosup = ndrift(i);
0968                 gdls = nodos{nodosup}.obtenerGDLIDCondensado();
0969                 gdlx = gdls(1);
0970                 despx(i, :) = desp(gdlx, :);
0971                 driftx(i-1, :) = abs(despx(i, :)-despx(i-1, :)) ./ (habs(i) - habs(i-1));
0972                 
0973             <span class="keyword">end</span> <span class="comment">% for i</span>
0974             
0975             <span class="comment">% Determinacion de envolvente maxima de desplazamiento y drift</span>
0976             despxmax = max(abs(despx'))';
0977             driftxmax = max(abs(driftx'))';
0978             VecDesp = flipud(despxmax);
0979             VecDrift = flipud(driftxmax);
0980             hgen = flipud(habs);
0981             hplot = zeros(2*length(hgen), 1);
0982             Despplot = zeros(2*length(hgen)-1, 1);
0983             Driftplot = zeros(2*length(hgen)-1, 1);
0984             aux1 = 1;
0985             aux2 = 2;
0986             <span class="keyword">for</span> i = 1:length(hgen)
0987                 hplot(aux1, 1) = hgen(i);
0988                 hplot(aux1+1, 1) = hgen(i);
0989                 <span class="keyword">if</span> aux2 &lt;= 2 * length(hgen) - 1
0990                     Driftplot(aux2, 1) = VecDrift(i);
0991                     Driftplot(aux2+1, 1) = VecDrift(i);
0992                     Despplot(aux2, 1) = VecDesp(i);
0993                     Despplot(aux2+1, 1) = VecDesp(i);
0994                 <span class="keyword">end</span>
0995                 aux1 = aux1 + 2;
0996                 aux2 = aux2 + 2;
0997             <span class="keyword">end</span> <span class="comment">% for i</span>
0998             hplot(length(hplot)) = [];
0999             
1000             <span class="comment">% Crea las figuras</span>
1001             fig_title = sprintf(<span class="string">'Envolvente de Deriva Entre Piso - %s %s'</span>, ctitle, carga.obtenerEtiqueta());
1002             plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1003             movegui(plt, <span class="string">'center'</span>);
1004             <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(Driftplot.*100, hplot, <span class="string">'*-'</span>, <span class="string">'LineWidth'</span>, 1, <span class="string">'Color'</span>, <span class="string">'black'</span>);
1005             grid on;
1006             grid minor;
1007             xlabel(<span class="string">'Drift (%)'</span>);
1008             ylabel(sprintf(<span class="string">'Altura (%s)'</span>, r.unidad));
1009             title(fig_title);
1010             
1011             fig_title = sprintf(<span class="string">'Envolvente de Desplazamiento - %s %s'</span>, ctitle, carga.obtenerEtiqueta());
1012             plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1013             movegui(plt, <span class="string">'center'</span>);
1014             <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(Despplot, hplot, <span class="string">'*-'</span>, <span class="string">'LineWidth'</span>, 1, <span class="string">'Color'</span>, <span class="string">'black'</span>);
1015             grid on;
1016             grid minor;
1017             xlabel(sprintf(<span class="string">'Desplazamiento (%s)'</span>, r.unidad));
1018             ylabel(sprintf(<span class="string">'Altura (%s)'</span>, r.unidad));
1019             title(fig_title);
1020             
1021             <span class="comment">% Finaliza proceso</span>
1022             drawnow();
1023             fprintf(<span class="string">'\tProceso finalizado en %.2f segundos\n'</span>, cputime-tinicial);
1024             <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
1025             
1026         <span class="keyword">end</span> <span class="comment">% calcularDesplazamientoDrift function</span>
1027         
1028         <a name="_sub17" href="#_subfunctions" class="code">function calcularMomentoCorteBasal(analisisObj, carga, varargin)</a>
1029             <span class="comment">% calcularMomentoCorteBasal: Funcion que calcula el momento y</span>
1030             <span class="comment">% corte basal a partir de una carga</span>
1031             <span class="comment">%</span>
1032             <span class="comment">% calcularMomentoCorteBasal(analisisObj,carga,varargin)</span>
1033             <span class="comment">%</span>
1034             <span class="comment">% Parametros opcionales:</span>
1035             <span class="comment">%   'closeall'  Cierra todos los graficos</span>
1036             <span class="comment">%   'modo'      Vector con graficos de modos</span>
1037             <span class="comment">%   'plot'      'all','momento','corte','envmomento','envcorte'</span>
1038             <span class="comment">%   'unidadC'   Unidad corte del modelo</span>
1039             <span class="comment">%   'unidadM'   Unidad momento del modelo</span>
1040             
1041             <span class="comment">% Inicia proceso</span>
1042             tinicial = cputime;
1043             fprintf(<span class="string">'Calculando grafico momento corte basal:\n'</span>);
1044             
1045             <span class="comment">% Rescata parametros</span>
1046             p = inputParser;
1047             p.KeepUnmatched = true;
1048             addOptional(p, <span class="string">'closeall'</span>, false);
1049             addOptional(p, <span class="string">'modo'</span>, []);
1050             addOptional(p, <span class="string">'plot'</span>, <span class="string">'all'</span>);
1051             addOptional(p, <span class="string">'unidadC'</span>, <span class="string">'tonf'</span>);
1052             addOptional(p, <span class="string">'unidadM'</span>, <span class="string">'tonf-m'</span>);
1053             parse(p, varargin{:});
1054             r = p.Results;
1055             tipoplot = r.plot;
1056             envmodo = r.modo;
1057             
1058             <span class="keyword">if</span> r.closeall
1059                 close all;
1060             <span class="keyword">end</span>
1061             
1062             <span class="comment">% Verifica que la carga se haya calculado</span>
1063             <span class="keyword">if</span> ~(isa(carga, <span class="string">'CargaDinamica'</span>) || isa(carga, <span class="string">'CombinacionCargas'</span>))
1064                 error(<span class="string">'Solo se pueden graficar cargas dinamicas o combinaciones de cargas'</span>);
1065             <span class="keyword">end</span>
1066             acel = carga.obtenerAceleracion();
1067             <span class="keyword">if</span> ~carga.cargaCalculada()
1068                 error(<span class="string">'La carga %s no se ha calculado'</span>, carga.obtenerEtiqueta());
1069             <span class="keyword">end</span>
1070             ctitle = analisisObj.imprimirPropiedadesAnalisisCarga(carga);
1071             
1072             <span class="comment">% Verifica que envmodo sea correcto</span>
1073             [~, lphi] = size(analisisObj.phin);
1074             lenvmodo = length(envmodo);
1075             envmodo = sort(envmodo);
1076             <span class="keyword">for</span> i = 1:lenvmodo
1077                 envmodo(i) = floor(envmodo(i));
1078                 <span class="keyword">if</span> envmodo(i) &lt; 0 || envmodo(i) &gt; lphi
1079                     error(<span class="string">'Analisis modo %d invalido'</span>, envmodo(i));
1080                 <span class="keyword">end</span>
1081             <span class="keyword">end</span> <span class="comment">% for i</span>
1082             
1083             <span class="comment">% Calcula el momento</span>
1084             [Cortante, Momento, CBplot, MBplot, hplot] = analisisObj.calcularMomentoCorteBasalAcel(acel);
1085             
1086             <span class="comment">% Graficos</span>
1087             t = carga.obtenerVectorTiempo(); <span class="comment">% Vector de tiempo</span>
1088             dplot = false; <span class="comment">% Indica si se realizo algun grafico</span>
1089             
1090             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'corte'</span>)
1091                 fig_title = sprintf(<span class="string">'Historial de Cortante Basal - %s %s'</span>, ctitle, carga.obtenerEtiqueta());
1092                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1093                 movegui(plt, <span class="string">'center'</span>);
1094                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, Cortante(<span class="keyword">end</span>, :), <span class="string">'k-'</span>, <span class="string">'LineWidth'</span>, 1);
1095                 grid on;
1096                 grid minor;
1097                 xlabel(<span class="string">'Tiempo (s)'</span>);
1098                 ylabel(sprintf(<span class="string">'Corte (%s)'</span>, r.unidadC));
1099                 title(fig_title);
1100                 dplot = true;
1101             <span class="keyword">end</span>
1102             
1103             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'momento'</span>)
1104                 fig_title = sprintf(<span class="string">'Historial de Momento Basal - %s %s'</span>, ctitle, carga.obtenerEtiqueta());
1105                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1106                 movegui(plt, <span class="string">'center'</span>);
1107                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, Momento(<span class="keyword">end</span>, :), <span class="string">'k-'</span>, <span class="string">'LineWidth'</span>, 1);
1108                 grid on;
1109                 grid minor;
1110                 xlabel(<span class="string">'Tiempo (s)'</span>);
1111                 ylabel(sprintf(<span class="string">'Momento (%s)'</span>, r.unidadM));
1112                 title(fig_title);
1113                 dplot = true;
1114             <span class="keyword">end</span>
1115             
1116             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'envcorte'</span>)
1117                 fig_title = sprintf(<span class="string">'Envolvente de Cortante Basal - %s %s'</span>, ctitle, carga.obtenerEtiqueta());
1118                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1119                 movegui(plt, <span class="string">'center'</span>);
1120                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(CBplot, hplot, <span class="string">'*-'</span>, <span class="string">'LineWidth'</span>, 1, <span class="string">'Color'</span>, <span class="string">'black'</span>);
1121                 hold on;
1122                 grid on;
1123                 grid minor;
1124                 xlabel(sprintf(<span class="string">'Corte (%s)'</span>, r.unidadC));
1125                 ylabel(<span class="string">'Altura (m)'</span>);
1126                 title(fig_title);
1127                 
1128                 <span class="comment">% Realiza los analisis por modo</span>
1129                 CBLegend = cell(1, 1+lenvmodo);
1130                 CBplotModoAnt = false;
1131                 CBLegend{1} = <span class="string">'Envolvente'</span>;
1132                 phiac = analisisObj.phin' * acel;
1133                 <span class="keyword">for</span> i = 1:lenvmodo
1134                     [~, ~, CBplotModo, ~, ~] = analisisObj.calcularMomentoCorteBasalAcel(analisisObj.phin(:, envmodo(i))*phiac(envmodo(i), :));
1135                     <span class="keyword">if</span> i &gt; 1
1136                         CBplotModo = CBplotModo + CBplotModoAnt;
1137                     <span class="keyword">end</span>
1138                     CBplotModoAnt = CBplotModo;
1139                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(CBplotModo, hplot, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, 1);
1140                     CBLegend{i+1} = sprintf(<span class="string">'Modo %d'</span>, envmodo(i));
1141                 <span class="keyword">end</span> <span class="comment">% for i</span>
1142                 <span class="keyword">if</span> lenvmodo &gt; 0
1143                     legend(CBLegend);
1144                 <span class="keyword">end</span>
1145                 dplot = true;
1146             <span class="keyword">end</span>
1147             
1148             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'envmomento'</span>)
1149                 fig_title = sprintf(<span class="string">'Envolvente de Momento Basal - %s %s'</span>, ctitle, carga.obtenerEtiqueta());
1150                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1151                 movegui(plt, <span class="string">'center'</span>);
1152                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(MBplot, hplot, <span class="string">'*-'</span>, <span class="string">'LineWidth'</span>, 1, <span class="string">'Color'</span>, <span class="string">'black'</span>);
1153                 grid on;
1154                 grid minor;
1155                 xlabel(sprintf(<span class="string">'Momento (%s)'</span>, r.unidadM));
1156                 ylabel(<span class="string">'Altura (m)'</span>);
1157                 title(fig_title);
1158                 dplot = true;
1159             <span class="keyword">end</span>
1160             
1161             <span class="comment">% Si no se realizo ningun grafico</span>
1162             <span class="keyword">if</span> ~dplot
1163                 error(<span class="string">'Tipo de grafico %s incorrecto, valores aceptados: %s'</span>, tipoplot, <span class="keyword">...</span>
1164                     <span class="string">'corte, momento, envcorte, envmomento'</span>);
1165             <span class="keyword">end</span>
1166             
1167             <span class="comment">% Finaliza proceso</span>
1168             drawnow();
1169             fprintf(<span class="string">'\tProceso finalizado en %.2f segundos\n'</span>, cputime-tinicial);
1170             <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
1171             
1172         <span class="keyword">end</span> <span class="comment">% calcularMomentoCorteBasal function</span>
1173         
1174         <a name="_sub18" href="#_subfunctions" class="code">function calcularCurvasEnergia(analisisObj, carga, varargin)</a>
1175             <span class="comment">% calcularCurvasEnergia: Genera las curvas de energia a partir</span>
1176             <span class="comment">% de una carga</span>
1177             <span class="comment">%</span>
1178             <span class="comment">% calcularCurvasEnergia(analisisObj,carga,varargin)</span>
1179             <span class="comment">%</span>
1180             <span class="comment">% Parametros opcionales:</span>
1181             <span class="comment">%   'carga'         Booleano que indica si se grafica la carga o no</span>
1182             <span class="comment">%   'closeall'      Cierra todos los graficos</span>
1183             <span class="comment">%   'linewidth'     Ancho de linea de los graficos</span>
1184             <span class="comment">%   'mfilt'         Porcentaje de filtrado por numero de datos</span>
1185             <span class="comment">%   'norm1'         Normaliza con respecto al primer valor</span>
1186             <span class="comment">%   'plot'          'all','ek','ev','ekev','ebe','et','ed'</span>
1187             
1188             <span class="comment">% Inicia el proceso</span>
1189             tinicial = cputime;
1190             
1191             <span class="comment">% Recorre parametros opcionales</span>
1192             p = inputParser;
1193             p.KeepUnmatched = true;
1194             addOptional(p, <span class="string">'closeall'</span>, false);
1195             addOptional(p, <span class="string">'linewidth'</span>, 1.2);
1196             addOptional(p, <span class="string">'mfilt'</span>, 0.005);
1197             addOptional(p, <span class="string">'norm1'</span>, false);
1198             addOptional(p, <span class="string">'plot'</span>, <span class="string">'all'</span>);
1199             addOptional(p, <span class="string">'plotcarga'</span>, false);
1200             parse(p, varargin{:});
1201             r = p.Results;
1202             
1203             <span class="keyword">if</span> r.closeall
1204                 close all;
1205             <span class="keyword">end</span>
1206             
1207             <span class="comment">% Obtiene variables</span>
1208             tipoplot = r.plot;
1209             plotcarga = r.plotcarga;
1210             
1211             <span class="comment">% Verifica que la carga se haya calculado</span>
1212             <span class="keyword">if</span> ~(isa(carga, <span class="string">'CargaDinamica'</span>) || isa(carga, <span class="string">'CombinacionCargas'</span>))
1213                 error(<span class="string">'Solo se pueden graficar cargas dinamicas o una combinacion de cargas'</span>);
1214             <span class="keyword">end</span>
1215             c_u = carga.obtenerDesplazamiento();
1216             c_v = carga.obtenerVelocidad();
1217             c_p = carga.obtenerCarga();
1218             
1219             <span class="keyword">if</span> ~carga.cargaCalculada()
1220                 error(<span class="string">'La carga %s no se ha calculado'</span>, carga.obtenerEtiqueta());
1221             <span class="keyword">end</span>
1222             
1223             <span class="comment">% Realiza calculos de energia</span>
1224             fprintf(<span class="string">'Calculando curvas de energia:\n'</span>);
1225             ctitle = analisisObj.imprimirPropiedadesAnalisisCarga(carga);
1226             
1227             <span class="comment">% Obtiene las matrices</span>
1228             k = analisisObj.obtenerMatrizRigidez();
1229             m = analisisObj.obtenerMatrizMasa();
1230             c = analisisObj.obtenerMatrizAmortiguamiento(carga.usoAmortiguamientoRayleigh());
1231             
1232             <span class="comment">% Si se usaron disipadores</span>
1233             <span class="keyword">if</span> carga.usoDeDisipadores()
1234                 cdv = analisisObj.obtenerMatrizAmortiguamientoDisipadores();
1235                 kdv = analisisObj.obtenerMatrizRigidezDisipadores();
1236                 fprintf(<span class="string">'\t\tLa %s se calculo con disipadores\n'</span>, lower(ctitle));
1237             <span class="keyword">else</span>
1238                 fprintf(<span class="string">'\t\tLa %s se calculo sin disipadores\n'</span>, lower(ctitle));
1239             <span class="keyword">end</span>
1240             
1241             <span class="comment">% Graficos</span>
1242             [~, s] = size(c_u);
1243             t = carga.obtenerVectorTiempo(); <span class="comment">% Vector de tiempo</span>
1244             
1245             <span class="comment">% Energia cinetica</span>
1246             e_k = zeros(1, s);
1247             ek1 = 0;
1248             fprintf(<span class="string">'\tCalculando energia cinetica\n'</span>);
1249             <span class="keyword">for</span> i = 1:s
1250                 vv = c_v(:, i); <span class="comment">% Obtiene el vector de velocidad para el tiempo i</span>
1251                 e_k(i) = 0.5 * vv' * m * vv;
1252                 <span class="keyword">if</span> i == 1
1253                     ek1 = e_k(i);
1254                 <span class="keyword">end</span>
1255                 <span class="keyword">if</span> r.norm1
1256                     e_k(i) = e_k(i) - ek1;
1257                 <span class="keyword">end</span>
1258             <span class="keyword">end</span> <span class="comment">% for i</span>
1259             
1260             <span class="comment">% Energia elastica</span>
1261             e_v = zeros(1, s);
1262             fprintf(<span class="string">'\tCalculando energia elastica\n'</span>);
1263             ev1 = 0;
1264             <span class="keyword">for</span> i = 1:s
1265                 vv = c_u(:, i); <span class="comment">% Obtiene el vector de desplazamiento para el tiempo i</span>
1266                 e_v(i) = 0.5 * vv' * k * vv;
1267                 <span class="keyword">if</span> i == 1
1268                     ev1 = e_v(1);
1269                 <span class="keyword">end</span>
1270                 <span class="keyword">if</span> r.norm1
1271                     e_v(i) = e_v(i) - ev1; <span class="comment">% Normaliza restando el valor inicial</span>
1272                 <span class="keyword">end</span>
1273             <span class="keyword">end</span> <span class="comment">% for i</span>
1274             
1275             <span class="comment">% Energia elastica disipadores</span>
1276             e_vamori = zeros(1, s); <span class="comment">% Parcial</span>
1277             e_vamor = zeros(1, s); <span class="comment">% Integral</span>
1278             ev1a = 0;
1279             
1280             <span class="keyword">if</span> carga.usoDeDisipadores()
1281                 fprintf(<span class="string">'\tCalculando energia elastica de los amortiguadores\n'</span>);
1282                 <span class="keyword">for</span> i = 1:s
1283                     uu = c_u(:, i); <span class="comment">% Obtiene el vector de desplazamiento para el tiempo i</span>
1284                     e_vamori(i) = uu' * kdv * uu;
1285                     <span class="keyword">if</span> i == 1
1286                         ev1a = e_vamori(1);
1287                     <span class="keyword">end</span>
1288                     <span class="keyword">if</span> r.norm1 <span class="comment">% Normaliza con el primer valor</span>
1289                         e_vamori(i) = e_vamori(i) - ev1a;
1290                     <span class="keyword">end</span>
1291                     <span class="keyword">if</span> i &gt; 1
1292                         dt = t(i) - t(i - 1);
1293                         e_vamor(i) = e_vamor(i - 1) + 0.5 * (e_vamori(i) + e_vamori(i - 1)) * dt;
1294                     <span class="keyword">end</span>
1295                 <span class="keyword">end</span> <span class="comment">% for i</span>
1296             <span class="keyword">end</span>
1297             
1298             <span class="comment">% Energia disipada</span>
1299             e_di = zeros(1, s); <span class="comment">% Parcial</span>
1300             e_d = zeros(1, s); <span class="comment">% Integral</span>
1301             ed1 = 0;
1302             
1303             fprintf(<span class="string">'\tCalculando energia disipada por la estructura\n'</span>);
1304             <span class="keyword">for</span> i = 1:s
1305                 vv = c_v(:, i); <span class="comment">% Obtiene el vector de velocidad para el tiempo i</span>
1306                 e_di(i) = vv' * c * vv;
1307                 <span class="keyword">if</span> i == 1
1308                     ed1 = e_di(1);
1309                 <span class="keyword">end</span>
1310                 <span class="keyword">if</span> r.norm1 <span class="comment">% Normaliza con el primer valor</span>
1311                     e_di(i) = e_di(i) - ed1;
1312                 <span class="keyword">end</span>
1313                 <span class="keyword">if</span> i &gt; 1
1314                     dt = t(i) - t(i-1);
1315                     e_d(i) = e_d(i-1) + 0.5 * (e_di(i) + e_di(i-1)) * dt;
1316                 <span class="keyword">end</span>
1317             <span class="keyword">end</span> <span class="comment">% for i</span>
1318             
1319             <span class="comment">% Energia disipada amortiguadores</span>
1320             e_damori = zeros(1, s); <span class="comment">% Parcial</span>
1321             e_damor = zeros(1, s); <span class="comment">% Integral</span>
1322             eda1 = 0;
1323             
1324             <span class="keyword">if</span> carga.usoDeDisipadores()
1325                 fprintf(<span class="string">'\tCalculando energia disipada por los amortiguadores\n'</span>);
1326                 <span class="keyword">for</span> i = 1:s
1327                     vv = c_v(:, i); <span class="comment">% Obtiene el vector de velocidad para el tiempo i</span>
1328                     e_damori(i) = vv' * cdv * vv;
1329                     <span class="keyword">if</span> i == 1
1330                         eda1 = e_damori(1);
1331                     <span class="keyword">end</span>
1332                     <span class="keyword">if</span> r.norm1 <span class="comment">% Normaliza con el primer valor</span>
1333                         e_damori(i) = e_damori(i) - eda1;
1334                     <span class="keyword">end</span>
1335                     <span class="keyword">if</span> i &gt; 1
1336                         dt = t(i) - t(i - 1);
1337                         e_damor(i) = e_damor(i - 1) + 0.5 * (e_damori(i) + e_damori(i - 1)) * dt;
1338                     <span class="keyword">end</span>
1339                 <span class="keyword">end</span> <span class="comment">% for i</span>
1340             <span class="keyword">end</span>
1341             
1342             <span class="comment">% Trabajo externo</span>
1343             w_ei = zeros(1, s); <span class="comment">% Parcial</span>
1344             w_e = zeros(1, s); <span class="comment">% Integral</span>
1345             fprintf(<span class="string">'\tCalculando trabajo externo\n'</span>);
1346             <span class="keyword">for</span> i = 1:s
1347                 w_ei(i) = c_p(:, i)' * c_v(:, i);
1348                 <span class="keyword">if</span> i &gt; 1
1349                     dt = t(i) - t(i-1);
1350                     w_e(i) = w_e(i-1) + 0.5 * (w_ei(i) + w_ei(i-1)) * dt;
1351                 <span class="keyword">end</span>
1352             <span class="keyword">end</span> <span class="comment">% for i</span>
1353             
1354             <span class="comment">% Energia total</span>
1355             e_t = zeros(1, s);
1356             fprintf(<span class="string">'\tCalculando energia total\n'</span>);
1357             <span class="keyword">for</span> i = 1:s
1358                 e_t(i) = e_k(1) + (e_v(1) + e_vamor(1)) + w_e(i) - (e_d(i) + e_damor(i));
1359             <span class="keyword">end</span> <span class="comment">% for i</span>
1360             
1361             <span class="comment">% Balance energetico normalizado</span>
1362             ebe = zeros(1, s);
1363             fprintf(<span class="string">'\tCalculando balance energetico\n'</span>);
1364             <span class="keyword">for</span> i = 1:s
1365                 ebe(i) = abs(w_e(i)-e_k(i)-(e_d(i) + e_damor(i))) / abs(w_e(i)) * 100;
1366             <span class="keyword">end</span> <span class="comment">% for i</span>
1367             
1368             <span class="comment">% Graficos</span>
1369             fprintf(<span class="string">'\tGenerando graficos\n'</span>);
1370             lw = r.linewidth; <span class="comment">% Linewidth de los graficos</span>
1371             dplot = false; <span class="comment">% Indica que un grafico se realizo</span>
1372             
1373             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'ek'</span>)
1374                 fig_title = sprintf(<span class="string">'E_K Energia Cinetica - %s %s'</span>, ctitle, carga.obtenerEtiqueta());
1375                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1376                 movegui(plt, <span class="string">'center'</span>);
1377                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_k, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1378                 grid on;
1379                 grid minor;
1380                 xlabel(<span class="string">'Tiempo (s)'</span>);
1381                 ylabel(<span class="string">'Energia cinetica'</span>);
1382                 title(fig_title);
1383                 ylims = get(gca, <span class="string">'YLim'</span>);
1384                 ylim([0, max(ylims)]);
1385                 <span class="keyword">if</span> plotcarga <span class="comment">% Grafica la carga</span>
1386                     axes(<span class="string">'Position'</span>, [.59, .70, .29, .20]);
1387                     box on;
1388                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, c_p, <span class="string">'k-'</span>, <span class="string">'Linewidth'</span>, 0.8);
1389                     grid on;
1390                 <span class="keyword">end</span>
1391                 dplot = true;
1392             <span class="keyword">end</span>
1393             
1394             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'ev'</span>)
1395                 fig_title = sprintf(<span class="string">'E_V Energia Elastica - %s %s'</span>, <span class="keyword">...</span>
1396                     ctitle, carga.obtenerEtiqueta());
1397                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1398                 movegui(plt, <span class="string">'center'</span>);
1399                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_v+e_vamor, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1400                 grid on;
1401                 grid minor;
1402                 xlabel(<span class="string">'Tiempo (s)'</span>);
1403                 ylabel(<span class="string">'Energia elastica'</span>);
1404                 title(fig_title);
1405                 ylims = get(gca, <span class="string">'YLim'</span>);
1406                 ylim([0, max(ylims)]);
1407                 <span class="keyword">if</span> plotcarga <span class="comment">% Grafica la carga</span>
1408                     axes(<span class="string">'Position'</span>, [.59, .70, .29, .20]);
1409                     box on;
1410                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, c_p, <span class="string">'k-'</span>, <span class="string">'Linewidth'</span>, 0.8);
1411                     grid on;
1412                 <span class="keyword">end</span>
1413                 dplot = true;
1414             <span class="keyword">end</span>
1415             
1416             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'ebe'</span>)
1417                 fig_title = sprintf(<span class="string">'Balance Energetico Normalizado - %s %s'</span>, <span class="keyword">...</span>
1418                     ctitle, carga.obtenerEtiqueta());
1419                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1420                 movegui(plt, <span class="string">'center'</span>);
1421                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, ebe, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1422                 grid on;
1423                 grid minor;
1424                 xlabel(<span class="string">'Tiempo (s)'</span>);
1425                 ylabel(<span class="string">'EBE (%)'</span>);
1426                 title(fig_title);
1427                 ylims = get(gca, <span class="string">'YLim'</span>);
1428                 ylim([0, max(ylims)]);
1429                 <span class="keyword">if</span> plotcarga <span class="comment">% Grafica la carga</span>
1430                     axes(<span class="string">'Position'</span>, [.59, .70, .29, .20]);
1431                     box on;
1432                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, c_p, <span class="string">'k-'</span>, <span class="string">'Linewidth'</span>, 0.8);
1433                     grid on;
1434                 <span class="keyword">end</span>
1435                 dplot = true;
1436             <span class="keyword">end</span>
1437             
1438             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'evek'</span>) || strcmp(tipoplot, <span class="string">'ekev'</span>)
1439                 fig_title = sprintf(<span class="string">'Energia Potencial - Cinetica - %s %s'</span>, <span class="keyword">...</span>
1440                     ctitle, carga.obtenerEtiqueta());
1441                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1442                 movegui(plt, <span class="string">'center'</span>);
1443                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_k, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1444                 hold on;
1445                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_v+e_vamor, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1446                 grid on;
1447                 grid minor;
1448                 xlabel(<span class="string">'Tiempo (s)'</span>);
1449                 ylabel(<span class="string">'Energia'</span>);
1450                 legend({<span class="string">'E_K Energia cinetica'</span>, <span class="string">'E_V Energia elastica'</span>}, <span class="keyword">...</span>
1451                     <span class="string">'location'</span>, <span class="string">'northeast'</span>);
1452                 title(fig_title);
1453                 ylims = get(gca, <span class="string">'YLim'</span>);
1454                 ylim([0, max(ylims)]);
1455                 <span class="keyword">if</span> plotcarga <span class="comment">% Grafica la carga</span>
1456                     axes(<span class="string">'Position'</span>, [.59, .55, .29, .20]);
1457                     box on;
1458                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, c_p, <span class="string">'k-'</span>, <span class="string">'Linewidth'</span>, 0.8);
1459                     grid on;
1460                 <span class="keyword">end</span>
1461                 dplot = true;
1462             <span class="keyword">end</span>
1463             
1464             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'et'</span>)
1465                 fig_title = sprintf(<span class="string">'Energia Total - Disipada - Ingresada - %s %s'</span>, <span class="keyword">...</span>
1466                     ctitle, carga.obtenerEtiqueta());
1467                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1468                 movegui(plt, <span class="string">'center'</span>);
1469                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_t, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1470                 hold on;
1471                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_d+e_damor, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1472                 <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, w_e, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1473                 grid on;
1474                 grid minor;
1475                 xlabel(<span class="string">'Tiempo (s)'</span>);
1476                 ylabel(<span class="string">'Energia'</span>);
1477                 legend({<span class="string">'E_t Energia total'</span>, <span class="string">'E_D Energia disipada total'</span>, <span class="keyword">...</span>
1478                     <span class="string">'W_E Trabajo externo'</span>}, <span class="string">'location'</span>, <span class="string">'southeast'</span>);
1479                 title(fig_title);
1480                 ylims = get(gca, <span class="string">'YLim'</span>);
1481                 ylim([0, max(ylims)]);
1482                 <span class="keyword">if</span> plotcarga <span class="comment">% Grafica la carga</span>
1483                     axes(<span class="string">'Position'</span>, [.59, .36, .29, .20]);
1484                     box on;
1485                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, c_p, <span class="string">'k-'</span>, <span class="string">'Linewidth'</span>, 0.8);
1486                     grid on;
1487                 <span class="keyword">end</span>
1488                 dplot = true;
1489             <span class="keyword">end</span>
1490             
1491             <span class="keyword">if</span> strcmp(tipoplot, <span class="string">'all'</span>) || strcmp(tipoplot, <span class="string">'ed'</span>)
1492                 
1493                 <span class="comment">% Graficos energia disipada</span>
1494                 fig_title = sprintf(<span class="string">'Energia Disipada - %s %s'</span>, <span class="keyword">...</span>
1495                     ctitle, carga.obtenerEtiqueta());
1496                 plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1497                 movegui(plt, <span class="string">'center'</span>);
1498                 <span class="keyword">if</span> carga.usoDeDisipadores()
1499                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_d+e_damor, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1500                     hold on;
1501                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_d, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1502                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_damor, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1503                     legend({<span class="string">'Energia disipada total'</span>, <span class="string">'Energia disipada por la estructura'</span>, <span class="keyword">...</span>
1504                         <span class="string">'Energia disipada por disipadores'</span>}, <span class="string">'location'</span>, <span class="string">'Best'</span>);
1505                 <span class="keyword">else</span>
1506                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, e_d, <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1507                     <span class="comment">% legend({'Energia disipada por la estructura'}, 'location', 'Best');</span>
1508                 <span class="keyword">end</span>
1509                 grid on;
1510                 grid minor;
1511                 xlabel(<span class="string">'Tiempo (s)'</span>);
1512                 ylabel(<span class="string">'Energia'</span>);
1513                 title(fig_title);
1514                 ylims = get(gca, <span class="string">'YLim'</span>);
1515                 ylim([0, max(ylims)]);
1516                 <span class="comment">% if plotcarga % Grafica la carga</span>
1517                 <span class="comment">%     axes('Position', [.59, .36, .29, .20]);</span>
1518                 <span class="comment">%     box on;</span>
1519                 <span class="comment">%     plot(t, c_p, 'k-', 'Linewidth', 0.8);</span>
1520                 <span class="comment">%     grid on;</span>
1521                 <span class="comment">% end</span>
1522                 dplot = true;
1523                 
1524                 <span class="comment">% Comparacion energia estructura y disipador</span>
1525                 <span class="keyword">if</span> carga.usoDeDisipadores()
1526                     fig_title = {<span class="string">'Razon energia estructura - disipador'</span>, <span class="keyword">...</span>
1527                         sprintf(<span class="string">'%s %s'</span>, ctitle, carga.obtenerEtiqueta())};
1528                     plt = figure(<span class="string">'Name'</span>, fig_title{1}, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1529                     movegui(plt, <span class="string">'center'</span>);
1530                     <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, medfilt1(e_d./e_damor, floor(r.mfilt*length(e_d))), <span class="keyword">...</span>
1531                         <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, lw);
1532                     grid on;
1533                     grid minor;
1534                     xlabel(<span class="string">'Tiempo (s)'</span>);
1535                     ylabel(<span class="string">'Razon estructura/disipador'</span>);
1536                     title(fig_title);
1537                     ylims = get(gca, <span class="string">'YLim'</span>);
1538                     ylim([0, max(ylims)]);
1539                     <span class="keyword">if</span> plotcarga <span class="comment">% Grafica la carga</span>
1540                         axes(<span class="string">'Position'</span>, [.59, .68, .29, .20]);
1541                         box on;
1542                         <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, c_p, <span class="string">'k-'</span>, <span class="string">'Linewidth'</span>, 0.8);
1543                         grid on;
1544                     <span class="keyword">end</span>
1545                 <span class="keyword">end</span>
1546                 
1547             <span class="keyword">end</span>
1548             
1549             <span class="comment">% Si no se realizo ningun grafico</span>
1550             <span class="keyword">if</span> ~dplot
1551                 error(<span class="string">'Tipo de grafico %s incorrecto, valores aceptados: %s'</span>, tipoplot, <span class="keyword">...</span>
1552                     <span class="string">'ek, ev, ekev, ebe, et, ed'</span>);
1553             <span class="keyword">end</span>
1554             
1555             <span class="comment">% Finaliza proceso</span>
1556             drawnow();
1557             fprintf(<span class="string">'\tProceso finalizado en %.2f segundos\n'</span>, cputime-tinicial);
1558             <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
1559             
1560         <span class="keyword">end</span> <span class="comment">% calcularCurvasEnergia function</span>
1561         
1562         <a name="_sub19" href="#_subfunctions" class="code">function e_v = calcularModosEnergia(analisisObj, carga, dispinfo)</a>
1563             <span class="comment">% calcularModosEnergia: Metodo que calcula las energias</span>
1564             <span class="comment">% elasticas asociadas a una carga por cada modo y retorna una</span>
1565             <span class="comment">% matriz ordenada por energia y numero de modos</span>
1566             <span class="comment">%</span>
1567             <span class="comment">% w = calcularModosEnergia(analisisObj,carga,dispinfo)</span>
1568             
1569             <span class="keyword">if</span> ~exist(<span class="string">'dispinfo'</span>, <span class="string">'var'</span>)
1570                 dispinfo = true;
1571             <span class="keyword">end</span>
1572             
1573             <span class="comment">% Verifica que la carga se haya calculado</span>
1574             <span class="keyword">if</span> ~isa(carga, <span class="string">'CargaDinamica'</span>)
1575                 error(<span class="string">'Solo se pueden graficar cargas dinamicas'</span>);
1576             <span class="keyword">end</span>
1577             c_u = carga.obtenerDesplazamiento();
1578             
1579             <span class="comment">% No usar carga.cargaCalculada() dado que este metodo es usado</span>
1580             <span class="comment">% por Newmark al iterar sobre los disipadores</span>
1581             <span class="keyword">if</span> isempty(c_u)
1582                 error(<span class="string">'La carga %s no se ha calculado'</span>, carga.obtenerEtiqueta());
1583             <span class="keyword">end</span>
1584             
1585             <span class="keyword">if</span> dispinfo
1586                 fprintf(<span class="string">'\tCalculando energia elastica por cada modo:\n'</span>);
1587                 analisisObj.imprimirPropiedadesAnalisisCarga(carga);
1588             <span class="keyword">end</span>
1589             
1590             <span class="comment">% Obtiene las matrices</span>
1591             k = analisisObj.obtenerMatrizRigidez();
1592             phi = analisisObj.obtenerMatrizPhi();
1593             
1594             <span class="comment">% Realiza calculos de energia elastica</span>
1595             [~, s] = size(c_u);
1596             
1597             <span class="comment">% Energia elastica total</span>
1598             e_v = zeros(analisisObj.numModos, 5);
1599             <span class="keyword">for</span> j = 1:analisisObj.numModos <span class="comment">% Recorre cada modo</span>
1600                 e_vsum = 0; <span class="comment">% Suma la energia asociada a un modo para todo el tiempo</span>
1601                 kj = phi(:, j)' * k;
1602                 <span class="keyword">for</span> i = 1:s <span class="comment">% Recorre el tiempo</span>
1603                     vv = c_u(:, i); <span class="comment">% Obtiene el vector de desplazamiento para el tiempo i</span>
1604                     e_vsum = e_vsum + 0.5 * vv' * phi(:, j) * kj * vv;
1605                 <span class="keyword">end</span> <span class="comment">% for i</span>
1606                 e_v(j, 1) = j;
1607                 e_v(j, 2) = analisisObj.wn(j);
1608                 e_v(j, 3) = 2 * pi() / analisisObj.wn(j);
1609                 e_v(j, 4) = abs(e_vsum);
1610             <span class="keyword">end</span> <span class="comment">% for j</span>
1611             
1612             <span class="comment">% Normaliza por el maximo</span>
1613             e_vmax = max(e_v(:, 4));
1614             <span class="keyword">for</span> j = 1:analisisObj.numModos
1615                 e_v(j, 4) = e_v(j, 4) / e_vmax;
1616             <span class="keyword">end</span> <span class="comment">% for j</span>
1617             
1618             <span class="comment">% Suma</span>
1619             e_vsum = sum(e_v(:, 4));
1620             <span class="keyword">for</span> j = 1:analisisObj.numModos
1621                 e_v(j, 5) = e_v(j, 4) / e_vsum;
1622             <span class="keyword">end</span> <span class="comment">% for j</span>
1623             
1624             <span class="comment">% Ordena la matriz</span>
1625             e_v = sortrows(e_v, -4);
1626             
1627         <span class="keyword">end</span> <span class="comment">% calcularModosEnergia function</span>
1628         
1629         <a name="_sub20" href="#_subfunctions" class="code">function [esfmax, esf, maxp, dirk] = calcularEsfuerzosElemento(analisisObj, carga, elemento, direccion)</a>
1630             <span class="comment">% calcularEsfuerzosElemento: Calcula los esfuerzos maximos de</span>
1631             <span class="comment">% un elemento a partir de una carga dinamica</span>
1632             <span class="comment">%</span>
1633             <span class="comment">% [esfmax,esf,maxp,dirk] = calcularEsfuerzosElemento(analisisObj,carga,elemento,direccion)</span>
1634             
1635             <span class="comment">% Obtiene resultados de la carga</span>
1636             u_c = carga.obtenerDesplazamiento();
1637             
1638             <span class="comment">% Verifica que la carga se haya calculado</span>
1639             <span class="keyword">if</span> ~(isa(carga, <span class="string">'CargaDinamica'</span>) || isa(carga, <span class="string">'CombinacionCargas'</span>))
1640                 error(<span class="string">'Solo se pueden graficar cargas dinamicas o combinaciones de cargas'</span>);
1641             <span class="keyword">end</span>
1642             <span class="keyword">if</span> ~carga.cargaCalculada()
1643                 error(<span class="string">'La carga %s no se ha calculado'</span>, carga.obtenerEtiqueta());
1644             <span class="keyword">end</span>
1645             
1646             <span class="comment">% Verifica que el elemento este bien definido</span>
1647             <span class="keyword">if</span> ~isa(elemento, <span class="string">'Elemento'</span>)
1648                 error(<span class="string">'El elemento no pertenece a la clase Elemento'</span>);
1649             <span class="keyword">end</span>
1650             
1651             <span class="comment">% Genera el esfuerzo por el tiempo</span>
1652             t = carga.obtenerVectorTiempo(); <span class="comment">% Vector de tiempo</span>
1653             esf = zeros(analisisObj.modeloObj.obtenerNumerosGDL(), length(t));
1654             esfmax = zeros(analisisObj.modeloObj.obtenerNumerosGDL(), 1);
1655             
1656             <span class="comment">% Obtiene desplazamientos originales de los nodos del elemento</span>
1657             nodos = elemento.obtenerNodos();
1658             despl = {};
1659             <span class="keyword">for</span> i = 1:length(nodos)
1660                 despl{i} = nodos{i}.obtenerDesplazamientos(); <span class="comment">%#ok&lt;AGROW&gt;</span>
1661             <span class="keyword">end</span>
1662             ngdl = nodos{1}.obtenerNumeroGDL();
1663             
1664             <span class="comment">% Verifica la direccion</span>
1665             dirk = 1; <span class="comment">% Direccion de analisis de cada elemento</span>
1666             <span class="keyword">if</span> direccion ~= 0
1667                 <span class="keyword">if</span> ~(<a href="../../tefame/utils/verificarVectorDireccion.html" class="code" title="function y = verificarVectorDireccion(vec, ndg)">verificarVectorDireccion</a>(direccion, nodos{1}.obtenerNumeroGDL())) || sum(direccion) ~= 1
1668                     error(<span class="string">'Direccion de analisis del elemento mal definido'</span>);
1669                 <span class="keyword">end</span>
1670                 <span class="keyword">for</span> i = 1:length(direccion)
1671                     <span class="keyword">if</span> direccion(i) == 1
1672                         dirk = i;
1673                         <span class="keyword">break</span>;
1674                     <span class="keyword">end</span>
1675                 <span class="keyword">end</span> <span class="comment">% for i</span>
1676             <span class="keyword">end</span>
1677             
1678             <span class="comment">% Posicion del maximo</span>
1679             maxp = 1;
1680             maxv = 0;
1681             
1682             <span class="comment">% Por cada tiempo obtiene la fuerza resistente local</span>
1683             <span class="keyword">for</span> i = 1:length(t)
1684                 
1685                 <span class="comment">% Define los desplazamientos del nodo</span>
1686                 <span class="keyword">for</span> j = 1:length(nodos)
1687                     k = nodos{j}.obtenerGDLIDCondensado();
1688                     unodo = zeros(1, ngdl);
1689                     <span class="keyword">for</span> n = 1:ngdl <span class="comment">% Recorre cada desplazamiento de ese grado para el tiempo i</span>
1690                         <span class="keyword">if</span> k(n) &gt; 0
1691                             unodo(n) = u_c(k(n), i);
1692                         <span class="keyword">end</span>
1693                     <span class="keyword">end</span> <span class="comment">% for n</span>
1694                     nodos{j}.definirDesplazamientos(unodo);
1695                 <span class="keyword">end</span> <span class="comment">% for j</span>
1696                 
1697                 <span class="comment">% Obtiene la fuerza resistente</span>
1698                 fr = elemento.obtenerFuerzaResistenteCoordLocal();
1699                 <span class="keyword">for</span> j = 1:length(fr) / 2
1700                     esf(j, i) = fr(j);
1701                 <span class="keyword">end</span> <span class="comment">% for j</span>
1702                 
1703                 <span class="comment">% Actualiza el maximo</span>
1704                 <span class="keyword">if</span> abs(esf(dirk, i)) &gt; maxv
1705                     maxv = abs(esf(dirk, i));
1706                     maxp = i;
1707                 <span class="keyword">end</span>
1708                 
1709                 <span class="keyword">for</span> j = 1:length(esfmax)
1710                     <span class="keyword">if</span> abs(esf(j, i)) &gt; abs(esfmax(j))
1711                         esfmax(j) = esf(j, i);
1712                     <span class="keyword">end</span>
1713                 <span class="keyword">end</span> <span class="comment">% for j</span>
1714                 
1715             <span class="keyword">end</span> <span class="comment">% for i</span>
1716             
1717             <span class="comment">% Resetea los desplazamientos originales</span>
1718             <span class="keyword">for</span> i = 1:length(nodos)
1719                 nodos{i}.definirDesplazamientos(despl{i});
1720             <span class="keyword">end</span> <span class="comment">% for i</span>
1721             
1722         <span class="keyword">end</span> <span class="comment">% calcularEsfuerzosElemento function</span>
1723         
1724         <a name="_sub21" href="#_subfunctions" class="code">function plotEsfuerzosElemento(analisisObj, carga, elemento, direccion, varargin)</a>
1725             <span class="comment">% plotEsfuerzosElemento: Grafica los esfuerzos de un elemento</span>
1726             <span class="comment">%</span>
1727             <span class="comment">% plotEsfuerzosElemento(analisisObj,carga,elemento,direccion,varargin)</span>
1728             <span class="comment">%</span>
1729             <span class="comment">% Parametros opcionales:</span>
1730             <span class="comment">%   'tlim'      Tiempo de analisis limite</span>
1731             <span class="comment">%   'unidadC'   Unidad corte</span>
1732             <span class="comment">%   'unidadM'   Unidad momento</span>
1733             
1734             <span class="comment">% Inicia el proceso</span>
1735             tinicial = cputime;
1736             
1737             <span class="comment">% Recorre parametros opcionales</span>
1738             p = inputParser;
1739             p.KeepUnmatched = true;
1740             addOptional(p, <span class="string">'tlim'</span>, 0);
1741             addOptional(p, <span class="string">'unidadC'</span>, <span class="string">'tonf'</span>);
1742             addOptional(p, <span class="string">'unidadM'</span>, <span class="string">'tonf-m'</span>);
1743             parse(p, varargin{:});
1744             r = p.Results;
1745             
1746             <span class="comment">% Obtiene las variables</span>
1747             tlim = r.tlim;
1748             
1749             <span class="comment">% Verifica que el elemento este bien definido</span>
1750             <span class="keyword">if</span> ~isa(elemento, <span class="string">'Elemento'</span>)
1751                 error(<span class="string">'El elemento no pertenece a la clase Elemento'</span>);
1752             <span class="keyword">end</span>
1753             
1754             <span class="comment">% Realiza calculos de esfuerzo</span>
1755             fprintf(<span class="string">'Calculando esfuerzos elemento:\n'</span>);
1756             fprintf(<span class="string">'\tElemento %s\n'</span>, elemento.obtenerEtiqueta());
1757             ctitle = analisisObj.imprimirPropiedadesAnalisisCarga(carga);
1758             [~, esf, maxp, dirk] = analisisObj.calcularEsfuerzosElemento(carga, elemento, direccion);
1759             
1760             <span class="comment">% Genera el vector de tiempo</span>
1761             t = carga.obtenerVectorTiempo(); <span class="comment">% Vector de tiempo</span>
1762             <span class="keyword">if</span> tlim == 0
1763                 tlim = [min(t), max(t)];
1764             <span class="keyword">else</span>
1765                 tlim = [max(min(tlim), min(t)), min(max(tlim), max(t))];
1766             <span class="keyword">end</span>
1767             
1768             dirn = <span class="string">''</span>;
1769             diru = <span class="string">''</span>;
1770             <span class="keyword">if</span> dirk == 1
1771                 dirn = <span class="string">'Axial'</span>;
1772                 diru = r.unidadC;
1773             <span class="keyword">elseif</span> dirk == 2
1774                 dirn = <span class="string">'Corte'</span>;
1775                 diru = r.unidadC;
1776             <span class="keyword">elseif</span> dirk == 3
1777                 dirn = <span class="string">'Giro'</span>;
1778                 diru = r.unidadM;
1779             <span class="keyword">end</span>
1780             
1781             <span class="comment">% Crea el grafico</span>
1782             fig_title = sprintf(<span class="string">'%s %s - Elemento %s - Direccion %s'</span>, <span class="keyword">...</span>
1783                 ctitle, carga.obtenerEtiqueta(), elemento.obtenerEtiqueta(), dirn);
1784             plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1785             movegui(plt, <span class="string">'center'</span>);
1786             
1787             <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, esf(dirk, :), <span class="string">'-'</span>, <span class="string">'LineWidth'</span>, 1);
1788             ylabel(sprintf(<span class="string">'Esfuerzo (%s)'</span>, diru));
1789             xlabel(<span class="string">'t (s)'</span>);
1790             hold on;
1791             
1792             <span class="comment">% Grafica el maximo</span>
1793             <a href="../../tefame/lib/drawVyLine.html" class="code" title="function obj = drawVyLine(y, style, lw)">drawVyLine</a>(esf(dirk, maxp), <span class="string">'k--'</span>, 1.25);
1794             xlim(tlim);
1795             grid on;
1796             title(fig_title);
1797             
1798             legend({sprintf(<span class="string">'Esfuerzo elemento: %s'</span>, carga.obtenerEtiqueta()), <span class="keyword">...</span>
1799                 sprintf(<span class="string">'Esfuerzo maximo: %.2f (%s)'</span>, esf(dirk, maxp), diru)}, <span class="keyword">...</span>
1800                 <span class="string">'location'</span>, <span class="string">'southeast'</span>);
1801             
1802             <span class="comment">% Finaliza proceso</span>
1803             fprintf(<span class="string">'\tProceso finalizado en %.2f segundos\n'</span>, cputime-tinicial);
1804             <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
1805             
1806         <span class="keyword">end</span> <span class="comment">% plotEsfuerzosElemento function</span>
1807         
1808         <a name="_sub22" href="#_subfunctions" class="code">function plotTrayectoriaNodo(analisisObj, carga, nodo, direccion, varargin)</a>
1809             <span class="comment">% plotTrayectoriaNodo: Grafica la trayectoria de un nodo</span>
1810             <span class="comment">% (desplazamiento, velocidad y aceleracion) para todo el tiempo</span>
1811             <span class="comment">%</span>
1812             <span class="comment">% plotTrayectoriaNodo(analisisObj,carga,nodo,direccion,varargin)</span>
1813             <span class="comment">%</span>
1814             <span class="comment">% Parametros opcionales:</span>
1815             <span class="comment">%   'tlim'      Tiempo de analisis limite</span>
1816             <span class="comment">%   'unidadC'   Unidad carga</span>
1817             <span class="comment">%   'unidadL'   Unidad longitud</span>
1818             
1819             <span class="comment">% Inicia proceso</span>
1820             tinicial = cputime;
1821             
1822             <span class="comment">% Verifica que la direccion sea correcta</span>
1823             <span class="keyword">if</span> sum(direccion) ~= 1
1824                 error(<span class="string">'Direccion invalida'</span>);
1825             <span class="keyword">end</span>
1826             <span class="keyword">if</span> ~<a href="../../tefame/utils/verificarVectorDireccion.html" class="code" title="function y = verificarVectorDireccion(vec, ndg)">verificarVectorDireccion</a>(direccion, nodo.obtenerNumeroGDL())
1827                 error(<span class="string">'Vector direccion mal definido'</span>);
1828             <span class="keyword">end</span>
1829             
1830             <span class="comment">% Recorre parametros opcionales</span>
1831             p = inputParser;
1832             p.KeepUnmatched = true;
1833             addOptional(p, <span class="string">'tlim'</span>, 0);
1834             addOptional(p, <span class="string">'unidadC'</span>, <span class="string">'tonf'</span>);
1835             addOptional(p, <span class="string">'unidadL'</span>, <span class="string">'m'</span>);
1836             parse(p, varargin{:});
1837             r = p.Results;
1838             
1839             <span class="comment">% Obtiene las variables</span>
1840             tlim = r.tlim;
1841             
1842             <span class="comment">% Obtiene resultados de la carga</span>
1843             p_c = carga.obtenerCarga();
1844             u_c = carga.obtenerDesplazamiento();
1845             v_c = carga.obtenerVelocidad();
1846             a_c = carga.obtenerAceleracion();
1847             
1848             <span class="comment">% Verifica que la carga se haya calculado</span>
1849             <span class="keyword">if</span> ~(isa(carga, <span class="string">'CargaDinamica'</span>) || isa(carga, <span class="string">'CombinacionCargas'</span>))
1850                 error(<span class="string">'Solo se pueden graficar cargas dinamicas o combinaciones de cargas'</span>);
1851             <span class="keyword">end</span>
1852             <span class="keyword">if</span> ~carga.cargaCalculada()
1853                 error(<span class="string">'La carga %s no se ha calculado'</span>, carga.obtenerEtiqueta());
1854             <span class="keyword">end</span>
1855             
1856             fprintf(<span class="string">'Calculando trayectoria nodo:\n'</span>);
1857             fprintf(<span class="string">'\tNodo %s\n'</span>, nodo.obtenerEtiqueta());
1858             ctitle = analisisObj.imprimirPropiedadesAnalisisCarga(carga);
1859             
1860             <span class="comment">% Elige al nodo</span>
1861             [r, ~] = size(a_c);
1862             ngd = nodo.obtenerGDLIDCondensado();
1863             ng = 0; <span class="comment">% Numero grado analisis</span>
1864             nd = 0; <span class="comment">% Numero direccion analisis</span>
1865             <span class="keyword">for</span> i = 1:length(direccion)
1866                 <span class="keyword">if</span> direccion(i) == 1
1867                     ng = ngd(i);
1868                     nd = i;
1869                 <span class="keyword">end</span>
1870             <span class="keyword">end</span> <span class="comment">% for i</span>
1871             <span class="keyword">if</span> ng == 0
1872                 error(<span class="string">'No se ha obtenido el GDLID del nodo, es posible que corresponda a un apoyo o bien que el grado de libertad fue condensado'</span>);
1873             <span class="keyword">end</span>
1874             <span class="keyword">if</span> ng &gt; r
1875                 error(<span class="string">'El GDLID excede al soporte del sistema'</span>);
1876             <span class="keyword">end</span>
1877             
1878             <span class="comment">% Genera el vector de tiempo</span>
1879             t = carga.obtenerVectorTiempo(); <span class="comment">% Vector de tiempo</span>
1880             <span class="keyword">if</span> tlim == 0
1881                 tlim = [min(t), max(t)];
1882             <span class="keyword">else</span>
1883                 tlim = [max(min(tlim), min(t)), min(max(tlim), max(t))];
1884             <span class="keyword">end</span>
1885             
1886             <span class="comment">% Crea el grafico</span>
1887             fig_title = sprintf(<span class="string">'%s %s - Nodo %s - GDLID condensado %d - Direccion %d'</span>, <span class="keyword">...</span>
1888                 ctitle, carga.obtenerEtiqueta(), nodo.obtenerEtiqueta(), ng, nd);
1889             plt = figure(<span class="string">'Name'</span>, fig_title, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
1890             movegui(plt, <span class="string">'center'</span>);
1891             
1892             subplot(4, 1, 1);
1893             <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, p_c(ng, :), <span class="string">'k-'</span>, <span class="string">'LineWidth'</span>, 1);
1894             ylabel(sprintf(<span class="string">'carga (%s)'</span>, r.unidadC));
1895             xlabel(<span class="string">'t (s)'</span>);
1896             xlim(tlim);
1897             grid on;
1898             title(fig_title);
1899             
1900             subplot(4, 1, 2);
1901             <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, u_c(ng, :), <span class="string">'k-'</span>, <span class="string">'LineWidth'</span>, 1);
1902             title(<span class="string">'Desplazamiento'</span>);
1903             ylabel(sprintf(<span class="string">'u (%s)'</span>, r.unidadL));
1904             xlabel(<span class="string">'t (s)'</span>);
1905             xlim(tlim);
1906             grid on;
1907             
1908             subplot(4, 1, 3);
1909             <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, v_c(ng, :), <span class="string">'k-'</span>, <span class="string">'LineWidth'</span>, 1);
1910             title(<span class="string">'Velocidad'</span>);
1911             ylabel(sprintf(<span class="string">'v (%s/s)'</span>, r.unidadL));
1912             xlabel(<span class="string">'t (s)'</span>);
1913             xlim(tlim);
1914             grid on;
1915             
1916             subplot(4, 1, 4);
1917             <a href="#_sub15" class="code" title="subfunction plt = plot(analisisObj, varargin)">plot</a>(t, a_c(ng, :), <span class="string">'k-'</span>, <span class="string">'LineWidth'</span>, 1);
1918             title(<span class="string">'Aceleracion'</span>);
1919             ylabel(sprintf(<span class="string">'a (%s/s^s)'</span>, r.unidadL));
1920             xlabel(<span class="string">'t (s)'</span>);
1921             xlim(tlim);
1922             grid on;
1923             
1924             <span class="comment">% Finaliza proceso</span>
1925             fprintf(<span class="string">'\tProceso finalizado en %.2f segundos\n'</span>, cputime-tinicial);
1926             <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
1927             
1928         <span class="keyword">end</span> <span class="comment">% plotTrayectoriaNodo function</span>
1929         
1930         <a name="_sub23" href="#_subfunctions" class="code">function activarCargaAnimacion(analisisObj)</a>
1931             <span class="comment">% activarCargaAnimacion: Carga la animacion  una vez calculada</span>
1932             <span class="comment">%</span>
1933             <span class="comment">% activarCargaAnimacion(analisisObj)</span>
1934             
1935             analisisObj.cargarAnimacion = true;
1936             
1937         <span class="keyword">end</span> <span class="comment">% activarCargaAnimacion funcion</span>
1938         
1939         <a name="_sub24" href="#_subfunctions" class="code">function desactivarCargaAnimacion(analisisObj)</a>
1940             <span class="comment">% desactivarCargaAnimacion: Desactiva la animacion una vez calculada</span>
1941             <span class="comment">%</span>
1942             <span class="comment">% desactivarCargaAnimacion(analisisObj)</span>
1943             
1944             analisisObj.cargarAnimacion = false;
1945             
1946         <span class="keyword">end</span> <span class="comment">% desactivarCargaAnimacion funcion</span>
1947         
1948         <a name="_sub25" href="#_subfunctions" class="code">function activarPlotDeformadaInicial(analisisObj)</a>
1949             <span class="comment">% activarPlotDeformadaInicial: Activa el grafico de la deformada inicial</span>
1950             <span class="comment">%</span>
1951             <span class="comment">% activarPlotDeformadaInicial(analisisObj)</span>
1952             
1953             analisisObj.mostrarDeformada = true;
1954             
1955         <span class="keyword">end</span> <span class="comment">% activarPlotDeformadaInicial function</span>
1956         
1957         <a name="_sub26" href="#_subfunctions" class="code">function desactivarPlotDeformadaInicial(analisisObj)</a>
1958             <span class="comment">% desactivarPlotDeformadaInicial: Desactiva el grafico de la deformada inicial</span>
1959             <span class="comment">%</span>
1960             <span class="comment">% desactivarPlotDeformadaInicial(analisisObj)</span>
1961             
1962             analisisObj.mostrarDeformada = false;
1963             
1964         <span class="keyword">end</span> <span class="comment">% desactivarPlotDeformadaInicial function</span>
1965         
1966         <a name="_sub27" href="#_subfunctions" class="code">function disp(analisisObj)</a>
1967             <span class="comment">% disp: es un metodo de la clase ModalEspectral que se usa para imprimir en</span>
1968             <span class="comment">% command Window la informacion del analisis espectral realizado</span>
1969             <span class="comment">%</span>
1970             <span class="comment">% disp(analisisObj)</span>
1971             <span class="comment">%</span>
1972             <span class="comment">% Imprime la informacion guardada en el ModalEspectral (analisisObj) en</span>
1973             <span class="comment">% pantalla</span>
1974             
1975             <span class="keyword">if</span> ~analisisObj.analisisFinalizado
1976                 error(<span class="string">'El analisis modal aun no ha sido calculado'</span>);
1977             <span class="keyword">end</span>
1978             
1979             fprintf(<span class="string">'Propiedades analisis modal espectral:\n'</span>);
1980             
1981             <span class="comment">% Muestra los grados de libertad</span>
1982             fprintf(<span class="string">'\tNumero de grados de libertad: %d\n'</span>, <span class="keyword">...</span>
1983                 analisisObj.numeroGDL-analisisObj.gdlCond);
1984             fprintf(<span class="string">'\tNumero de grados condensados: %d\n'</span>, analisisObj.gdlCond);
1985             fprintf(<span class="string">'\tNumero de direcciones por grado: %d\n'</span>, analisisObj.numDG);
1986             fprintf(<span class="string">'\tNumero de modos en el analisis: %d\n'</span>, analisisObj.numModos);
1987             
1988             <span class="comment">% Propiedades de las matrices</span>
1989             detKt = det(analisisObj.Kt);
1990             detMt = det(analisisObj.Mt);
1991             <span class="keyword">if</span> detKt ~= Inf
1992                 fprintf(<span class="string">'\tMatriz de rigidez:\n'</span>);
1993                 fprintf(<span class="string">'\t\tDeterminante: %f\n'</span>, detKt);
1994             <span class="keyword">end</span>
1995             <span class="keyword">if</span> abs(detMt) &gt;= 1e-20
1996                 fprintf(<span class="string">'\tMatriz de Masa:\n'</span>);
1997                 fprintf(<span class="string">'\t\tDeterminante: %f\n'</span>, detMt);
1998             <span class="keyword">end</span>
1999             fprintf(<span class="string">'\tMasa total de la estructura: %.3f\n'</span>, analisisObj.Mtotal);
2000             
2001             fprintf(<span class="string">'\tPeriodos y participacion modal:\n'</span>);
2002             <span class="keyword">if</span> analisisObj.numDG == 2
2003                 fprintf(<span class="string">'\t\tN\t|\tT (s)\t| w (rad/s)\t|\tU1\t\t|\tU2\t\t|\tSum U1\t|\tSum U2\t|\n'</span>);
2004                 fprintf(<span class="string">'\t\t-----------------------------------------------------------------------------\n'</span>);
2005             <span class="keyword">elseif</span> analisisObj.numDG == 3
2006                 fprintf(<span class="string">'\t\tN\t|\tT (s)\t| w (rad/s)\t|\tU1\t\t|\tU2\t\t|\tU3\t\t|\tSum U1\t|\tSum U2\t|\tSum U3\t|\n'</span>);
2007                 fprintf(<span class="string">'\t\t----------------------------------------------------------------------------------------------------\n'</span>);
2008             <span class="keyword">end</span>
2009             
2010             <span class="keyword">for</span> i = 1:analisisObj.numModos
2011                 <span class="keyword">if</span> analisisObj.numDG == 2
2012                     fprintf(<span class="string">'\t\t%d\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\n'</span>, i, analisisObj.Tn(i), <span class="keyword">...</span>
2013                         analisisObj.wn(i), analisisObj.Mmeff(i, 1), analisisObj.Mmeff(i, 2), <span class="keyword">...</span>
2014                         analisisObj.Mmeffacum(i, 1), analisisObj.Mmeffacum(i, 2));
2015                 <span class="keyword">elseif</span> analisisObj.numDG == 3
2016                     fprintf(<span class="string">'\t\t%d\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\t|\t%.3f\n'</span>, i, analisisObj.Tn(i), <span class="keyword">...</span>
2017                         analisisObj.wn(i), analisisObj.Mmeff(i, 1), analisisObj.Mmeff(i, 2), analisisObj.Mmeff(i, 3), <span class="keyword">...</span>
2018                         analisisObj.Mmeffacum(i, 1), analisisObj.Mmeffacum(i, 2), analisisObj.Mmeffacum(i, 3));
2019                 <span class="keyword">end</span>
2020                 fprintf(<span class="string">'\n'</span>);
2021             <span class="keyword">end</span> <span class="comment">% for i</span>
2022             
2023             <span class="comment">% Busca los periodos para los cuales se logra el 90%</span>
2024             mt90p = zeros(analisisObj.numDG, 1);
2025             <span class="keyword">for</span> i = 1:analisisObj.numDG
2026                 fprintf(<span class="string">'\t\tN periodo en U%d para el 90%% de la masa: '</span>, i);
2027                 <span class="keyword">for</span> j = 1:analisisObj.numModos
2028                     <span class="keyword">if</span> analisisObj.Mmeffacum(j, i) &gt;= 0.90
2029                         mt90p(i) = j;
2030                         <span class="keyword">break</span>;
2031                     <span class="keyword">end</span>
2032                 <span class="keyword">end</span> <span class="comment">% for j</span>
2033                 <span class="keyword">if</span> mt90p(i) &gt; 0
2034                     fprintf(<span class="string">'%d\n'</span>, mt90p(i));
2035                 <span class="keyword">else</span>
2036                     fprintf(<span class="string">'Incrementar modos de analisis\n'</span>);
2037                 <span class="keyword">end</span>
2038             <span class="keyword">end</span> <span class="comment">% for i</span>
2039             
2040             <a href="../../tefame/utils/dispMetodoTEFAME.html" class="code" title="function dispMetodoTEFAME()">dispMetodoTEFAME</a>();
2041             
2042         <span class="keyword">end</span> <span class="comment">% disp function</span>
2043         
2044         <a name="_sub28" href="#_subfunctions" class="code">function c = obtenerCargaEstatica(analisisObj, varargin)</a>
2045             <span class="comment">% obtenerCargaEstatica: Obtiene la carga estatica del modelo</span>
2046             <span class="comment">% como una carga dinamica para ser incluida en las</span>
2047             <span class="comment">% combinaciones de cargas</span>
2048             <span class="comment">%</span>
2049             <span class="comment">% c = obtenerCargaEstatica(analisisObj,varargin)</span>
2050             <span class="comment">%</span>
2051             <span class="comment">% Parametros opcionales:</span>
2052             <span class="comment">%   'etiqueta'      Nombre de la carga</span>
2053             
2054             <span class="comment">% Recorre parametros opcionales</span>
2055             p = inputParser;
2056             p.KeepUnmatched = true;
2057             addOptional(p, <span class="string">'etiqueta'</span>, <span class="string">'Carga Estatica'</span>);
2058             parse(p, varargin{:});
2059             r = p.Results;
2060             
2061             c = <a href="../../tefame/modelo/cargas/CargaDinamica.html" class="code" title="">CargaDinamica</a>(r.etiqueta);
2062             c.dt = 1;
2063             c.tAnalisis = 1;
2064             
2065             <span class="comment">% Crea vector de velocidad y aceleracion ceros</span>
2066             v = zeros(length(analisisObj.u), 1);
2067             a = zeros(length(analisisObj.u), 1);
2068             
2069             c.guardarCarga(analisisObj.F);
2070             c.guardarDesplazamiento(analisisObj.u);
2071             c.guardarVelocidad(v);
2072             c.guardarAceleracion(a);
2073             
2074         <span class="keyword">end</span> <span class="comment">% obtenerCargaEstatica function</span>
2075         
2076     <span class="keyword">end</span> <span class="comment">% methods(public) ModalEspectral</span>
2077     
2078     methods(Access = private)
2079         
2080         <a name="_sub29" href="#_subfunctions" class="code">function definirNumeracionGDL(analisisObj)</a>
2081             <span class="comment">% definirNumeracionGDL: es un metodo de la clase ModalEspectral que</span>
2082             <span class="comment">% se usa para definir como se enumeran los GDL en el modelo</span>
2083             <span class="comment">%</span>
2084             <span class="comment">% definirNumeracionGDL(analisisObj)</span>
2085             <span class="comment">%</span>
2086             <span class="comment">% Define y asigna la enumeracion de los GDL en el modelo</span>
2087             
2088             fprintf(<span class="string">'\tDefiniendo numeracion GDL\n'</span>);
2089             
2090             <span class="comment">% Primero se aplican las restricciones al modelo</span>
2091             analisisObj.modeloObj.aplicarRestricciones();
2092             
2093             <span class="comment">% Extraemos los nodos para que sean enumerados</span>
2094             nodoObjetos = analisisObj.modeloObj.obtenerNodos();
2095             numeroNodos = length(nodoObjetos);
2096             
2097             <span class="comment">% Inicializamos en cero el contador de GDL</span>
2098             contadorGDL = 0;
2099             <span class="keyword">for</span> i = 1:numeroNodos
2100                 
2101                 gdlidNodo = nodoObjetos{i}.obtenerGDLID;
2102                 
2103                 <span class="comment">% Si no es reaccion entonces se agrega como GDL</span>
2104                 <span class="keyword">for</span> j = 1:length(gdlidNodo)
2105                     <span class="keyword">if</span> (gdlidNodo(j) == -1)
2106                         contadorGDL = contadorGDL + 1;
2107                         gdlidNodo(j) = contadorGDL;
2108                     <span class="keyword">end</span> <span class="comment">% if</span>
2109                 <span class="keyword">end</span> <span class="comment">% for j</span>
2110                 nodoObjetos{i}.definirGDLID(gdlidNodo);
2111                 
2112             <span class="keyword">end</span> <span class="comment">% for i</span>
2113             
2114             <span class="comment">% Guardamos el numero de GDL, es decir el numero de ecuaciones</span>
2115             <span class="comment">% del sistema</span>
2116             analisisObj.numeroGDL = contadorGDL;
2117             
2118             <span class="comment">% Extraemos los Elementos del modelo</span>
2119             elementoObjetos = analisisObj.modeloObj.obtenerElementos();
2120             disipadorObjetos = analisisObj.modeloObj.obtenerDisipadores();
2121             numeroElementos = length(elementoObjetos);
2122             numeroDisipadores = length(disipadorObjetos);
2123             <span class="comment">% Definimos los GDLID en los elementos para poder formar la matriz de rigidez</span>
2124             <span class="keyword">for</span> i = 1:numeroElementos
2125                 elementoObjetos{i}.definirGDLID();
2126             <span class="keyword">end</span> <span class="comment">% for i</span>
2127             
2128             <span class="keyword">for</span> i = 1:numeroDisipadores
2129                 disipadorObjetos{i}.definirGDLID();
2130             <span class="keyword">end</span> <span class="comment">% for i</span>
2131             
2132         <span class="keyword">end</span> <span class="comment">% definirNumeracionGDL function</span>
2133         
2134         <a name="_sub30" href="#_subfunctions" class="code">function calcularModalEspectral(analisisObj, nModos, betacR, modocR, </a><span class="keyword">...</span>
2135                 direcR, betacP, maxcond, valvecAlgoritmo, valvecTolerancia, <span class="keyword">...</span>
2136                 muIterDesplazamiento)
2137             <span class="comment">% calcularModalEspectral: Calcula el metodo modal espectral</span>
2138             <span class="comment">%</span>
2139             <span class="comment">% calcularModalEspectral(analisisObj,nModos,betacR,modocR,direcR,</span>
2140             <span class="comment">%   betacP,maxcond,valvecAlgoritmo,valvecTolerancia,muIterDesplazamiento)</span>
2141             
2142             <span class="comment">% Calcula tiempo inicio</span>
2143             fprintf(<span class="string">'\tCalculando metodo modal espectral:\n'</span>);
2144             tInicio = cputime;
2145             
2146             <span class="comment">% Obtiene matriz de masa</span>
2147             diagMt = diag(analisisObj.Mt);
2148             analisisObj.Mtotal = sum(diagMt) / 2;
2149             
2150             <span class="comment">% Obtiene los grados de libertad</span>
2151             ngdl = length(analisisObj.Mt); <span class="comment">% Numero de grados de libertad</span>
2152             ndg = analisisObj.modeloObj.obtenerNumerosGDL(); <span class="comment">% Grados de libertad por nodo</span>
2153             
2154             <span class="comment">% ---------------- CONDENSACION ESTATICA DE GUYAN ---------------</span>
2155             <span class="comment">% Primero se genera matriz para reordenar elementos (rot)</span>
2156             vz = []; <span class="comment">% Vector que identifica indices a condensar</span>
2157             j = 1;
2158             <span class="keyword">if</span> maxcond &gt;= 0
2159                 <span class="keyword">for</span> i = 1:length(diagMt)
2160                     <span class="keyword">if</span> diagMt(i) &lt;= maxcond
2161                         vz(j) = i; <span class="comment">%#ok&lt;AGROW&gt;</span>
2162                         j = j + 1;
2163                     <span class="keyword">end</span>
2164                 <span class="keyword">end</span> <span class="comment">% for i</span>
2165             <span class="keyword">end</span>
2166             
2167             <span class="comment">% Si condensa grados</span>
2168             analisisObj.gdlCond = length(vz);
2169             realizaCond = false;
2170             <span class="keyword">if</span> analisisObj.gdlCond &gt; 0
2171                 
2172                 realizaCond = true;
2173                 <span class="comment">% Chequea cuantos grados quedan</span>
2174                 nndg = ndg;
2175                 <span class="keyword">if</span> ndg &gt; 2
2176                     <span class="keyword">for</span> i = 2:ndg
2177                         <span class="comment">% Si todos los grados se dividen por 3, entonces se borra</span>
2178                         <span class="comment">% el tercer grado de libertad (giro por ejemplo)</span>
2179                         <span class="keyword">if</span> <a href="../../tefame/lib/allDivMod.html" class="code" title="function t = allDivMod(y, r)">allDivMod</a>(vz, i)
2180                             nndg = nndg - 1;
2181                         <span class="keyword">end</span>
2182                     <span class="keyword">end</span> <span class="comment">% for i</span>
2183                 <span class="keyword">end</span>
2184                 ndg = nndg;
2185                 
2186                 lpasivos = length(vz);
2187                 lactivos = length(diagMt) - lpasivos;
2188                 rot = zeros(length(diagMt), length(diagMt));
2189                 aux0 = 1;
2190                 aux1 = 1;
2191                 aux2 = length(diagMt) - lpasivos + 1;
2192                 <span class="keyword">for</span> i = 1:1:length(rot)
2193                     <span class="keyword">if</span> aux0 &lt;= length(vz) &amp;&amp; i == vz(aux0)
2194                         rot(i, aux2) = 1;
2195                         aux2 = aux2 + 1;
2196                         aux0 = aux0 + 1;
2197                     <span class="keyword">else</span>
2198                         rot(i, aux1) = 1;
2199                         aux1 = aux1 + 1;
2200                     <span class="keyword">end</span>
2201                 <span class="keyword">end</span> <span class="comment">% for i</span>
2202                 
2203                 <span class="comment">% Se realiza rotacion de matriz de rigidez</span>
2204                 Krot = rot' * analisisObj.Kt * rot;
2205                 
2206                 <span class="comment">% Se determina matriz de rigidez condensada (Keq)</span>
2207                 Kaa = Krot(1:lactivos, 1:lactivos);
2208                 Kap = Krot(1:lactivos, lactivos+1:end);
2209                 Kpa = Krot(lactivos+1:<span class="keyword">end</span>, 1:lactivos);
2210                 Kpp = Krot(lactivos+1:<span class="keyword">end</span>, lactivos+1:end);
2211                 Keq = Kaa - Kap * Kpp^(-1) * Kpa;
2212                 
2213                 <span class="comment">% Generacion de matriz T de condensacion</span>
2214                 If = size(Kaa, 1);
2215                 T1 = eye(If);
2216                 T2 = -(Kpp)^(-1) * (Kpa);
2217                 T = vertcat(T1, T2);
2218                 
2219                 <span class="comment">% Se determina matriz de masa condensada (Meq)</span>
2220                 Mrot = rot' * analisisObj.Mt * rot;
2221                 Meq = T' * Mrot * T;
2222                 
2223                 <span class="comment">% Condensa la fuerza estatica</span>
2224                 analisisObj.F = rot' * analisisObj.F;
2225                 analisisObj.F = T' * analisisObj.F;
2226                 
2227                 <span class="comment">% Condensa los desplazamientos estaticos</span>
2228                 analisisObj.u = rot' * analisisObj.u;
2229                 analisisObj.u = T' * analisisObj.u;
2230                 
2231                 <span class="comment">% Actualiza los grados</span>
2232                 cngdl = length(Meq);
2233                 <span class="keyword">if</span> cngdl &lt; ngdl
2234                     fprintf(<span class="string">'\t\tSe han condensado %d grados de libertad\n'</span>, ngdl-cngdl);
2235                     ngdl = cngdl;
2236                 <span class="keyword">end</span>
2237                 
2238                 <span class="comment">% Actualiza los nodos</span>
2239                 nodos = analisisObj.modeloObj.obtenerNodos();
2240                 nnodos = length(nodos);
2241                 <span class="keyword">for</span> i = 1:nnodos
2242                     gdl = nodos{i}.obtenerGDLID();
2243                     gdlaux = gdl;
2244                     <span class="keyword">for</span> j = 1:length(gdl)
2245                         <span class="keyword">for</span> k = 1:length(vz) <span class="comment">% Recorre los grados condensados</span>
2246                             <span class="keyword">if</span> vz(k) == gdl(j)
2247                                 gdlaux(j) = 0; <span class="comment">% gdl condensado</span>
2248                             <span class="keyword">elseif</span> vz(k) &lt; gdl(j)
2249                                 gdlaux(j) = gdlaux(j) - 1;
2250                             <span class="keyword">else</span>
2251                                 gdlaux(j) = gdlaux(j);
2252                             <span class="keyword">end</span>
2253                         <span class="keyword">end</span> <span class="comment">% for k</span>
2254                     <span class="keyword">end</span> <span class="comment">% for j</span>
2255                     nodos{i}.definirGDLIDCondensado(gdlaux);
2256                 <span class="keyword">end</span> <span class="comment">% for i</span>
2257                 
2258                 MtotalRed = sum(diag(Meq)) / 2;
2259                 fprintf(<span class="string">'\t\tTras la condensacion la masa se redujo en %.2f (%.2f%%)\n'</span>, <span class="keyword">...</span>
2260                     analisisObj.Mtotal-MtotalRed, 100*(analisisObj.Mtotal - MtotalRed)/analisisObj.Mtotal);
2261                 
2262             <span class="keyword">else</span> <span class="comment">% No condensa grados</span>
2263                 
2264                 Meq = analisisObj.Mt;
2265                 Keq = analisisObj.Kt;
2266                 fprintf(<span class="string">'\t\tNo se han condensado grados de libertad\n'</span>);
2267                 
2268             <span class="keyword">end</span>
2269             
2270             <span class="comment">% Una vez pasado este punto no deberian haber masas nulas o</span>
2271             <span class="comment">% incorrectas</span>
2272             <span class="keyword">for</span> i = 1:ngdl
2273                 <span class="keyword">if</span> Meq(i, i) &lt;= 0
2274                     error(<span class="string">'La matriz de masa esta mal definida, M(%d,%d)&lt;=0'</span>, i, i);
2275                 <span class="keyword">end</span>
2276             <span class="keyword">end</span> <span class="comment">% for i</span>
2277             
2278             fprintf(<span class="string">'\t\tGrados de libertad totales: %d\n'</span>, ngdl);
2279             fprintf(<span class="string">'\t\tNumero de direcciones de analisis: %d\n'</span>, ndg);
2280             nModos = min(nModos, ngdl);
2281             
2282             <span class="comment">%------------- CALCULO VALORES Y VECTORES PROPIOS ---------------</span>
2283             eigCalcT = cputime;
2284             
2285             <span class="keyword">if</span> strcmp(valvecAlgoritmo, <span class="string">'eigs'</span>)
2286                 fprintf(<span class="string">'\t\tCalculo valores y vectores propios con metodo eigs\n'</span>);
2287                 [modalPhin, modalWn] = <a href="../../tefame/analisis/eig/calculoEigEigs.html" class="code" title="function [w, v] = calculoEigEigs(M, K, nModos)">calculoEigEigs</a>(Meq, Keq, nModos);
2288             <span class="keyword">elseif</span> strcmp(valvecAlgoritmo, <span class="string">'itDir'</span>)
2289                 fprintf(<span class="string">'\t\tCalculo valores y vectores con algoritmo iteracion directa\n'</span>);
2290                 fprintf(<span class="string">'\t\t\tTolerancia: %.4f\n'</span>, valvecTolerancia);
2291                 [modalPhin, modalWn] = <a href="../../tefame/analisis/eig/calculoEigIterDirecta.html" class="code" title="function [v, w, error] = calculoEigIterDirecta(M, K, tol)">calculoEigIterDirecta</a>(Meq, Keq, valvecTolerancia);
2292                 nModos = length(modalWn);
2293             <span class="keyword">elseif</span> strcmp(valvecAlgoritmo, <span class="string">'matBarr'</span>)
2294                 fprintf(<span class="string">'\t\tCalculo valores y vectores propios con algoritmo matriz de barrido\n'</span>);
2295                 fprintf(<span class="string">'\t\t\tTolerancia: %.4f\n'</span>, valvecTolerancia);
2296                 [modalPhin, modalWn] = <a href="../../tefame/analisis/eig/calculoEigDirectaBarrido.html" class="code" title="function [v, w, error] = calculoEigDirectaBarrido(M, K, nModos, tol)">calculoEigDirectaBarrido</a>(Meq, Keq, nModos, valvecTolerancia);
2297             <span class="comment">% elseif strcmp(valvecAlgoritmo, 'itInv')</span>
2298             <span class="comment">%     fprintf('\t\tCalculo valores y vectores propios con metodo iteracion inversa\n');</span>
2299             <span class="keyword">elseif</span> strcmp(valvecAlgoritmo, <span class="string">'itInvDesp'</span>)
2300                 fprintf(<span class="string">'\t\tCalculo valores y vectores propios con metodo iteracion inversa con desplazamientos\n'</span>);
2301                 fprintf(<span class="string">'\t\t\tTolerancia: %.4f\n'</span>, valvecTolerancia);
2302                 fprintf(<span class="string">'\t\t\tMu: %.4f\n'</span>, muIterDesplazamiento);
2303                 [modalPhin, modalWn] = <a href="../../tefame/analisis/eig/calculoEigIterInvDesplazamiento.html" class="code" title="function [v, w, error] = calculoEigIterInvDesplazamiento(M, K, mu, tol)">calculoEigIterInvDesplazamiento</a>(Meq, Keq, muIterDesplazamiento, valvecTolerancia);
2304                 nModos = length(modalWn);
2305             <span class="keyword">elseif</span> strcmp(valvecAlgoritmo, <span class="string">'itSubesp'</span>)
2306                 fprintf(<span class="string">'\t\tCalculo valores y vectores propios con metodo iteracion del subespacio\n'</span>);
2307                 fprintf(<span class="string">'\t\t\tTolerancia: %.4f\n'</span>, valvecTolerancia);
2308                 [modalPhin, modalWn] = <a href="../../tefame/analisis/eig/calculoEigItSubespacio.html" class="code" title="function [v, w] = calculoEigItSubespacio(M, K, nModos, tol)">calculoEigItSubespacio</a>(Meq, Keq, nModos, valvecTolerancia);                
2309             <span class="keyword">else</span>
2310                 error(<span class="string">'Algoritmo valvec:%s incorrecto, valores posibles: eigvc,itDir,matBarr,itInvDesp,itSubesp'</span>, <span class="keyword">...</span>
2311                     valvecAlgoritmo);
2312             <span class="keyword">end</span>
2313             fprintf(<span class="string">'\t\t\tFinalizado en %.3f segundos\n'</span>, cputime-eigCalcT);
2314             analisisObj.numModos = nModos;
2315             
2316             <span class="comment">% Se recuperan los grados de libertad condensados y se</span>
2317             <span class="comment">% ordenan de acuerdo a la configuracion original</span>
2318             <span class="keyword">if</span> realizaCond
2319                 modalPhinFull = T * modalPhin;
2320                 rot_inv = rot^(-1);
2321                 modalPhinFull = rot_inv' * modalPhinFull;
2322                 analisisObj.condMatT = T;
2323                 analisisObj.condMatRot = rot_inv;
2324             <span class="keyword">else</span>
2325                 modalPhinFull = modalPhin;
2326                 analisisObj.condMatT = eye(length(modalPhin));
2327                 analisisObj.condMatRot = eye(length(modalPhin));
2328             <span class="keyword">end</span>
2329             
2330             <span class="comment">% Calcula las frecuencias del sistema</span>
2331             modalTn = (modalWn.^-1) .* 2 * pi(); <span class="comment">% Calcula los periodos</span>
2332             
2333             <span class="comment">% Calcula las matrices</span>
2334             modalMmt = modalPhin' * Meq * modalPhin;
2335             modalPhin = modalPhin * diag(diag(modalMmt).^-0.5);
2336             modalMm = diag(diag(modalPhin'*Meq*modalPhin));
2337             modalKm = diag(diag(modalPhin'*Keq*modalPhin));
2338             
2339             <span class="comment">% Reordena los periodos</span>
2340             Torder = zeros(nModos, 1);
2341             Tpos = 1;
2342             <span class="keyword">for</span> i = 1:nModos
2343                 maxt = 0; <span class="comment">% Periodo</span>
2344                 maxi = 0; <span class="comment">% Indice</span>
2345                 <span class="keyword">for</span> j = 1:nModos <span class="comment">% Se busca el elemento para etiquetar</span>
2346                     <span class="keyword">if</span> Torder(j) == 0 <span class="comment">% Si aun no se ha etiquetado</span>
2347                         <span class="keyword">if</span> modalTn(j) &gt; maxt
2348                             maxt = modalTn(j);
2349                             maxi = j;
2350                         <span class="keyword">end</span>
2351                     <span class="keyword">end</span>
2352                 <span class="keyword">end</span> <span class="comment">% for j</span>
2353                 Torder(maxi) = Tpos;
2354                 Tpos = Tpos + 1;
2355             <span class="keyword">end</span> <span class="comment">% for i</span>
2356             <span class="comment">% ngdl = length(Meq); % Numero de grados de libertad</span>
2357             
2358             <span class="comment">% Asigna valores</span>
2359             analisisObj.phinExt = modalPhinFull;
2360             analisisObj.Tn = zeros(nModos, 1);
2361             analisisObj.wn = zeros(nModos, 1);
2362             analisisObj.phin = zeros(ngdl, nModos);
2363             analisisObj.Mm = modalMm;
2364             analisisObj.Km = modalKm;
2365             analisisObj.Mteq = Meq;
2366             analisisObj.Kteq = Keq;
2367             <span class="keyword">for</span> i = 1:nModos
2368                 analisisObj.Tn(Torder(i)) = modalTn(i);
2369                 analisisObj.wn(Torder(i)) = modalWn(i);
2370                 analisisObj.phin(:, Torder(i)) = modalPhin(:, i);
2371             <span class="keyword">end</span> <span class="comment">% for i</span>
2372             
2373             <span class="comment">% Crea vector influencia</span>
2374             analisisObj.rm = zeros(ngdl, ndg);
2375             <span class="keyword">for</span> j = 1:ndg
2376                 <span class="keyword">for</span> i = 1:ngdl
2377                     <span class="keyword">if</span> mod(i, ndg) == j || (mod(i, ndg) == 0 &amp;&amp; j == ndg)
2378                         analisisObj.rm(i, j) = 1;
2379                     <span class="keyword">end</span>
2380                 <span class="keyword">end</span> <span class="comment">% for i</span>
2381             <span class="keyword">end</span> <span class="comment">% for j</span>
2382             
2383             <span class="comment">% Realiza el calculo de las participaciones modales</span>
2384             analisisObj.Lm = zeros(nModos, ndg);
2385             analisisObj.Mmeff = zeros(ngdl, ndg);
2386             analisisObj.Mmeffacum = zeros(ngdl, ndg);
2387             Mtotr = zeros(ndg, 1);
2388             
2389             <span class="comment">% Recorre cada grado de libertad (horizontal, vertical, giro)</span>
2390             <span class="keyword">for</span> j = 1:ndg
2391                 Mtotr(j) = sum(Meq*analisisObj.rm(:, j));
2392                 <span class="keyword">for</span> k = 1:nModos
2393                     analisisObj.Lm(k, j) = analisisObj.phin(:, k)' * Meq * analisisObj.rm(:, j);
2394                     analisisObj.Mmeff(k, j) = analisisObj.Lm(k, j).^2 ./ modalMm(k, k);
2395                 <span class="keyword">end</span> <span class="comment">% for k</span>
2396                 
2397                 analisisObj.Mmeff(:, j) = analisisObj.Mmeff(:, j) ./ Mtotr(j);
2398                 analisisObj.Mmeffacum(1, j) = analisisObj.Mmeff(1, j);
2399                 <span class="keyword">for</span> i = 2:nModos
2400                     analisisObj.Mmeffacum(i, j) = analisisObj.Mmeffacum(i-1, j) + analisisObj.Mmeff(i, j);
2401                 <span class="keyword">end</span> <span class="comment">% for i</span>
2402             <span class="keyword">end</span> <span class="comment">% for j</span>
2403             
2404             <span class="comment">% -------- CALCULO DE AMORTIGUAMIENTO DE RAYLEIGH -------------</span>
2405             
2406             <span class="comment">% Se recorren los numero de modos, si alguno es mayor a los</span>
2407             <span class="comment">% modos de analisis se reajusta y lanza warning</span>
2408             <span class="keyword">for</span> i = 1:length(modocR)
2409                 <span class="keyword">if</span> modocR(i) &gt; nModos
2410                     warning(<span class="string">'Modo de Rayleigh %d excede al numero de modos de analisis %d, se ha reajustado este ultimo'</span>, <span class="keyword">...</span>
2411                         modocR(i), nModos);
2412                     modocR(i) = nModos;
2413                 <span class="keyword">end</span>
2414             <span class="keyword">end</span> <span class="comment">% for i</span>
2415             
2416             countcR = [0, 0];
2417             m = 0;
2418             n = 0;
2419             <span class="keyword">for</span> i = 1:min(length(analisisObj.Mmeff), nModos)
2420                 <span class="keyword">if</span> analisisObj.Mmeff(i, 1) &gt; max(analisisObj.Mmeff(i, 2:ndg))
2421                     countcR(1) = countcR(1) + 1;
2422                     <span class="keyword">if</span> direcR(1) == <span class="string">'h'</span> &amp;&amp; modocR(1) == countcR(1)
2423                         m = i;
2424                     <span class="keyword">elseif</span> direcR(2) == <span class="string">'h'</span> &amp;&amp; modocR(2) == countcR(1)
2425                         n = i;
2426                     <span class="keyword">end</span>
2427                 <span class="keyword">elseif</span> analisisObj.Mmeff(i, 2) &gt; <span class="keyword">...</span>
2428                         max(analisisObj.Mmeff(i, 1), analisisObj.Mmeff(i, max(1, ndg)))
2429                     countcR(2) = countcR(2) + 1;
2430                     <span class="keyword">if</span> direcR(1) == <span class="string">'v'</span> &amp;&amp; modocR(1) == countcR(2)
2431                         m = i;
2432                     <span class="keyword">elseif</span> direcR(2) == <span class="string">'h'</span> &amp;&amp; modocR(2) == countcR(2)
2433                         n = i;
2434                     <span class="keyword">end</span>
2435                 <span class="keyword">end</span>
2436             <span class="keyword">end</span> <span class="comment">% for i</span>
2437             
2438             <span class="keyword">if</span> m == 0 || n == 0
2439                 warning(<span class="string">'Se requiere aumentar el numero de modos para determinar matriz de amortiguamiento de Rayleigh'</span>);
2440                 m = 1;
2441                 n = 1;
2442             <span class="keyword">end</span>
2443             w = analisisObj.wn;
2444             a = (2 * w(m) * w(n)) / (w(n)^2 - w(m)^2) .* [w(n), -w(m); <span class="keyword">...</span>
2445                 -1 / w(n), 1 / w(m)] * betacR';
2446             analisisObj.cRayleigh = a(1) .* Meq + a(2) .* Keq;
2447             
2448             <span class="comment">% ------ CALCULO DE AMORTIGUAMIENTO DE WILSON-PENZIEN ----------</span>
2449             <span class="comment">% Se declaran todos los amortiguamientos criticos del sistema,</span>
2450             <span class="comment">% (horizontal, vertical y rotacional)</span>
2451             d = zeros(length(analisisObj.Mmeff), length(analisisObj.Mmeff));
2452             w = analisisObj.wn;
2453             Mn = modalMmt;
2454             analisisObj.cPenzien = 0;
2455             
2456             <span class="keyword">for</span> i = 1:length(Mn)
2457                 <span class="keyword">if</span> analisisObj.Mmeff(i, 1) &gt; max(analisisObj.Mmeff(i, 2:ndg))
2458                     d(i, i) = 2 * betacP(1) * w(i) / Mn(i, i);
2459                 <span class="keyword">elseif</span> analisisObj.Mmeff(i, 2) &gt; <span class="keyword">...</span>
2460                         max(analisisObj.Mmeff(i, 1), analisisObj.Mmeff(i, max(1, ndg)))
2461                     d(i, i) = 2 * betacP(2) * w(i) / Mn(i, i);
2462                 <span class="keyword">else</span>
2463                     d(i, i) = 2 * betacP(3) * w(i) / Mn(i, i);
2464                 <span class="keyword">end</span>
2465                 analisisObj.cPenzien = analisisObj.cPenzien + <span class="keyword">...</span>
2466                     Meq * (d(i, i) * modalPhin(:, i) * modalPhin(:, i)') * Meq;
2467             <span class="keyword">end</span> <span class="comment">% for i</span>
2468             
2469             <span class="comment">% Termina el analisis</span>
2470             analisisObj.analisisFinalizado = true;
2471             analisisObj.numDG = ndg;
2472             analisisObj.numDGReal = analisisObj.modeloObj.obtenerNumerosGDL();
2473             fprintf(<span class="string">'\tSe completo el analisis en %.3f segundos\n'</span>, cputime-tInicio);
2474             
2475         <span class="keyword">end</span> <span class="comment">% calcularModalEspectral function</span>
2476         
2477         <a name="_sub31" href="#_subfunctions" class="code">function ensamblarMatrizRigidez(analisisObj)</a>
2478             <span class="comment">% ensamblarMatrizRigidez: es un metodo de la clase ModalEspectral que se usa para</span>
2479             <span class="comment">% realizar el armado de la matriz de rigidez del modelo analizado</span>
2480             <span class="comment">%</span>
2481             <span class="comment">% ensamblarMatrizRigidez(analisisObj)</span>
2482             <span class="comment">%</span>
2483             <span class="comment">% Ensambla la matriz de rigidez del modelo analizado usando el metodo</span>
2484             <span class="comment">% indicial</span>
2485             
2486             fprintf(<span class="string">'\tEnsamblando matriz de rigidez\n'</span>);
2487             analisisObj.Kt = zeros(analisisObj.numeroGDL, analisisObj.numeroGDL);
2488             
2489             <span class="comment">% Extraemos los Elementos</span>
2490             elementoObjetos = analisisObj.modeloObj.obtenerElementos();
2491             numeroElementos = length(elementoObjetos);
2492             
2493             <span class="comment">% Definimos los GDLID en los elementos</span>
2494             <span class="keyword">for</span> i = 1:numeroElementos
2495                 
2496                 <span class="comment">% Se obienen los gdl del elemento metodo indicial</span>
2497                 gdl = elementoObjetos{i}.obtenerGDLID();
2498                 ngdl = elementoObjetos{i}.obtenerNumeroGDL();
2499                 
2500                 <span class="comment">% Se obtiene la matriz de rigidez global del elemento-i</span>
2501                 k_globl_elem = elementoObjetos{i}.obtenerMatrizRigidezCoordGlobal();
2502                 
2503                 <span class="comment">% Se calcula el metodo indicial</span>
2504                 <span class="keyword">for</span> r = 1:ngdl
2505                     <span class="keyword">for</span> s = 1:ngdl
2506                         i_ = gdl(r);
2507                         j_ = gdl(s);
2508                         
2509                         <span class="comment">% Si corresponden a grados de libertad -&gt; puntos en (i,j)</span>
2510                         <span class="comment">% se suma contribucion metodo indicial</span>
2511                         <span class="keyword">if</span> (i_ ~= 0 &amp;&amp; j_ ~= 0)
2512                             analisisObj.Kt(i_, j_) = analisisObj.Kt(i_, j_) + k_globl_elem(r, s);
2513                         <span class="keyword">end</span>
2514                         
2515                     <span class="keyword">end</span> <span class="comment">% for s</span>
2516                 <span class="keyword">end</span> <span class="comment">% for r</span>
2517                 
2518             <span class="keyword">end</span> <span class="comment">% for i</span>
2519             
2520         <span class="keyword">end</span> <span class="comment">% ensamblarMatrizRigidez function</span>
2521         
2522         <a name="_sub32" href="#_subfunctions" class="code">function ensamblarMatrizMasa(analisisObj)</a>
2523             <span class="comment">% ensamblarMatrizMasa: es un metodo de la clase ModalEspectral que se usa para</span>
2524             <span class="comment">% realizar el armado de la matriz de masa del modelo</span>
2525             <span class="comment">%</span>
2526             <span class="comment">% ensamblarMatrizMasa(analisisObj)</span>
2527             <span class="comment">%</span>
2528             <span class="comment">% Ensambla la matriz de masa del modelo analizado usando el metodo</span>
2529             <span class="comment">% indicial</span>
2530             
2531             fprintf(<span class="string">'\tEnsamblando matriz de masa\n'</span>);
2532             analisisObj.Mt = zeros(analisisObj.numeroGDL, analisisObj.numeroGDL);
2533             
2534             <span class="comment">% Extraemos los Elementos</span>
2535             fprintf(<span class="string">'\t\tAgrega masa de elementos\n'</span>);
2536             elementoObjetos = analisisObj.modeloObj.obtenerElementos();
2537             numeroElementos = length(elementoObjetos);
2538             
2539             <span class="comment">% Definimos los GDLID en los elementos</span>
2540             <span class="keyword">for</span> i = 1:numeroElementos
2541                 
2542                 <span class="comment">% Se obienen los gdl del elemento metodo indicial</span>
2543                 gdl = elementoObjetos{i}.obtenerGDLID();
2544                 ngdl = elementoObjetos{i}.obtenerNumeroGDL();
2545                 
2546                 <span class="comment">% Se obtiene la matriz de masa</span>
2547                 m_elem = elementoObjetos{i}.obtenerVectorMasa();
2548                 
2549                 <span class="comment">% Se calcula el metodo indicial</span>
2550                 <span class="keyword">for</span> r = 1:ngdl
2551                     <span class="keyword">for</span> s = 1:ngdl
2552                         i_ = gdl(r);
2553                         j_ = gdl(s);
2554                         
2555                         <span class="comment">% Si corresponden a grados de libertad -&gt; puntos en (i,j)</span>
2556                         <span class="comment">% se suma contribucion metodo indicial</span>
2557                         <span class="keyword">if</span> (i_ ~= 0 &amp;&amp; j_ ~= 0 &amp;&amp; r == s)
2558                             analisisObj.Mt(i_, j_) = analisisObj.Mt(i_, j_) + m_elem(r);
2559                         <span class="keyword">end</span>
2560                         
2561                     <span class="keyword">end</span> <span class="comment">% for s</span>
2562                 <span class="keyword">end</span> <span class="comment">% for r</span>
2563                 
2564             <span class="keyword">end</span> <span class="comment">% for i</span>
2565             
2566             <span class="comment">% Masa de los elementos</span>
2567             mElementos = sum(diag(analisisObj.Mt)) / 2;
2568             
2569             <span class="comment">% Agrega las cargas</span>
2570             fprintf(<span class="string">'\t\tAgrega masa de cargas\n'</span>);
2571             pat = analisisObj.modeloObj.obtenerPatronesDeCargas();
2572             <span class="keyword">for</span> i = 1:length(pat)
2573                 
2574                 cargas = pat{i}.obtenerCargas();
2575                 <span class="keyword">for</span> j = 1:length(cargas)
2576                     
2577                     <span class="comment">% Si la carga ya sumo masa se bloquea</span>
2578                     <span class="keyword">if</span> ~cargas{j}.cargaSumaMasa()
2579                         <span class="keyword">continue</span>;
2580                     <span class="keyword">end</span>
2581                     
2582                     nodoCarga = cargas{j}.obtenerNodos();
2583                     m = cargas{j}.obtenerMasa();
2584                     
2585                     <span class="comment">% Recorre los nodos</span>
2586                     <span class="keyword">for</span> k = 1:length(nodoCarga)
2587                         
2588                         n = nodoCarga{i}.obtenerGDLID();
2589                         analisisObj.Mt(n(1), n(1)) = analisisObj.Mt(n(1), n(1)) + 0.5 * m;
2590                         analisisObj.Mt(n(2), n(2)) = analisisObj.Mt(n(2), n(2)) + 0.5 * m;
2591                         <span class="keyword">if</span> length(n) == 3
2592                             analisisObj.Mt(n(3), n(3)) = analisisObj.Mt(n(3), n(3)) + 1e-6;
2593                         <span class="keyword">end</span>
2594                         <span class="comment">% u(3) no se agrega dado que es el giro</span>
2595                         
2596                     <span class="keyword">end</span> <span class="comment">% for k</span>
2597                     
2598                     <span class="comment">% Bloquea la suma de masa de esta carga</span>
2599                     cargas{j}.bloquearCargaMasa();
2600                     
2601                 <span class="keyword">end</span> <span class="comment">% for j</span>
2602                 
2603             <span class="keyword">end</span> <span class="comment">% for i</span>
2604             
2605             <span class="comment">% Masa total</span>
2606             mTotal = sum(diag(analisisObj.Mt)) / 2;
2607             
2608             <span class="comment">% Masa de las cargas</span>
2609             mCargas = mTotal - mElementos;
2610             
2611             <span class="comment">% Despliega informacion</span>
2612             fprintf(<span class="string">'\tDistribucion de masa\n'</span>);
2613             fprintf(<span class="string">'\t\tMasa de elementos: %.1f (%.2f%%)\n'</span>, mElementos, <span class="keyword">...</span>
2614                 mElementos/mTotal*100);
2615             fprintf(<span class="string">'\t\tMasa de cargas: %.1f (%.2f%%)\n'</span>, mCargas, <span class="keyword">...</span>
2616                 mCargas/mTotal*100);
2617             fprintf(<span class="string">'\t\tMasa total: %.1f\n'</span>, mTotal);
2618             
2619         <span class="keyword">end</span> <span class="comment">% ensamblarMatrizMasa function</span>
2620         
2621         <a name="_sub33" href="#_subfunctions" class="code">function Cdv = ensamblarMatrizAmortiguamientoDisipadores(analisisObj)</a>
2622             <span class="comment">% ensamblarMatrizRigidez: es un metodo de la clase ModalEspectral</span>
2623             <span class="comment">% que se usa para realizar el armado de la matriz de</span>
2624             <span class="comment">% amortiguamiento de los disipadores del modelo</span>
2625             <span class="comment">%</span>
2626             <span class="comment">% Cdv = ensamblarMatrizAmortiguamientoDisipadores(analisisObj)</span>
2627             <span class="comment">%</span>
2628             <span class="comment">% Ensambla la matriz de rigidez del modelo analizado usando el metodo</span>
2629             <span class="comment">% indicial</span>
2630             
2631             <span class="comment">% fprintf('\tEnsamblando matriz de amortiguamiento disipadores\n');</span>
2632             ndglc = analisisObj.numeroGDL - analisisObj.gdlCond; <span class="comment">% Numero de grados de libertad condensados</span>
2633             Cdv = zeros(ndglc, ndglc);
2634             
2635             <span class="comment">% Extraemos los Elementos</span>
2636             disipadorObjetos = analisisObj.modeloObj.obtenerDisipadores();
2637             numeroDisipadores = length(disipadorObjetos);
2638             
2639             <span class="comment">% Definimos los GDLID en los elementos</span>
2640             <span class="keyword">for</span> i = 1:numeroDisipadores
2641                 
2642                 <span class="comment">% Se obienen los gdl del elemento metodo indicial</span>
2643                 gdl = disipadorObjetos{i}.obtenerGDLIDCondensado();
2644                 ngdl = disipadorObjetos{i}.obtenerNumeroGDL();
2645                 
2646                 <span class="comment">% Se obtiene la matriz de amortiguamiento global del elemento-i</span>
2647                 c_globl_elem = disipadorObjetos{i}.obtenerMatrizAmortiguamientoCoordGlobal();
2648                 
2649                 <span class="comment">% Se calcula el metodo indicial</span>
2650                 <span class="keyword">for</span> r = 1:ngdl
2651                     <span class="keyword">for</span> s = 1:ngdl
2652                         i_ = gdl(r);
2653                         j_ = gdl(s);
2654                         
2655                         <span class="comment">% Si corresponden a grados de libertad -&gt; puntos en (i,j)</span>
2656                         <span class="comment">% se suma contribucion metodo indicial</span>
2657                         <span class="keyword">if</span> (i_ ~= 0 &amp;&amp; j_ ~= 0)
2658                             Cdv(i_, j_) = Cdv(i_, j_) + c_globl_elem(r, s);
2659                         <span class="keyword">end</span>
2660                         
2661                     <span class="keyword">end</span> <span class="comment">% for s</span>
2662                 <span class="keyword">end</span> <span class="comment">% for r</span>
2663                 
2664             <span class="keyword">end</span> <span class="comment">% for i</span>
2665             
2666         <span class="keyword">end</span> <span class="comment">% ensamblarMatrizAmortiguamientoDisipadores function</span>
2667         
2668         <a name="_sub34" href="#_subfunctions" class="code">function Kdv = ensamblarMatrizRigidezDisipadores(analisisObj)</a>
2669             <span class="comment">% ensamblarMatrizRigidezDisipadores: es un metodo de la clase</span>
2670             <span class="comment">% ModalEspectral que se usa para realizar el armado de la matriz</span>
2671             <span class="comment">% de rigidez del modelo analizado</span>
2672             <span class="comment">%</span>
2673             <span class="comment">% Kdv = ensamblarMatrizRigidezDisipadores(analisisObj)</span>
2674             <span class="comment">%</span>
2675             <span class="comment">% Ensambla la matriz de rigidez de los disipadores del modelo</span>
2676             <span class="comment">% analizado usando el metodo indicial</span>
2677             
2678             <span class="comment">% fprintf('\tEnsamblando matriz de rigidez disipadores\n');</span>
2679             ndglc = analisisObj.numeroGDL - analisisObj.gdlCond; <span class="comment">% Numero de grados de libertad condensados</span>
2680             Kdv = zeros(ndglc, ndglc);
2681             
2682             <span class="comment">% Extraemos los elementos</span>
2683             disipadorObj = analisisObj.modeloObj.obtenerDisipadores();
2684             numeroDisipadores = length(disipadorObj);
2685             
2686             <span class="comment">% Definimos los GDLID en los elementos</span>
2687             <span class="keyword">for</span> i = 1:numeroDisipadores
2688                 
2689                 <span class="comment">% Se obienen los gdl del elemento metodo indicial</span>
2690                 gdl = disipadorObj{i}.obtenerGDLIDCondensado();
2691                 ngdl = disipadorObj{i}.obtenerNumeroGDL();
2692                 
2693                 <span class="comment">% Se obtiene la matriz de amortiguamiento global del elemento-i</span>
2694                 k_globl_elem = disipadorObj{i}.obtenerMatrizRigidezCoordGlobal();
2695                 
2696                 <span class="comment">% Se calcula el metodo indicial</span>
2697                 <span class="keyword">for</span> r = 1:ngdl
2698                     <span class="keyword">for</span> s = 1:ngdl
2699                         i_ = gdl(r);
2700                         j_ = gdl(s);
2701                         
2702                         <span class="comment">% Si corresponden a grados de libertad -&gt; puntos en (i,j)</span>
2703                         <span class="comment">% se suma contribucion metodo indicial</span>
2704                         <span class="keyword">if</span> (i_ ~= 0 &amp;&amp; j_ ~= 0)
2705                             Kdv(i_, j_) = Kdv(i_, j_) + k_globl_elem(r, s);
2706                         <span class="keyword">end</span>
2707                         
2708                     <span class="keyword">end</span> <span class="comment">% for s</span>
2709                 <span class="keyword">end</span> <span class="comment">% for r</span>
2710                 
2711             <span class="keyword">end</span> <span class="comment">% for i</span>
2712             
2713         <span class="keyword">end</span> <span class="comment">% ensamblarMatrizAmortiguamientoDisipadores function</span>
2714         
2715         <a name="_sub35" href="#_subfunctions" class="code">function ensamblarVectorFuerzas(analisisObj)</a>
2716             <span class="comment">% ensamblarVectorFuerzas: es un metodo de la clase ModalEspectral que se usa para</span>
2717             <span class="comment">% realizar el armado del vector de fuerzas del modelo analizado</span>
2718             <span class="comment">%</span>
2719             <span class="comment">% ensamblarVectorFuerzas(analisisObj)</span>
2720             <span class="comment">%</span>
2721             <span class="comment">% Ensambla el vector de fuerzas del modelo analizado usando el metodo</span>
2722             <span class="comment">% indicial</span>
2723             
2724             analisisObj.F = zeros(analisisObj.numeroGDL, 1);
2725             
2726             <span class="comment">% En esta funcion se tiene que ensamblar el vector de fuerzas</span>
2727             <span class="comment">% Extraemos los nodos</span>
2728             nodoObjetos = analisisObj.modeloObj.obtenerNodos();
2729             numeroNodos = length(nodoObjetos);
2730             
2731             <span class="comment">% Definimos los GDLID en los nodos</span>
2732             <span class="keyword">for</span> i = 1:numeroNodos
2733                 
2734                 ngdlid = nodoObjetos{i}.obtenerNumeroGDL(); <span class="comment">% Numero grados de libertad del nodo</span>
2735                 gdl = nodoObjetos{i}.obtenerGDLID(); <span class="comment">% Grados de libertad del nodo</span>
2736                 reacc = nodoObjetos{i}.obtenerReacciones(); <span class="comment">% Reacciones del nodo</span>
2737                 
2738                 <span class="comment">% Recorre cada grado de libertad, si no es cero entonces</span>
2739                 <span class="comment">% hay una carga aplicada en ese grado de libertad para</span>
2740                 <span class="comment">% lograr el equilibrio</span>
2741                 <span class="keyword">for</span> j = 1:ngdlid
2742                     <span class="keyword">if</span> (gdl(j) ~= 0)
2743                         analisisObj.F(gdl(j)) = -reacc(j);
2744                     <span class="keyword">end</span>
2745                 <span class="keyword">end</span> <span class="comment">% for j</span>
2746                 
2747             <span class="keyword">end</span> <span class="comment">% for i</span>
2748             
2749         <span class="keyword">end</span> <span class="comment">% ensamblarVectorFuerzas function</span>
2750         
2751         <a name="_sub36" href="#_subfunctions" class="code">function plotAnimado(analisisObj, deformada, modo, factor, phif, limx, limy, limz, </a><span class="keyword">...</span>
2752                 per, cuadro, totCuadros, defElem, defCarga, carga, tcarga, tcargaEq, <span class="keyword">...</span>
2753                 mostrarEstatico, mostrarDisipadores, styleNodoE, sizeNodoE, <span class="keyword">...</span>
2754                 styleNodoD, sizeNodoD, styleElemE, lwElemE, styleElemD, lwElemD, <span class="keyword">...</span>
2755                 styleDisipador, colorDisipador, lwDisipador, unidad, <span class="keyword">...</span>
2756                 angAzh, angPol)
2757             <span class="comment">% plotAnimado: Anima el grafico en funcion del numero del modo</span>
2758             
2759             <span class="comment">% Si se grafica la carga no se aplica el factor sin(wt)</span>
2760             <span class="keyword">if</span> defCarga
2761                 phif = 1;
2762             <span class="keyword">end</span>
2763             
2764             <span class="comment">% Carga objetos</span>
2765             nodoObjetos = analisisObj.modeloObj.obtenerNodos();
2766             numeroNodos = length(nodoObjetos);
2767             
2768             <span class="comment">% Obtiene cuantos GDL tiene el modelo</span>
2769             gdl = 2;
2770             ngdl = analisisObj.modeloObj.obtenerNumeroDimensiones();
2771             j = 1;
2772             <span class="keyword">for</span> i = 1:numeroNodos
2773                 coords = nodoObjetos{i}.obtenerCoordenadas();
2774                 ngdlid = length(coords);
2775                 gdl = max(gdl, ngdlid);
2776                 <span class="keyword">if</span> ~deformada &amp;&amp; mostrarEstatico
2777                     <span class="keyword">if</span> modo ~= 0 || defCarga
2778                         nodoObjetos{i}.plot([], styleNodoE, sizeNodoE);
2779                     <span class="keyword">else</span>
2780                         nodoObjetos{i}.plot([], styleNodoD, sizeNodoD);
2781                     <span class="keyword">end</span>
2782                     <span class="keyword">if</span> j == 1
2783                         hold on;
2784                     <span class="keyword">end</span>
2785                     j = j + 1;
2786                 <span class="keyword">end</span>
2787             <span class="keyword">end</span> <span class="comment">% for i</span>
2788             
2789             <span class="comment">% Grafica los elementos</span>
2790             elementoObjetos = analisisObj.modeloObj.obtenerElementos();
2791             numeroElementos = length(elementoObjetos);
2792             <span class="keyword">for</span> i = 1:numeroElementos
2793                 
2794                 <span class="comment">% Se obienen los gdl del elemento metodo indicial</span>
2795                 nodoElemento = elementoObjetos{i}.obtenerNodos();
2796                 numNodo = length(nodoElemento);
2797                 
2798                 <span class="keyword">if</span> (~deformada || analisisObj.mostrarDeformada) &amp;&amp; mostrarEstatico
2799                     <span class="keyword">if</span> modo ~= 0 || defCarga
2800                         elementoObjetos{i}.plot({}, styleElemE, lwElemE, false);
2801                     <span class="keyword">else</span>
2802                         elementoObjetos{i}.plot({}, styleElemD, lwElemD, false);
2803                     <span class="keyword">end</span>
2804                 <span class="keyword">end</span>
2805                 
2806                 <span class="keyword">if</span> deformada
2807                     def = cell(numNodo, 1);
2808                     <span class="keyword">for</span> j = 1:numNodo
2809                         def{j} = factor * phif * analisisObj.obtenerDeformadaNodo(nodoElemento{j}, <span class="keyword">...</span>
2810                             modo, analisisObj.numDGReal, defCarga, carga, tcarga);
2811                     <span class="keyword">end</span> <span class="comment">% for j</span>
2812                     elementoObjetos{i}.plot(def, styleElemD, lwElemD, defElem);
2813                     <span class="keyword">if</span> i == 1
2814                         hold on;
2815                     <span class="keyword">end</span>
2816                 <span class="keyword">end</span>
2817                 
2818             <span class="keyword">end</span> <span class="comment">% for i</span>
2819             
2820             <span class="comment">% Grafica los nodos deformados</span>
2821             <span class="keyword">if</span> deformada
2822                 <span class="keyword">for</span> i = 1:numeroNodos
2823                     coords = nodoObjetos{i}.obtenerCoordenadas();
2824                     ngdlid = length(coords);
2825                     gdl = max(gdl, ngdlid);
2826                     def = analisisObj.obtenerDeformadaNodo(nodoObjetos{i}, modo, <span class="keyword">...</span>
2827                         gdl, defCarga, carga, tcarga);
2828                     nodoObjetos{i}.plot(def.*factor*phif, styleNodoD, sizeNodoD);
2829                 <span class="keyword">end</span> <span class="comment">% for i</span>
2830             <span class="keyword">end</span>
2831             
2832             <span class="comment">% Grafica los disipadores</span>
2833             <span class="keyword">if</span> mostrarDisipadores
2834                 disipadores = analisisObj.modeloObj.obtenerDisipadores();
2835                 <span class="keyword">for</span> i = 1:length(disipadores)
2836                     nodoDisipador = disipadores{i}.obtenerNodos();
2837                     numnodoDisipador = disipadores{i}.obtenerNumeroNodos();
2838                     def = cell(numnodoDisipador, 1);
2839                     <span class="keyword">for</span> j = 1:numnodoDisipador
2840                         def{j} = factor * phif * analisisObj.obtenerDeformadaNodo(nodoDisipador{j}, <span class="keyword">...</span>
2841                             modo, analisisObj.numDGReal, defCarga, carga, tcarga);
2842                     <span class="keyword">end</span> <span class="comment">% for j</span>
2843                     disipadores{i}.plot(def, styleDisipador, lwDisipador, colorDisipador);
2844                 <span class="keyword">end</span> <span class="comment">% for i</span>
2845             <span class="keyword">end</span>
2846             
2847             <span class="comment">% Setea el titulo</span>
2848             <span class="keyword">if</span> ~defCarga <span class="comment">% Se grafica los modos</span>
2849                 <span class="keyword">if</span> ~deformada
2850                     title(<span class="string">'Analisis modal espectral'</span>);
2851                 <span class="keyword">else</span>
2852                     a = sprintf(<span class="string">'Analisis modal espectral - Modo %d (T: %.3fs)'</span>, modo, per);
2853                     <span class="keyword">if</span> totCuadros &gt; 1
2854                         b = sprintf(<span class="string">'Escala deformacion x%d - Cuadro %s/%d'</span>, <span class="keyword">...</span>
2855                             factor, <a href="../../tefame/lib/padFillNum.html" class="code" title="function y = padFillNum(x, a)">padFillNum</a>(cuadro, totCuadros), totCuadros);
2856                     <span class="keyword">else</span>
2857                         b = sprintf(<span class="string">'Escala deformacion x%d'</span>, factor);
2858                     <span class="keyword">end</span>
2859                     title({a; b});
2860                 <span class="keyword">end</span>
2861             <span class="keyword">else</span> <span class="comment">% Grafica una carga</span>
2862                 a = sprintf(<span class="string">'Analisis modal espectral - Carga %s'</span>, carga.obtenerEtiqueta());
2863                 b = sprintf(<span class="string">'Escala deformacion x%d - Cuadro %s/%d - t:%.3fs'</span>, <span class="keyword">...</span>
2864                     factor, <a href="../../tefame/lib/padFillNum.html" class="code" title="function y = padFillNum(x, a)">padFillNum</a>(cuadro, totCuadros), totCuadros, tcargaEq(cuadro));
2865                 title({a; b});
2866             <span class="keyword">end</span>
2867             grid on;
2868             
2869             <span class="comment">% Limita en los ejes</span>
2870             <span class="keyword">if</span> deformada || modo == 0
2871                 <span class="keyword">if</span> limx(1) &lt; limx(2)
2872                     xlim(limx);
2873                 <span class="keyword">end</span>
2874                 <span class="keyword">if</span> limy(1) &lt; limy(2)
2875                     ylim(limy);
2876                 <span class="keyword">end</span>
2877                 <span class="keyword">if</span> gdl == 3 &amp;&amp; limz(1) &lt; limz(2)
2878                     zlim(limz);
2879                 <span class="keyword">end</span>
2880             <span class="keyword">end</span>
2881             
2882             <span class="keyword">if</span> ngdl == 2
2883                 xlabel(sprintf(<span class="string">'X (%s)'</span>, unidad));
2884                 ylabel(sprintf(<span class="string">'Y (%s)'</span>, unidad));
2885             <span class="keyword">else</span>
2886                 xlabel(sprintf(<span class="string">'X (%s)'</span>, unidad));
2887                 ylabel(sprintf(<span class="string">'Y (%s)'</span>, unidad));
2888                 zlabel(sprintf(<span class="string">'Z (%s)'</span>, unidad));
2889                 view(angAzh, angPol);
2890             <span class="keyword">end</span>
2891             
2892         <span class="keyword">end</span> <span class="comment">% plotAnimado function</span>
2893         
2894         <a name="_sub37" href="#_subfunctions" class="code">function [limx, limy, limz] = obtenerLimitesDeformada(analisisObj, modo, factor, defcarga, carga)</a>
2895             <span class="comment">% obtenerLimitesDeformada: Obtiene los limites de deformacion</span>
2896             <span class="comment">%</span>
2897             <span class="comment">% obtenerLimitesDeformada(analisisObj,modo,factor,defcarga,carga)</span>
2898             
2899             fprintf(<span class="string">'\tCalculando los limites del grafico\n'</span>);
2900             factor = 2.5 * factor;
2901             limx = [inf, -inf];
2902             limy = [inf, -inf];
2903             limz = [inf, -inf];
2904             
2905             <span class="comment">% Carga objetos</span>
2906             nodoObjetos = analisisObj.modeloObj.obtenerNodos();
2907             numeroNodos = length(nodoObjetos);
2908             gdl = 2;
2909             <span class="keyword">for</span> i = 1:numeroNodos
2910                 coords = nodoObjetos{i}.obtenerCoordenadas();
2911                 ngdlid = length(coords);
2912                 gdl = max(gdl, ngdlid);
2913             <span class="keyword">end</span> <span class="comment">% for i</span>
2914             
2915             elementoObjetos = analisisObj.modeloObj.obtenerElementos();
2916             numeroElementos = length(elementoObjetos);
2917             <span class="keyword">for</span> i = 1:numeroElementos
2918                 nodoElemento = elementoObjetos{i}.obtenerNodos();
2919                 numNodo = length(nodoElemento);
2920                 <span class="keyword">for</span> j = 1:numNodo
2921                     coord = nodoElemento{j}.obtenerCoordenadas();
2922                     <span class="keyword">if</span> (analisisObj.analisisFinalizado &amp;&amp; modo &gt; 0) || defcarga
2923                         def = analisisObj.obtenerDeformadaNodo(nodoElemento{j}, modo, gdl, defcarga, carga, -1);
2924                         coordi = coord + def .* factor;
2925                     <span class="keyword">else</span>
2926                         coordi = coord;
2927                     <span class="keyword">end</span>
2928                     limx(1) = min(limx(1), coordi(1));
2929                     limy(1) = min(limy(1), coordi(2));
2930                     limx(2) = max(limx(2), coordi(1));
2931                     limy(2) = max(limy(2), coordi(2));
2932                     <span class="keyword">if</span> gdl == 3
2933                         limz(1) = min(limz(1), coordi(3));
2934                         limz(2) = max(limz(2), coordi(3));
2935                     <span class="keyword">end</span>
2936                     <span class="keyword">if</span> (analisisObj.analisisFinalizado &amp;&amp; modo &gt; 0) || defcarga
2937                         coordf = coord - def .* factor;
2938                     <span class="keyword">else</span>
2939                         coordf = coord;
2940                     <span class="keyword">end</span>
2941                     limx(1) = min(limx(1), coordf(1));
2942                     limy(1) = min(limy(1), coordf(2));
2943                     limx(2) = max(limx(2), coordf(1));
2944                     limy(2) = max(limy(2), coordf(2));
2945                     <span class="keyword">if</span> gdl == 3
2946                         limz(1) = min(limz(1), coordf(3));
2947                         limz(2) = max(limz(2), coordf(3));
2948                     <span class="keyword">end</span>
2949                 <span class="keyword">end</span> <span class="comment">% for j</span>
2950             <span class="keyword">end</span> <span class="comment">% for i</span>
2951             
2952         <span class="keyword">end</span> <span class="comment">% obtenerLimitesDeformada function</span>
2953         
2954         <a name="_sub38" href="#_subfunctions" class="code">function def = obtenerDeformadaNodo(analisisObj, nodo, modo, gdl, defcarga, carga, tcarga)</a>
2955             <span class="comment">% obtenerDeformadaNodo: Obtiene la deformada de un nodo</span>
2956             <span class="comment">%</span>
2957             <span class="comment">% obtenerDeformadaNodo(analisisObj,nodo,modo,gdl,defcarga,carga,tcarga)</span>
2958             
2959             ngdl = nodo.obtenerGDLIDCondensado();
2960             def = zeros(gdl, 1);
2961             gdl = min(gdl, length(ngdl));
2962             <span class="keyword">for</span> i = 1:gdl
2963                 <span class="keyword">if</span> ngdl(i) &gt; 0
2964                     <span class="keyword">if</span> ~defcarga <span class="comment">% La deformada la saca a partir del modo</span>
2965                         <span class="keyword">if</span> modo &gt; 0
2966                             def(i) = analisisObj.phin(ngdl(i), modo);
2967                         <span class="keyword">else</span>
2968                             def(i) = 0;
2969                         <span class="keyword">end</span>
2970                     <span class="keyword">else</span>
2971                         def(i) = carga.obtenerDesplazamientoTiempo(ngdl(i), tcarga);
2972                     <span class="keyword">end</span>
2973                 <span class="keyword">else</span>
2974                     def(i) = 0;
2975                 <span class="keyword">end</span>
2976             <span class="keyword">end</span> <span class="comment">% for i</span>
2977             
2978         <span class="keyword">end</span> <span class="comment">% obtenerDeformadaNodo function</span>
2979         
2980         <a name="_sub39" href="#_subfunctions" class="code">function [Cortante, Momento, CBplot, MBplot, hplot] = calcularMomentoCorteBasalAcel(analisisObj, acel)</a>
2981             <span class="comment">% calcularMomentoCorteBasalAcel: Calcula el momento y corte</span>
2982             <span class="comment">% basal en funcion de una aceleracion</span>
2983             <span class="comment">%</span>
2984             <span class="comment">% [Cortante,Momento,CBplot,MBplot,hplot] = calcularMomentoCorteBasalAcel(analisisObj,acel)</span>
2985             <span class="comment">%</span>
2986             <span class="comment">% Se genera vector en que las filas contienen nodos en un mismo piso,</span>
2987             <span class="comment">% rellenando con ceros la matriz en caso de diferencia de nodos por piso.</span>
2988             <span class="comment">% Tambien se genera vector que contiene alturas de piso</span>
2989             
2990             <span class="comment">% Iniciando el proceso</span>
2991             nodos = analisisObj.modeloObj.obtenerNodos();
2992             nnodos = length(nodos);
2993             
2994             habs = zeros(1, 1);
2995             hNodos = zeros(1, 1);
2996             j = 1;
2997             k = 1;
2998             ini = 1;
2999             <span class="keyword">for</span> i = 1:nnodos
3000                 CoordNodo = nodos{i}.obtenerCoordenadas;
3001                 yNodo = CoordNodo(2);
3002                 <span class="keyword">if</span> yNodo ~= habs(j)
3003                     k = 1;
3004                     j = j + 1;
3005                     habs(j, 1) = yNodo;
3006                     hNodos(j, k) = i;
3007                 <span class="keyword">elseif</span> i == 1
3008                     hNodos(j, k) = i;
3009                 <span class="keyword">else</span>
3010                     k = k + 1;
3011                     hNodos(j, k) = i;
3012                 <span class="keyword">end</span>
3013                 <span class="keyword">if</span> yNodo == 0
3014                     ini = ini + 1;
3015                 <span class="keyword">end</span>
3016             <span class="keyword">end</span> <span class="comment">% for i</span>
3017             
3018             [~, s] = size(acel);
3019             M = analisisObj.obtenerMatrizMasa();
3020             m = zeros(nnodos-ini+1, 1);
3021             acelx = zeros(nnodos-ini+1, s);
3022             Fnodos = zeros(nnodos-ini+1, s);
3023             Fpisos = zeros(length(habs)-1, s);
3024             
3025             <span class="comment">% Calculo de fuerzas inerciales nodales que generan corte, fuerzas nodales</span>
3026             <span class="comment">% y fuerzas por piso</span>
3027             <span class="keyword">for</span> i = ini:nnodos
3028                 gdls = nodos{i}.obtenerGDLIDCondensado();
3029                 gdlx = gdls(1);
3030                 acelx(i-ini+1, :) = acel(gdlx, :);
3031                 m(i-ini+1, 1) = M(gdlx, gdlx);
3032                 Fnodos(i-ini+1, :) = M(gdlx, gdlx) .* acel(gdlx, :);
3033                 [fil, ~] = find(hNodos == i);
3034                 Fpisos(fil-1, :) = Fpisos(fil-1, :) + Fnodos(i-ini+1, :);
3035             <span class="keyword">end</span> <span class="comment">% for i</span>
3036             
3037             <span class="comment">% Calculo de cortante y momento acumulado por piso</span>
3038             Fpisos_ud = flipud(Fpisos);
3039             habs_ud = flipud(habs);
3040             Cortante = zeros(length(habs)-1, s);
3041             Momento = zeros(length(habs)-1, s);
3042             <span class="keyword">for</span> i = 1:length(habs) - 1
3043                 hcero = habs_ud(i+1);
3044                 <span class="keyword">for</span> j = 1:i
3045                     Cortante(i, :) = Cortante(i, :) + Fpisos_ud(j, :);
3046                     Momento(i, :) = Momento(i, :) + Fpisos_ud(j, :) .* (habs_ud(j) - hcero);
3047                 <span class="keyword">end</span> <span class="comment">% for j</span>
3048             <span class="keyword">end</span> <span class="comment">% for i</span>
3049             
3050             <span class="comment">% Determinacion de envolvente maxima de cortante y momento basal</span>
3051             icor = 1;
3052             imom = 1;
3053             CorB_max = 1;
3054             MomB_max = 1;
3055             [nfil, ~] = size(Cortante);
3056             <span class="keyword">for</span> i = 1:s
3057                 <span class="keyword">if</span> abs(Cortante(nfil, i)) &gt; abs(CorB_max)
3058                     icor = i;
3059                     CorB_max = Cortante(nfil, i);
3060                 <span class="keyword">end</span>
3061                 <span class="keyword">if</span> abs(Momento(nfil, i)) &gt; abs(MomB_max)
3062                     imom = i;
3063                     MomB_max = Momento(nfil, i);
3064                 <span class="keyword">end</span>
3065             <span class="keyword">end</span> <span class="comment">% for i</span>
3066             
3067             <span class="comment">% Calcula las envolventes, aplica valor absoluto</span>
3068             VecCB = abs(Cortante(:, icor));
3069             VecMB = abs(Momento(:, imom));
3070             hgen = habs_ud;
3071             hplot = zeros(2*length(hgen), 1);
3072             CBplot = zeros(2*length(hgen)-1, 1);
3073             MBplot = zeros(2*length(hgen)-1, 1);
3074             aux1 = 1;
3075             aux2 = 2;
3076             <span class="keyword">for</span> i = 1:length(hgen)
3077                 hplot(aux1, 1) = hgen(i);
3078                 hplot(aux1+1, 1) = hgen(i);
3079                 <span class="keyword">if</span> aux2 &lt;= 2 * length(hgen) - 1
3080                     CBplot(aux2, 1) = VecCB(i);
3081                     CBplot(aux2+1, 1) = VecCB(i);
3082                     MBplot(aux2, 1) = VecMB(i);
3083                     MBplot(aux2+1, 1) = VecMB(i);
3084                 <span class="keyword">end</span>
3085                 aux1 = aux1 + 2;
3086                 aux2 = aux2 + 2;
3087             <span class="keyword">end</span> <span class="comment">% for i</span>
3088             hplot(length(hplot)) = [];
3089             
3090         <span class="keyword">end</span> <span class="comment">% calcularMomentoCorteBasalAcel function</span>
3091         
3092         <a name="_sub40" href="#_subfunctions" class="code">function ctitle = imprimirPropiedadesAnalisisCarga(analisisObj, carga) </a><span class="comment">%#ok&lt;INUSL&gt;</span>
3093             <span class="comment">% imprimirPropiedadesAnalisisCarga: Imprime propiedades de</span>
3094             <span class="comment">% analisis de la carga o combinacion de cargas</span>
3095             <span class="comment">%</span>
3096             <span class="comment">% ctitle = imprimirPropiedadesAnalisisCarga(analisisObj, carga)</span>
3097             
3098             ctitle = <span class="string">'Carga'</span>;
3099             <span class="keyword">if</span> isa(carga, <span class="string">'CombinacionCargas'</span>)
3100                 ctitle = <span class="string">'Combinacion'</span>;
3101             <span class="keyword">end</span>
3102             fprintf(<span class="string">'\t%s %s\n'</span>, ctitle, carga.obtenerEtiqueta());
3103             
3104             <span class="keyword">if</span> carga.usoAmortiguamientoRayleigh()
3105                 fprintf(<span class="string">'\t\tLa %s se calculo con amortiguamiento Rayleigh\n'</span>, lower(ctitle));
3106             <span class="keyword">else</span>
3107                 fprintf(<span class="string">'\t\tLa %s se calculo con amortiguamiento de Wilson-Penzien\n'</span>, lower(ctitle));
3108             <span class="keyword">end</span>
3109             
3110             <span class="keyword">if</span> carga.usoDescomposicionModal()
3111                 fprintf(<span class="string">'\t\tLa %s se calculo usando descomposicion modal\n'</span>, lower(ctitle));
3112             <span class="keyword">else</span>
3113                 fprintf(<span class="string">'\t\tLa %s se calculo sin usar descomposicion modal\n'</span>, lower(ctitle));
3114             <span class="keyword">end</span>
3115             
3116         <span class="keyword">end</span> <span class="comment">% imprimirPropiedadesAnalisisCarga function</span>
3117         
3118     <span class="keyword">end</span> <span class="comment">% methods(private) ModalEspectral</span>
3119     
3120 <span class="keyword">end</span> <span class="comment">% class ModalEspectral</span></pre></div>
<hr><address>Generated on Wed 15-May-2019 23:09:04 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>